# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019 Red Hat, Inc.
# This file is distributed under the same license as the Ansible package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Ansible devel\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-04 13:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../rst/user_guide/basic_concepts.rst:5
msgid "Ansible concepts"
msgstr ""

#: ../../rst/user_guide/basic_concepts.rst:7
msgid "These concepts are common to all uses of Ansible. You need to understand them to use Ansible for any kind of automation. This basic introduction provides the background you need to follow the rest of the User Guide."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:2
msgid "Control node"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:4
msgid "Any machine with Ansible installed. You can run Ansible commands and playbooks by invoking the ``ansible`` or ``ansible-playbook`` command from any control node. You can use any computer that has a Python installation as a control node - laptops, shared desktops, and servers can all run Ansible. However, you cannot use a Windows machine as a control node. You can have multiple control nodes."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:7
msgid "Managed nodes"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:9
msgid "The network devices (and/or servers) you manage with Ansible. Managed nodes are also sometimes called \"hosts\". Ansible is not installed on managed nodes."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:12
msgid "Inventory"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:14
msgid "A list of managed nodes. An inventory file is also sometimes called a \"hostfile\". Your inventory can specify information like IP address for each managed node. An inventory can also organize managed nodes, creating and nesting groups for easier scaling. To learn more about inventory, see :ref:`the Working with Inventory<intro_inventory>` section."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:17
msgid "Collections"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:19
msgid "Collections are a distribution format for Ansible content that can include playbooks, roles, modules, and plugins. You can install and use collections through `Ansible Galaxy <https://galaxy.ansible.com>`_. To learn more about collections, see :ref:`collections`."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:22
msgid "Modules"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:24
msgid "The units of code Ansible executes. Each module has a particular use, from administering users on a specific type of database to managing VLAN interfaces on a specific type of network device. You can invoke a single module with a task, or invoke several different modules in a playbook. Starting in Ansible 2.10, modules are grouped in collections. For an idea of how many collections Ansible includes, take a look at the :ref:`list_of_collections`."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:27
msgid "Tasks"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:29
msgid "The units of action in Ansible. You can execute a single task once with an ad-hoc command."
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:32
msgid "Playbooks"
msgstr ""

#: ../../rst/shared_snippets/basic_concepts.txt:34
msgid "Ordered lists of tasks, saved so you can run those tasks in that order repeatedly. Playbooks can include variables as well as tasks. Playbooks are written in YAML and are easy to read, write, share and understand. To learn more about playbooks, see :ref:`about_playbooks`."
msgstr ""

#: ../../rst/user_guide/become.rst:5
msgid "Understanding privilege escalation: become"
msgstr ""

#: ../../rst/user_guide/become.rst:7
msgid "Ansible uses existing privilege escalation systems to execute tasks with root privileges or with another user's permissions. Because this feature allows you to 'become' another user, different from the user that logged into the machine (remote user), we call it ``become``. The ``become`` keyword leverages existing privilege escalation tools like `sudo`, `su`, `pfexec`, `doas`, `pbrun`, `dzdo`, `ksu`, `runas`, `machinectl` and others."
msgstr ""

#: ../../rst/user_guide/become.rst:13
msgid "Using become"
msgstr ""

#: ../../rst/user_guide/become.rst:15
msgid "You can control the use of ``become`` with play or task directives, connection variables, or at the command line. If you set privilege escalation properties in multiple ways, review the :ref:`general precedence rules<general_precedence_rules>` to understand which settings will be used."
msgstr ""

#: ../../rst/user_guide/become.rst:17
msgid "A full list of all become plugins that are included in Ansible can be found in the :ref:`become_plugin_list`."
msgstr ""

#: ../../rst/user_guide/become.rst:20
msgid "Become directives"
msgstr ""

#: ../../rst/user_guide/become.rst:22
msgid "You can set the directives that control ``become`` at the play or task level. You can override these by setting connection variables, which often differ from one host to another. These variables and directives are independent. For example, setting ``become_user`` does not set ``become``."
msgstr ""

#: ../../rst/user_guide/become.rst:25
msgid "become"
msgstr ""

#: ../../rst/user_guide/become.rst:25
msgid "set to ``yes`` to activate privilege escalation."
msgstr ""

#: ../../rst/user_guide/become.rst:28
msgid "become_user"
msgstr ""

#: ../../rst/user_guide/become.rst:28
msgid "set to user with desired privileges â€” the user you `become`, NOT the user you login as. Does NOT imply ``become: yes``, to allow it to be set at host level. Default value is ``root``."
msgstr ""

#: ../../rst/user_guide/become.rst:31
msgid "become_method"
msgstr ""

#: ../../rst/user_guide/become.rst:31
msgid "(at play or task level) overrides the default method set in ansible.cfg, set to use any of the :ref:`become_plugins`."
msgstr ""

#: ../../rst/user_guide/become.rst:34
msgid "become_flags"
msgstr ""

#: ../../rst/user_guide/become.rst:34
msgid "(at play or task level) permit the use of specific flags for the tasks or role. One common use is to change the user to nobody when the shell is set to nologin. Added in Ansible 2.2."
msgstr ""

#: ../../rst/user_guide/become.rst:36
msgid "For example, to manage a system service (which requires ``root`` privileges) when connected as a non-``root`` user, you can use the default value of ``become_user`` (``root``):"
msgstr ""

#: ../../rst/user_guide/become.rst:46
msgid "To run a command as the ``apache`` user:"
msgstr ""

#: ../../rst/user_guide/become.rst:55
msgid "To do something as the ``nobody`` user when the shell is nologin:"
msgstr ""

#: ../../rst/user_guide/become.rst:66
msgid "To specify a password for sudo, run ``ansible-playbook`` with ``--ask-become-pass`` (``-K`` for short). If you run a playbook utilizing ``become`` and the playbook seems to hang, most likely it is stuck at the privilege escalation prompt. Stop it with `CTRL-c`, then execute the playbook with ``-K`` and the appropriate password."
msgstr ""

#: ../../rst/user_guide/become.rst:70
msgid "Become connection variables"
msgstr ""

#: ../../rst/user_guide/become.rst:72
msgid "You can define different ``become`` options for each managed node or group. You can define these variables in inventory or use them as normal variables."
msgstr ""

#: ../../rst/user_guide/become.rst:75
#: ../../rst/user_guide/intro_inventory.rst:573
#: ../../rst/user_guide/intro_inventory.rst:648
msgid "ansible_become"
msgstr ""

#: ../../rst/user_guide/become.rst:75
msgid "overrides the ``become`` directive, decides if privilege escalation is used or not."
msgstr ""

#: ../../rst/user_guide/become.rst:78
#: ../../rst/user_guide/intro_inventory.rst:575
msgid "ansible_become_method"
msgstr ""

#: ../../rst/user_guide/become.rst:78
msgid "which privilege escalation method should be used"
msgstr ""

#: ../../rst/user_guide/become.rst:81
#: ../../rst/user_guide/intro_inventory.rst:577
msgid "ansible_become_user"
msgstr ""

#: ../../rst/user_guide/become.rst:81
msgid "set the user you become through privilege escalation; does not imply ``ansible_become: yes``"
msgstr ""

#: ../../rst/user_guide/become.rst:84
#: ../../rst/user_guide/intro_inventory.rst:579
msgid "ansible_become_password"
msgstr ""

#: ../../rst/user_guide/become.rst:84
msgid "set the privilege escalation password. See :ref:`playbooks_vault` for details on how to avoid having secrets in plain text"
msgstr ""

#: ../../rst/user_guide/become.rst:87
msgid "ansible_common_remote_group"
msgstr ""

#: ../../rst/user_guide/become.rst:87
msgid "determines if Ansible should try to ``chgrp`` its temporary files to a group if ``setfacl`` and ``chown`` both fail. See `Risks of becoming an unprivileged user`_ for more information. Added in version 2.10."
msgstr ""

#: ../../rst/user_guide/become.rst:89
msgid "For example, if you want to run all tasks as ``root`` on a server named ``webserver``, but you can only connect as the ``manager`` user, you could use an inventory entry like this:"
msgstr ""

#: ../../rst/user_guide/become.rst:96
msgid "The variables defined above are generic for all become plugins but plugin specific ones can also be set instead. Please see the documentation for each plugin for a list of all options the plugin has and how they can be defined. A full list of become plugins in Ansible can be found at :ref:`become_plugins`."
msgstr ""

#: ../../rst/user_guide/become.rst:101
msgid "Become command-line options"
msgstr ""

#: ../../rst/user_guide/become.rst:104
msgid "ask for privilege escalation password; does not imply become will be used. Note that this password will be used for all hosts."
msgstr ""

#: ../../rst/user_guide/become.rst:107
msgid "run operations with become (no password implied)"
msgstr ""

#: ../../rst/user_guide/become.rst:110
msgid "privilege escalation method to use (default=sudo), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas | machinectl ]"
msgstr ""

#: ../../rst/user_guide/become.rst:114
msgid "run operations as this user (default=root), does not imply --become/-b"
msgstr ""

#: ../../rst/user_guide/become.rst:117
msgid "Risks and limitations of become"
msgstr ""

#: ../../rst/user_guide/become.rst:119
msgid "Although privilege escalation is mostly intuitive, there are a few limitations on how it works.  Users should be aware of these to avoid surprises."
msgstr ""

#: ../../rst/user_guide/become.rst:123
msgid "Risks of becoming an unprivileged user"
msgstr ""

#: ../../rst/user_guide/become.rst:125
msgid "Ansible modules are executed on the remote machine by first substituting the parameters into the module file, then copying the file to the remote machine, and finally executing it there."
msgstr ""

#: ../../rst/user_guide/become.rst:129
msgid "Everything is fine if the module file is executed without using ``become``, when the ``become_user`` is root, or when the connection to the remote machine is made as root. In these cases Ansible creates the module file with permissions that only allow reading by the user and root, or only allow reading by the unprivileged user being switched to."
msgstr ""

#: ../../rst/user_guide/become.rst:135
msgid "However, when both the connection user and the ``become_user`` are unprivileged, the module file is written as the user that Ansible connects as (the ``remote_user``), but the file needs to be readable by the user Ansible is set to ``become``. The details of how Ansible solves this can vary based on platform. However, on POSIX systems, Ansible solves this problem in the following way:"
msgstr ""

#: ../../rst/user_guide/become.rst:141
msgid "First, if :command:`setfacl` is installed and available in the remote ``PATH``, and the temporary directory on the remote host is mounted with POSIX.1e filesystem ACL support, Ansible will use POSIX ACLs to share the module file with the second unprivileged user."
msgstr ""

#: ../../rst/user_guide/become.rst:146
msgid "Next, if POSIX ACLs are **not** available or :command:`setfacl` could not be run, Ansible will attempt to change ownership of the module file using :command:`chown` for systems which support doing so as an unprivileged user."
msgstr ""

#: ../../rst/user_guide/become.rst:150
msgid "New in Ansible 2.11, at this point, Ansible will try :command:`chmod +a` which is a macOS-specific way of setting ACLs on files."
msgstr ""

#: ../../rst/user_guide/become.rst:153
msgid "New in Ansible 2.10, if all of the above fails, Ansible will then check the value of the configuration setting ``ansible_common_remote_group``. Many systems will allow a given user to change the group ownership of a file to a group the user is in. As a result, if the second unprivileged user (the ``become_user``) has a UNIX group in common with the user Ansible is connected as (the ``remote_user``), and if ``ansible_common_remote_group`` is defined to be that group, Ansible can try to change the group ownership of the module file to that group by using :command:`chgrp`, thereby likely making it readable to the ``become_user``."
msgstr ""

#: ../../rst/user_guide/become.rst:163
msgid "At this point, if ``ansible_common_remote_group`` was defined and a :command:`chgrp` was attempted and returned successfully, Ansible assumes (but, importantly, does not check) that the new group ownership is enough and does not fall back further. That is, Ansible **does not check** that the ``become_user`` does in fact share a group with the ``remote_user``; so long as the command exits successfully, Ansible considers the result successful and does not proceed to check ``allow_world_readable_tmpfiles`` per below."
msgstr ""

#: ../../rst/user_guide/become.rst:171
msgid "If ``ansible_common_remote_group`` is **not** set and the chown above it failed, or if ``ansible_common_remote_group`` *is* set but the :command:`chgrp` (or following group-permissions :command:`chmod`) returned a non-successful exit code, Ansible will lastly check the value of ``allow_world_readable_tmpfiles``. If this is set, Ansible will place the module file in a world-readable temporary directory, with world-readable permissions to allow the ``become_user`` (and incidentally any other user on the system) to read the contents of the file. **If any of the parameters passed to the module are sensitive in nature, and you do not trust the remote machines, then this is a potential security risk.**"
msgstr ""

#: ../../rst/user_guide/become.rst:182
msgid "Once the module is done executing, Ansible deletes the temporary file."
msgstr ""

#: ../../rst/user_guide/become.rst:184
msgid "Several ways exist to avoid the above logic flow entirely:"
msgstr ""

#: ../../rst/user_guide/become.rst:186
msgid "Use `pipelining`.  When pipelining is enabled, Ansible does not save the module to a temporary file on the client.  Instead it pipes the module to the remote python interpreter's stdin. Pipelining does not work for python modules involving file transfer (for example: :ref:`copy <copy_module>`, :ref:`fetch <fetch_module>`, :ref:`template <template_module>`), or for non-python modules."
msgstr ""

#: ../../rst/user_guide/become.rst:192
msgid "Avoid becoming an unprivileged user.  Temporary files are protected by UNIX file permissions when you ``become`` root or do not use ``become``.  In Ansible 2.1 and above, UNIX file permissions are also secure if you make the connection to the managed machine as root and then use ``become`` to access an unprivileged account."
msgstr ""

#: ../../rst/user_guide/become.rst:198
msgid "Although the Solaris ZFS filesystem has filesystem ACLs, the ACLs are not POSIX.1e filesystem acls (they are NFSv4 ACLs instead).  Ansible cannot use these ACLs to manage its temp file permissions so you may have to resort to ``allow_world_readable_tmpfiles`` if the remote machines use ZFS."
msgstr ""

#: ../../rst/user_guide/become.rst:205
msgid "Ansible makes it hard to unknowingly use ``become`` insecurely. Starting in Ansible 2.1, Ansible defaults to issuing an error if it cannot execute securely with ``become``. If you cannot use pipelining or POSIX ACLs, must connect as an unprivileged user, must use ``become`` to execute as a different unprivileged user, and decide that your managed nodes are secure enough for the modules you want to run there to be world readable, you can turn on ``allow_world_readable_tmpfiles`` in the :file:`ansible.cfg` file.  Setting ``allow_world_readable_tmpfiles`` will change this from an error into a warning and allow the task to run as it did prior to 2.1."
msgstr ""

#: ../../rst/user_guide/become.rst:217
msgid "Ansible 2.10 introduces the above-mentioned ``ansible_common_remote_group`` fallback. As mentioned above, if enabled, it is used when ``remote_user`` and ``become_user`` are both unprivileged users. Refer to the text above for details on when this fallback happens."
msgstr ""

#: ../../rst/user_guide/become.rst:222
msgid "As mentioned above, if ``ansible_common_remote_group`` and ``allow_world_readable_tmpfiles`` are both enabled, it is unlikely that the world-readable fallback will ever trigger, and yet Ansible might still be unable to access the module file. This is because after the group ownership change is successful, Ansible does not fall back any further, and also does not do any check to ensure that the ``become_user`` is actually a member of the \"common group\". This is a design decision made by the fact that doing such a check would require another round-trip connection to the remote machine, which is a time-expensive operation. Ansible does, however, emit a warning in this case."
msgstr ""

#: ../../rst/user_guide/become.rst:234
msgid "Not supported by all connection plugins"
msgstr ""

#: ../../rst/user_guide/become.rst:236
msgid "Privilege escalation methods must also be supported by the connection plugin used. Most connection plugins will warn if they do not support become. Some will just ignore it as they always run as root (jail, chroot, and so on)."
msgstr ""

#: ../../rst/user_guide/become.rst:241
msgid "Only one method may be enabled per host"
msgstr ""

#: ../../rst/user_guide/become.rst:243
msgid "Methods cannot be chained. You cannot use ``sudo /bin/su -`` to become a user, you need to have privileges to run the command as that user in sudo or be able to su directly to it (the same for pbrun, pfexec or other supported methods)."
msgstr ""

#: ../../rst/user_guide/become.rst:248
msgid "Privilege escalation must be general"
msgstr ""

#: ../../rst/user_guide/become.rst:250
msgid "You cannot limit privilege escalation permissions to certain commands. Ansible does not always use a specific command to do something but runs modules (code) from a temporary file name which changes every time.  If you have '/sbin/service' or '/bin/chmod' as the allowed commands this will fail with ansible as those paths won't match with the temporary file that Ansible creates to run the module. If you have security rules that constrain your sudo/pbrun/doas environment to running specific command paths only, use Ansible from a special account that does not have this constraint, or use :ref:`ansible_tower` to manage indirect access to SSH credentials."
msgstr ""

#: ../../rst/user_guide/become.rst:261
msgid "May not access environment variables populated by pamd_systemd"
msgstr ""

#: ../../rst/user_guide/become.rst:263
msgid "For most Linux distributions using ``systemd`` as their init, the default methods used by ``become`` do not open a new \"session\", in the sense of systemd. Because the ``pam_systemd`` module will not fully initialize a new session, you might have surprises compared to a normal session opened through ssh: some environment variables set by ``pam_systemd``, most notably ``XDG_RUNTIME_DIR``, are not populated for the new user and instead inherited or just emptied."
msgstr ""

#: ../../rst/user_guide/become.rst:271
msgid "This might cause trouble when trying to invoke systemd commands that depend on ``XDG_RUNTIME_DIR`` to access the bus:"
msgstr ""

#: ../../rst/user_guide/become.rst:281
msgid "To force ``become`` to open a new systemd session that goes through ``pam_systemd``, you can use ``become_method: machinectl``."
msgstr ""

#: ../../rst/user_guide/become.rst:284
msgid "For more information, see `this systemd issue <https://github.com/systemd/systemd/issues/825#issuecomment-127917622>`_."
msgstr ""

#: ../../rst/user_guide/become.rst:290
msgid "Become and network automation"
msgstr ""

#: ../../rst/user_guide/become.rst:292
msgid "As of version 2.6, Ansible supports ``become`` for privilege escalation (entering ``enable`` mode or privileged EXEC mode) on all Ansible-maintained network platforms that support ``enable`` mode. Using ``become`` replaces the ``authorize`` and ``auth_pass`` options in a ``provider`` dictionary."
msgstr ""

#: ../../rst/user_guide/become.rst:294
msgid "You must set the connection type to either ``connection: ansible.netcommon.network_cli`` or ``connection: ansible.netcommon.httpapi`` to use ``become`` for privilege escalation on network devices. Check the :ref:`platform_options` documentation for details."
msgstr ""

#: ../../rst/user_guide/become.rst:296
msgid "You can use escalated privileges on only the specific tasks that need them, on an entire play, or on all plays. Adding ``become: yes`` and ``become_method: enable`` instructs Ansible to enter ``enable`` mode before executing the task, play, or playbook where those parameters are set."
msgstr ""

#: ../../rst/user_guide/become.rst:298
msgid "If you see this error message, the task that generated it requires ``enable`` mode to succeed:"
msgstr ""

#: ../../rst/user_guide/become.rst:304
msgid "To set ``enable`` mode for a specific task, add ``become`` at the task level:"
msgstr ""

#: ../../rst/user_guide/become.rst:315
msgid "To set enable mode for all tasks in a single play, add ``become`` at the play level:"
msgstr ""

#: ../../rst/user_guide/become.rst:329
msgid "Setting enable mode for all tasks"
msgstr ""

#: ../../rst/user_guide/become.rst:331
msgid "Often you wish for all tasks in all plays to run using privilege mode, that is best achieved by using ``group_vars``:"
msgstr ""

#: ../../rst/user_guide/become.rst:333
msgid "**group_vars/eos.yml**"
msgstr ""

#: ../../rst/user_guide/become.rst:344
msgid "Passwords for enable mode"
msgstr ""

#: ../../rst/user_guide/become.rst:346
msgid "If you need a password to enter ``enable`` mode, you can specify it in one of two ways:"
msgstr ""

#: ../../rst/user_guide/become.rst:348
msgid "providing the :option:`--ask-become-pass <ansible-playbook --ask-become-pass>` command line option"
msgstr ""

#: ../../rst/user_guide/become.rst:349
msgid "setting the ``ansible_become_password`` connection variable"
msgstr ""

#: ../../rst/user_guide/become.rst:353
msgid "As a reminder passwords should never be stored in plain text. For information on encrypting your passwords and other secrets with Ansible Vault, see :ref:`vault`."
msgstr ""

#: ../../rst/user_guide/become.rst:356
msgid "authorize and auth_pass"
msgstr ""

#: ../../rst/user_guide/become.rst:358
msgid "Ansible still supports ``enable`` mode with ``connection: local`` for legacy network playbooks. To enter ``enable`` mode with ``connection: local``, use the module options ``authorize`` and ``auth_pass``:"
msgstr ""

#: ../../rst/user_guide/become.rst:373
msgid "We recommend updating your playbooks to use ``become`` for network-device ``enable`` mode consistently. The use of ``authorize`` and of ``provider`` dictionaries will be deprecated in future. Check the :ref:`platform_options` and :ref:`network_modules` documentation for details."
msgstr ""

#: ../../rst/user_guide/become.rst:378
msgid "Become and Windows"
msgstr ""

#: ../../rst/user_guide/become.rst:380
msgid "Since Ansible 2.3, ``become`` can be used on Windows hosts through the ``runas`` method. Become on Windows uses the same inventory setup and invocation arguments as ``become`` on a non-Windows host, so the setup and variable names are the same as what is defined in this document."
msgstr ""

#: ../../rst/user_guide/become.rst:385
msgid "While ``become`` can be used to assume the identity of another user, there are other uses for it with Windows hosts. One important use is to bypass some of the limitations that are imposed when running on WinRM, such as constrained network delegation or accessing forbidden system calls like the WUA API. You can use ``become`` with the same user as ``ansible_user`` to bypass these limitations and run commands that are not normally accessible in a WinRM session."
msgstr ""

#: ../../rst/user_guide/become.rst:393
msgid "Administrative rights"
msgstr ""

#: ../../rst/user_guide/become.rst:395
msgid "Many tasks in Windows require administrative privileges to complete. When using the ``runas`` become method, Ansible will attempt to run the module with the full privileges that are available to the remote user. If it fails to elevate the user token, it will continue to use the limited token during execution."
msgstr ""

#: ../../rst/user_guide/become.rst:400
msgid "A user must have the ``SeDebugPrivilege`` to run a become process with elevated privileges. This privilege is assigned to Administrators by default. If the debug privilege is not available, the become process will run with a limited set of privileges and groups."
msgstr ""

#: ../../rst/user_guide/become.rst:405
msgid "To determine the type of token that Ansible was able to get, run the following task:"
msgstr ""

#: ../../rst/user_guide/become.rst:414
msgid "The output will look something similar to the below:"
msgstr ""

#: ../../rst/user_guide/become.rst:502
msgid "Under the ``label`` key, the ``account_name`` entry determines whether the user has Administrative rights. Here are the labels that can be returned and what they represent:"
msgstr ""

#: ../../rst/user_guide/become.rst:506
msgid "``Medium``: Ansible failed to get an elevated token and ran under a limited token. Only a subset of the privileges assigned to user are available during the module execution and the user does not have administrative rights."
msgstr ""

#: ../../rst/user_guide/become.rst:510
msgid "``High``: An elevated token was used and all the privileges assigned to the user are available during the module execution."
msgstr ""

#: ../../rst/user_guide/become.rst:513
msgid "``System``: The ``NT AUTHORITY\\System`` account is used and has the highest level of privileges available."
msgstr ""

#: ../../rst/user_guide/become.rst:516
msgid "The output will also show the list of privileges that have been granted to the user. When the privilege value is ``disabled``, the privilege is assigned to the logon token but has not been enabled. In most scenarios these privileges are automatically enabled when required."
msgstr ""

#: ../../rst/user_guide/become.rst:521
msgid "If running on a version of Ansible that is older than 2.5 or the normal ``runas`` escalation process fails, an elevated token can be retrieved by:"
msgstr ""

#: ../../rst/user_guide/become.rst:524
msgid "Set the ``become_user`` to ``System`` which has full control over the operating system."
msgstr ""

#: ../../rst/user_guide/become.rst:527
msgid "Grant ``SeTcbPrivilege`` to the user Ansible connects with on WinRM. ``SeTcbPrivilege`` is a high-level privilege that grants full control over the operating system. No user is given this privilege by default, and care should be taken if you grant this privilege to a user or group. For more information on this privilege, please see `Act as part of the operating system <https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn221957(v=ws.11)>`_. You can use the below task to set this privilege on a Windows host:"
msgstr ""

#: ../../rst/user_guide/become.rst:543
msgid "Turn UAC off on the host and reboot before trying to become the user. UAC is a security protocol that is designed to run accounts with the ``least privilege`` principle. You can turn UAC off by running the following tasks:"
msgstr ""

#: ../../rst/user_guide/become.rst:563
msgid "Granting the ``SeTcbPrivilege`` or turning UAC off can cause Windows security vulnerabilities and care should be given if these steps are taken."
msgstr ""

#: ../../rst/user_guide/become.rst:567
msgid "Local service accounts"
msgstr ""

#: ../../rst/user_guide/become.rst:569
msgid "Prior to Ansible version 2.5, ``become`` only worked on Windows with a local or domain user account. Local service accounts like ``System`` or ``NetworkService`` could not be used as ``become_user`` in these older versions. This restriction has been lifted since the 2.5 release of Ansible. The three service accounts that can be set under ``become_user`` are:"
msgstr ""

#: ../../rst/user_guide/become.rst:575
msgid "System"
msgstr ""

#: ../../rst/user_guide/become.rst:576
msgid "NetworkService"
msgstr ""

#: ../../rst/user_guide/become.rst:577
msgid "LocalService"
msgstr ""

#: ../../rst/user_guide/become.rst:579
msgid "Because local service accounts do not have passwords, the ``ansible_become_password`` parameter is not required and is ignored if specified."
msgstr ""

#: ../../rst/user_guide/become.rst:584
msgid "Become without setting a password"
msgstr ""

#: ../../rst/user_guide/become.rst:586
msgid "As of Ansible 2.8, ``become`` can be used to become a Windows local or domain account without requiring a password for that account. For this method to work, the following requirements must be met:"
msgstr ""

#: ../../rst/user_guide/become.rst:590
msgid "The connection user has the ``SeDebugPrivilege`` privilege assigned"
msgstr ""

#: ../../rst/user_guide/become.rst:591
msgid "The connection user is part of the ``BUILTIN\\Administrators`` group"
msgstr ""

#: ../../rst/user_guide/become.rst:592
msgid "The ``become_user`` has either the ``SeBatchLogonRight`` or ``SeNetworkLogonRight`` user right"
msgstr ""

#: ../../rst/user_guide/become.rst:594
msgid "Using become without a password is achieved in one of two different methods:"
msgstr ""

#: ../../rst/user_guide/become.rst:596
msgid "Duplicating an existing logon session's token if the account is already logged on"
msgstr ""

#: ../../rst/user_guide/become.rst:597
msgid "Using S4U to generate a logon token that is valid on the remote host only"
msgstr ""

#: ../../rst/user_guide/become.rst:599
msgid "In the first scenario, the become process is spawned from another logon of that user account. This could be an existing RDP logon, console logon, but this is not guaranteed to occur all the time. This is similar to the ``Run only when user is logged on`` option for a Scheduled Task."
msgstr ""

#: ../../rst/user_guide/become.rst:604
msgid "In the case where another logon of the become account does not exist, S4U is used to create a new logon and run the module through that. This is similar to the ``Run whether user is logged on or not`` with the ``Do not store password`` option for a Scheduled Task. In this scenario, the become process will not be able to access any network resources like a normal WinRM process."
msgstr ""

#: ../../rst/user_guide/become.rst:610
msgid "To make a distinction between using become with no password and becoming an account that has no password make sure to keep ``ansible_become_password`` as undefined or set ``ansible_become_password:``."
msgstr ""

#: ../../rst/user_guide/become.rst:614
msgid "Because there are no guarantees an existing token will exist for a user when Ansible runs, there's a high change the become process will only have access to local resources. Use become with a password if the task needs to access network resources"
msgstr ""

#: ../../rst/user_guide/become.rst:620
msgid "Accounts without a password"
msgstr ""

#: ../../rst/user_guide/become.rst:622
msgid "As a general security best practice, you should avoid allowing accounts without passwords."
msgstr ""

#: ../../rst/user_guide/become.rst:624
msgid "Ansible can be used to become a Windows account that does not have a password (like the ``Guest`` account). To become an account without a password, set up the variables like normal but set ``ansible_become_password: ''``."
msgstr ""

#: ../../rst/user_guide/become.rst:628
msgid "Before become can work on an account like this, the local policy `Accounts: Limit local account use of blank passwords to console logon only <https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj852174(v=ws.11)>`_ must be disabled. This can either be done through a Group Policy Object (GPO) or with this Ansible task:"
msgstr ""

#: ../../rst/user_guide/become.rst:643
msgid "This is only for accounts that do not have a password. You still need to set the account's password under ``ansible_become_password`` if the become_user has a password."
msgstr ""

#: ../../rst/user_guide/become.rst:648
msgid "Become flags for Windows"
msgstr ""

#: ../../rst/user_guide/become.rst:650
msgid "Ansible 2.5 added the ``become_flags`` parameter to the ``runas`` become method. This parameter can be set using the ``become_flags`` task directive or set in Ansible's configuration using ``ansible_become_flags``. The two valid values that are initially supported for this parameter are ``logon_type`` and ``logon_flags``."
msgstr ""

#: ../../rst/user_guide/become.rst:656
msgid "These flags should only be set when becoming a normal user account, not a local service account like LocalSystem."
msgstr ""

#: ../../rst/user_guide/become.rst:658
msgid "The key ``logon_type`` sets the type of logon operation to perform. The value can be set to one of the following:"
msgstr ""

#: ../../rst/user_guide/become.rst:661
msgid "``interactive``: The default logon type. The process will be run under a context that is the same as when running a process locally. This bypasses all WinRM restrictions and is the recommended method to use."
msgstr ""

#: ../../rst/user_guide/become.rst:665
msgid "``batch``: Runs the process under a batch context that is similar to a scheduled task with a password set. This should bypass most WinRM restrictions and is useful if the ``become_user`` is not allowed to log on interactively."
msgstr ""

#: ../../rst/user_guide/become.rst:670
msgid "``new_credentials``: Runs under the same credentials as the calling user, but outbound connections are run under the context of the ``become_user`` and ``become_password``, similar to ``runas.exe /netonly``. The ``logon_flags`` flag should also be set to ``netcredentials_only``. Use this flag if the process needs to access a network resource (like an SMB share) using a different set of credentials."
msgstr ""

#: ../../rst/user_guide/become.rst:677
msgid "``network``: Runs the process under a network context without any cached credentials. This results in the same type of logon session as running a normal WinRM process without credential delegation, and operates under the same restrictions."
msgstr ""

#: ../../rst/user_guide/become.rst:682
msgid "``network_cleartext``: Like the ``network`` logon type, but instead caches the credentials so it can access network resources. This is the same type of logon session as running a normal WinRM process with credential delegation."
msgstr ""

#: ../../rst/user_guide/become.rst:686
msgid "For more information, see `dwLogonType <https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-logonusera>`_."
msgstr ""

#: ../../rst/user_guide/become.rst:689
msgid "The ``logon_flags`` key specifies how Windows will log the user on when creating the new process. The value can be set to none or multiple of the following:"
msgstr ""

#: ../../rst/user_guide/become.rst:692
msgid "``with_profile``: The default logon flag set. The process will load the user's profile in the ``HKEY_USERS`` registry key to ``HKEY_CURRENT_USER``."
msgstr ""

#: ../../rst/user_guide/become.rst:695
msgid "``netcredentials_only``: The process will use the same token as the caller but will use the ``become_user`` and ``become_password`` when accessing a remote resource. This is useful in inter-domain scenarios where there is no trust relationship, and should be used with the ``new_credentials`` ``logon_type``."
msgstr ""

#: ../../rst/user_guide/become.rst:700
msgid "By default ``logon_flags=with_profile`` is set, if the profile should not be loaded set ``logon_flags=`` or if the profile should be loaded with ``netcredentials_only``, set ``logon_flags=with_profile,netcredentials_only``."
msgstr ""

#: ../../rst/user_guide/become.rst:704
msgid "For more information, see `dwLogonFlags <https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-createprocesswithtokenw>`_."
msgstr ""

#: ../../rst/user_guide/become.rst:706
msgid "Here are some examples of how to use ``become_flags`` with Windows tasks:"
msgstr ""

#: ../../rst/user_guide/become.rst:734
msgid "Limitations of become on Windows"
msgstr ""

#: ../../rst/user_guide/become.rst:736
msgid "Running a task with ``async`` and ``become`` on Windows Server 2008, 2008 R2 and Windows 7 only works when using Ansible 2.7 or newer."
msgstr ""

#: ../../rst/user_guide/become.rst:739
msgid "By default, the become user logs on with an interactive session, so it must have the right to do so on the Windows host. If it does not inherit the ``SeAllowLogOnLocally`` privilege or inherits the ``SeDenyLogOnLocally`` privilege, the become process will fail. Either add the privilege or set the ``logon_type`` flag to change the logon type used."
msgstr ""

#: ../../rst/user_guide/become.rst:745
msgid "Prior to Ansible version 2.3, become only worked when ``ansible_winrm_transport`` was either ``basic`` or ``credssp``. This restriction has been lifted since the 2.4 release of Ansible for all hosts except Windows Server 2008 (non R2 version)."
msgstr ""

#: ../../rst/user_guide/become.rst:750
msgid "The Secondary Logon service ``seclogon`` must be running to use ``ansible_become_method: runas``"
msgstr ""

#: ../../rst/user_guide/become.rst:754
msgid "`Mailing List <https://groups.google.com/forum/#!forum/ansible-project>`_"
msgstr ""

#: ../../rst/user_guide/become.rst:755 ../../rst/user_guide/intro_adhoc.rst:204
#: ../../rst/user_guide/intro_bsd.rst:104
#: ../../rst/user_guide/intro_dynamic_inventory.rst:247
#: ../../rst/user_guide/intro_getting_started.rst:144
#: ../../rst/user_guide/intro_inventory.rst:789
#: ../../rst/user_guide/intro_patterns.rst:169
#: ../../rst/user_guide/modules.rst:34
#: ../../rst/user_guide/modules_intro.rst:50
#: ../../rst/user_guide/modules_support.rst:68
#: ../../rst/user_guide/playbooks_best_practices.rst:167
#: ../../rst/user_guide/playbooks_intro.rst:155
#: ../../rst/user_guide/playbooks_reuse.rst:201
#: ../../rst/user_guide/playbooks_reuse_includes.rst:32
#: ../../rst/user_guide/playbooks_reuse_roles.rst:490
#: ../../rst/user_guide/sample_setup.rst:285
msgid "Questions? Help? Ideas?  Stop by the list on Google Groups"
msgstr ""

#: ../../rst/user_guide/become.rst:756
msgid "`webchat.freenode.net <https://webchat.freenode.net>`_"
msgstr ""

#: ../../rst/user_guide/become.rst:757
#: ../../rst/user_guide/collections_using.rst:324
#: ../../rst/user_guide/intro_adhoc.rst:206
#: ../../rst/user_guide/intro_bsd.rst:106
#: ../../rst/user_guide/intro_dynamic_inventory.rst:249
#: ../../rst/user_guide/intro_getting_started.rst:146
#: ../../rst/user_guide/intro_inventory.rst:791
#: ../../rst/user_guide/intro_patterns.rst:171
#: ../../rst/user_guide/modules.rst:36
#: ../../rst/user_guide/modules_intro.rst:52
#: ../../rst/user_guide/modules_support.rst:70
#: ../../rst/user_guide/playbooks_advanced_syntax.rst:112
#: ../../rst/user_guide/playbooks_async.rst:161
#: ../../rst/user_guide/playbooks_blocks.rst:189
#: ../../rst/user_guide/playbooks_conditionals.rst:508
#: ../../rst/user_guide/playbooks_debugger.rst:329
#: ../../rst/user_guide/playbooks_delegation.rst:136
#: ../../rst/user_guide/playbooks_environment.rst:141
#: ../../rst/user_guide/playbooks_error_handling.rst:245
#: ../../rst/user_guide/playbooks_filters.rst:1734
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:743
#: ../../rst/user_guide/playbooks_lookups.rst:37
#: ../../rst/user_guide/playbooks_loops.rst:445
#: ../../rst/user_guide/playbooks_prompts.rst:116
#: ../../rst/user_guide/playbooks_strategies.rst:222
#: ../../rst/user_guide/playbooks_tags.rst:429
#: ../../rst/user_guide/playbooks_templating.rst:55
#: ../../rst/user_guide/playbooks_tests.rst:403
#: ../../rst/user_guide/playbooks_variables.rst:466
#: ../../rst/user_guide/windows_dsc.rst:505
#: ../../rst/user_guide/windows_faq.rst:236
#: ../../rst/user_guide/windows_setup.rst:573
#: ../../rst/user_guide/windows_usage.rst:513
#: ../../rst/user_guide/windows_winrm.rst:913
msgid "#ansible IRC chat channel"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:6
msgid "Using collections"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:8
msgid "Collections are a distribution format for Ansible content that can include playbooks, roles, modules, and plugins. As modules move from the core Ansible repository into collections, the module documentation will move to the :ref:`collections pages <list_of_collections>`."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:10
msgid "You can install and use collections through `Ansible Galaxy <https://galaxy.ansible.com>`_."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:12
msgid "For details on how to *develop* collections see :ref:`developing_collections`."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:13
msgid "For the current development status of Collections and FAQ see `Ansible Collections Community Guide <https://github.com/ansible-collections/overview/blob/main/README.rst>`_."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:22
msgid "Installing collections"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:26
msgid "Installing collections with ``ansible-galaxy``"
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:3
msgid "By default, ``ansible-galaxy collection install`` uses https://galaxy.ansible.com as the Galaxy server (as listed in the :file:`ansible.cfg` file under :ref:`galaxy_server`). You do not need any further configuration."
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:7
msgid "See :ref:`Configuring the ansible-galaxy client <galaxy_server_config>` if you are using any other Galaxy server, such as Red Hat Automation Hub."
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:9
msgid "To install a collection hosted in Galaxy:"
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:15
msgid "You can also directly use the tarball from your build:"
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:22
msgid "The install command automatically appends the path ``ansible_collections`` to the one specified  with the ``-p`` option unless the parent directory is already in a folder called ``ansible_collections``."
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:26
msgid "When using the ``-p`` option to specify the install path, use one of the values configured in :ref:`COLLECTIONS_PATHS`, as this is where Ansible itself will expect to find collections. If you don't specify a path, ``ansible-galaxy collection install`` installs the collection to the first path defined in :ref:`COLLECTIONS_PATHS`, which by default is ``~/.ansible/collections``"
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:30
msgid "You can also keep a collection adjacent to the current playbook, under a ``collections/ansible_collections/`` directory structure."
msgstr ""

#: ../../rst/shared_snippets/installing_collections.txt:42
msgid "See :ref:`collection_structure` for details on the collection directory structure."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:33
msgid "Installing an older version of a collection"
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:2
msgid "You can only have one version of a collection installed at a time. By default ``ansible-galaxy`` installs the latest available version. If you want to install a specific version, you can add a version range identifier. For example, to install the 1.0.0-beta.1 version of the collection:"
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:8
msgid "You can specify multiple range identifiers separated by ``,``. Use single quotes so the shell passes the entire command, including ``>``, ``!``, and other operators, along. For example, to install the most recent version that is greater than or equal to 1.0.0 and less than 2.0.0:"
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:14
msgid "Ansible will always install the most recent version that meets the range identifiers you specify. You can use the following range identifiers:"
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:16
msgid "``*``: The most recent version. This is the default."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:17
msgid "``!=``: Not equal to the version specified."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:18
msgid "``==``: Exactly the version specified."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:19
msgid "``>=``: Greater than or equal to the version specified."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:20
msgid "``>``: Greater than the version specified."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:21
msgid "``<=``: Less than or equal to the version specified."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:22
msgid "``<``: Less than the version specified."
msgstr ""

#: ../../rst/shared_snippets/installing_older_collection.txt:25
msgid "By default ``ansible-galaxy`` ignores pre-release versions. To install a pre-release version, you must use the ``==`` range identifier to require it explicitly."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:38
msgid "Installing a collection from a git repository"
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:1
msgid "You can install a collection in a git repository by providing the URI to the repository instead of a collection name or path to a ``tar.gz`` file. The collection must contain a ``galaxy.yml`` file, which will be used to generate the would-be collection artifact data from the directory. The URI should be prefixed with ``git+`` (or with ``git@`` to use a private repository with ssh authentication) and optionally supports a comma-separated `git commit-ish <https://git-scm.com/docs/gitglossary#def_commit-ish>`_ version (for example, a commit or tag)."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:5
msgid "Embedding credentials into a git URI is not secure. Make sure to use safe auth options for security reasons. For example, use `SSH <https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh>`_, `netrc <https://linux.die.net/man/5/netrc>`_ or `http.extraHeader <https://git-scm.com/docs/git-config#Documentation/git-config.txt-httpextraHeader>`_/`url.<base>.pushInsteadOf <https://git-scm.com/docs/git-config#Documentation/git-config.txt-urlltbasegtpushInsteadOf>`_ in Git config to prevent your creds from being exposed in logs."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:18
msgid "In a ``requirements.yml`` file, you can also use the ``type`` and ``version`` keys in addition to using the ``git+repo,version`` syntax for the collection name."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:27
msgid "Git repositories can be used for collection dependencies as well. This can be helpful for local development and testing but built/published artifacts should only have dependencies on other artifacts."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:34
msgid "Default repository search locations"
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:36
msgid "There are two paths searched in a repository for collections by default."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:38
msgid "The first is the ``galaxy.yml`` file in the top level of the repository path. If the ``galaxy.yml`` file exists it's used as the collection metadata and the individual collection will be installed."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:49
msgid "The second is a ``galaxy.yml`` file in each directory in the repository path (one level deep). In this scenario, each directory with a ``galaxy.yml`` is installed as a collection."
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:62
msgid "Specifying the location to search for collections"
msgstr ""

#: ../../rst/shared_snippets/installing_collections_git_repo.txt:64
msgid "If you have a different repository structure or only want to install a subset of collections, you can add a fragment to the end of your URI (before the optional comma-separated version) to indicate which path ansible-galaxy should inspect for ``galaxy.yml`` file(s). The path should be a directory to a collection or multiple collections (rather than the path to a ``galaxy.yml`` file)."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:45
msgid "Install multiple collections with a requirements file"
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:2
msgid "You can also setup a ``requirements.yml`` file to install multiple collections in one command. This file is a YAML file in the format:"
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:16
msgid "The supported keys for collection requirement entries are ``name``, ``version``, ``source``, and ``type``."
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:18
msgid "The ``version`` key can take in the same range identifier format documented above. If you're installing a collection from a git repository instead of a built collection artifact, the ``version`` key refers to a `git commit-ish <https://git-scm.com/docs/gitglossary#def_commit-ish>`_."
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:20
msgid "The ``type`` key can be set to ``galaxy``, ``url``, ``file``, and ``git``. If ``type`` is omitted, the ``name`` key is used to implicitly determine the source of the collection."
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:22
msgid "Roles can also be specified and placed under the ``roles`` key. The values follow the same format as a requirements file used in older Ansible releases."
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:39
msgid "To install both roles and collections at the same time with one command, run the following:"
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:45
msgid "Running ``ansible-galaxy collection install -r`` or ``ansible-galaxy role install -r`` will only install collections, or roles respectively."
msgstr ""

#: ../../rst/shared_snippets/installing_multiple_collections.txt:49
msgid "Installing both roles and collections from the same requirements file will not work when specifying a custom collection or role install path. In this scenario the collections will be skipped and the command will process each like ``ansible-galaxy role install`` would."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:52
msgid "Downloading a collection for offline use"
msgstr ""

#: ../../rst/shared_snippets/download_tarball_collections.txt:3
msgid "To download the collection tarball from Galaxy for offline use:"
msgstr ""

#: ../../rst/shared_snippets/download_tarball_collections.txt:5
msgid "Navigate to the collection page."
msgstr ""

#: ../../rst/shared_snippets/download_tarball_collections.txt:6
msgid "Click on :guilabel:`Download tarball`."
msgstr ""

#: ../../rst/shared_snippets/download_tarball_collections.txt:8
msgid "You may also need to manually download any dependent collections."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:60
msgid "Configuring the ``ansible-galaxy`` client"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:3
msgid "By default, ``ansible-galaxy`` uses https://galaxy.ansible.com as the Galaxy server (as listed in the :file:`ansible.cfg` file under :ref:`galaxy_server`)."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:5
msgid "You can use either option below to configure ``ansible-galaxy collection`` to use other servers (such as Red Hat Automation Hub or a custom Galaxy server):"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:7
msgid "Set the server list in the :ref:`galaxy_server_list` configuration option in :ref:`ansible_configuration_settings_locations`."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:8
msgid "Use the ``--server`` command line argument to limit to an individual server."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:10
msgid "To configure a Galaxy server list in ``ansible.cfg``:"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:13
msgid "Add the ``server_list``  option under the ``[galaxy]`` section to one or more server names."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:14
msgid "Create a new section for each server name."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:15
msgid "Set the ``url`` option for each server name."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:16
msgid "Optionally, set the API token for each server name. Go to https://galaxy.ansible.com/me/preferences and click :guilabel:`Show API key`."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:19
msgid "The ``url`` option for each server name must end with a forward slash ``/``. If you do not set the API token in your Galaxy server list, use the ``--api-key`` argument to pass in the token to  the ``ansible-galaxy collection publish`` command."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:21
msgid "For Automation Hub, you additionally need to:"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:23
msgid "Set the ``auth_url`` option for each server name."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:24
msgid "Set the API token for each server name. Go to https://cloud.redhat.com/ansible/automation-hub/token/ and click ::guilabel:`Get API token` from the version dropdown to copy your API token."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:26
msgid "The following example shows how to configure multiple servers:"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:52
msgid "You can use the ``--server`` command line argument to select an explicit Galaxy server in the ``server_list`` and the value of this argument should match the name of the server. To use a server not in the server list, set the value to the URL to access that server (all servers in the server list will be ignored). Also you cannot use the ``--api-key`` argument for any of the predefined servers. You can only use the ``api_key`` argument if you did not define a server list or if you specify a URL in the ``--server`` argument."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:56
msgid "**Galaxy server list configuration options**"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:58
msgid "The :ref:`galaxy_server_list` option is a list of server identifiers in a prioritized order. When searching for a collection, the install process will search in that order, for example, ``automation_hub`` first, then ``my_org_hub``, ``release_galaxy``, and finally ``test_galaxy`` until the collection is found. The actual Galaxy instance is then defined under the section ``[galaxy_server.{{ id }}]`` where ``{{ id }}`` is the server identifier defined in the list. This section can then define the following keys:"
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:64
msgid "``url``: The URL of the Galaxy instance to connect to. Required."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:65
msgid "``token``: An API token key to use for authentication against the Galaxy instance. Mutually exclusive with ``username``."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:66
msgid "``username``: The username to use for basic authentication against the Galaxy instance. Mutually exclusive with ``token``."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:67
msgid "``password``: The password to use, in conjunction with ``username``, for basic authentication."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:68
msgid "``auth_url``: The URL of a Keycloak server 'token_endpoint' if using SSO authentication (for example, Automation Hub). Mutually exclusive with ``username``. Requires ``token``."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:70
msgid "As well as defining these server options in the ``ansible.cfg`` file, you can also define them as environment variables. The environment variable is in the form ``ANSIBLE_GALAXY_SERVER_{{ id }}_{{ key }}`` where ``{{ id }}`` is the upper case form of the server identifier and ``{{ key }}`` is the key to define. For example I can define ``token`` for ``release_galaxy`` by setting ``ANSIBLE_GALAXY_SERVER_RELEASE_GALAXY_TOKEN=secret_token``."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:75
msgid "For operations that use only one Galaxy server (for example, the ``publish``, ``info``, or ``install`` commands). the ``ansible-galaxy collection`` command uses the first entry in the ``server_list``, unless you pass in an explicit server with the ``--server`` argument."
msgstr ""

#: ../../rst/shared_snippets/galaxy_server_list.txt:79
msgid "Once a collection is found, any of its requirements are only searched within the same Galaxy instance as the parent collection. The install process will not search for a collection requirement in a different Galaxy instance."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:67
msgid "Downloading collections"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:69
msgid "To download a collection and its dependencies for an offline install, run ``ansible-galaxy collection download``. This downloads the collections specified and their dependencies to the specified folder and creates a ``requirements.yml`` file which can be used to install those collections on a host without access to a Galaxy server. All the collections are downloaded by default to the ``./collections`` folder."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:74
msgid "Just like the ``install`` command, the collections are sourced based on the :ref:`configured galaxy server config <galaxy_server_config>`. Even if a collection to download was specified by a URL or path to a tarball, the collection will be redownloaded from the configured Galaxy server."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:78
msgid "Collections can be specified as one or multiple collections or with a ``requirements.yml`` file just like ``ansible-galaxy collection install``."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:81
msgid "To download a single collection and its dependencies:"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:87
msgid "To download a single collection at a specific version:"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:93
msgid "To download multiple collections either specify multiple collections as command line arguments as shown above or use a requirements file in the format documented with :ref:`collection_requirements_file`."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:100
msgid "All the collections are downloaded by default to the ``./collections`` folder but you can use ``-p`` or ``--download-path`` to specify another path:"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:107
msgid "Once you have downloaded the collections, the folder contains the collections specified, their dependencies, and a ``requirements.yml`` file. You can use this folder as is with ``ansible-galaxy collection install`` to install the collections on a host without access to a Galaxy or Automation Hub server."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:121
msgid "Listing collections"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:123
msgid "To list installed collections, run ``ansible-galaxy collection list``. This shows all of the installed collections found in the configured collections search paths. It will also show collections under development which contain a galaxy.yml file instead of a MANIFEST.json. The path where the collections are located are displayed as well as version information. If no version information is available, a ``*`` is displayed for the version number."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:142
msgid "Run with ``-vvv`` to display more detailed information."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:144
msgid "To list a specific collection, pass a valid fully qualified collection name (FQCN) to the command ``ansible-galaxy collection list``. All instances of the collection will be listed."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:160
msgid "To search other paths for collections, use the ``-p`` option. Specify multiple search paths by separating them with a ``:``. The list of paths specified on the command line will be added to the beginning of the configured collections search paths."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:196
msgid "Verifying collections"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:199
msgid "Verifying collections with ``ansible-galaxy``"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:201
msgid "Once installed, you can verify that the content of the installed collection matches the content of the collection on the server. This feature expects that the collection is installed in one of the configured collection paths and that the collection exists on one of the configured galaxy servers."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:207
msgid "The output of the ``ansible-galaxy collection verify`` command is quiet if it is successful. If a collection has been modified, the altered files are listed under the collection name."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:217
msgid "You can use the ``-vvv`` flag to display additional information, such as the version and path of the installed collection, the URL of the remote collection used for validation, and successful verification output."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:228
msgid "If you have a pre-release or non-latest version of a collection installed you should include the specific version to verify. If the version is omitted, the installed collection is verified against the latest version available on the server."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:234
msgid "In addition to the ``namespace.collection_name:version`` format, you can provide the collections to verify in a ``requirements.yml`` file. Dependencies listed in ``requirements.yml`` are not included in the verify process and should be verified separately."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:240
msgid "Verifying against ``tar.gz`` files is not supported. If your ``requirements.yml`` contains paths to tar files or URLs for installation, you can use the ``--ignore-errors`` flag to ensure that all collections using the ``namespace.name`` format in the file are processed."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:245
msgid "Using collections in a Playbook"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:247
msgid "Once installed, you can reference a collection content by its fully qualified collection name (FQCN):"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:256
msgid "This works for roles or any type of plugin distributed within the collection:"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:272
msgid "Simplifying module names with the ``collections`` keyword"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:274
msgid "The ``collections`` keyword lets you define a list of collections that your role or playbook should search for unqualified module and action names. So you can use the ``collections`` keyword, then simply refer to modules and action plugins by their short-form names throughout that role or playbook."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:277
msgid "If your playbook uses both the ``collections`` keyword and one or more roles, the roles do not inherit the collections set by the playbook. This is one of the reasons we recommend you always use FQCN. See below for roles details."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:280
msgid "Using ``collections`` in roles"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:282
msgid "Within a role, you can control which collections Ansible searches for the tasks inside the role using the ``collections`` keyword in the role's ``meta/main.yml``. Ansible will use the collections list defined inside the role even if the playbook that calls the role defines different collections in a separate ``collections`` keyword entry. Roles defined inside a collection always implicitly search their own collection first, so you don't need to use the ``collections`` keyword to access modules, actions, or other roles contained in the same collection."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:293
msgid "Using ``collections`` in playbooks"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:295
msgid "In a playbook, you can control the collections Ansible searches for modules and action plugins to execute. However, any roles you call in your playbook define their own collections search order; they do not inherit the calling playbook's settings. This is true even if the role does not define its own ``collections`` keyword."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:313
msgid "The ``collections`` keyword merely creates an ordered 'search path' for non-namespaced plugin and role references. It does not install content or otherwise change Ansible's behavior around the loading of plugins or roles. Note that an FQCN is still required for non-action or module plugins (for example, lookups, filters, tests)."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:317
msgid ":ref:`developing_collections`"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:318
msgid "Develop or modify a collection."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:319
msgid ":ref:`collections_galaxy_meta`"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:320
msgid "Understand the collections metadata structure."
msgstr ""

#: ../../rst/user_guide/collections_using.rst:321
msgid "`Mailing List <https://groups.google.com/group/ansible-devel>`_"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:322
msgid "The development mailing list"
msgstr ""

#: ../../rst/user_guide/collections_using.rst:323
#: ../../rst/user_guide/intro_adhoc.rst:205
#: ../../rst/user_guide/intro_bsd.rst:105
#: ../../rst/user_guide/intro_dynamic_inventory.rst:248
#: ../../rst/user_guide/intro_getting_started.rst:145
#: ../../rst/user_guide/intro_inventory.rst:790
#: ../../rst/user_guide/intro_patterns.rst:170
#: ../../rst/user_guide/modules.rst:35
#: ../../rst/user_guide/modules_intro.rst:51
#: ../../rst/user_guide/modules_support.rst:69
#: ../../rst/user_guide/playbooks_advanced_syntax.rst:111
#: ../../rst/user_guide/playbooks_async.rst:160
#: ../../rst/user_guide/playbooks_blocks.rst:188
#: ../../rst/user_guide/playbooks_conditionals.rst:507
#: ../../rst/user_guide/playbooks_debugger.rst:328
#: ../../rst/user_guide/playbooks_delegation.rst:135
#: ../../rst/user_guide/playbooks_environment.rst:140
#: ../../rst/user_guide/playbooks_error_handling.rst:244
#: ../../rst/user_guide/playbooks_filters.rst:1733
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:742
#: ../../rst/user_guide/playbooks_lookups.rst:36
#: ../../rst/user_guide/playbooks_loops.rst:444
#: ../../rst/user_guide/playbooks_prompts.rst:115
#: ../../rst/user_guide/playbooks_strategies.rst:221
#: ../../rst/user_guide/playbooks_tags.rst:428
#: ../../rst/user_guide/playbooks_templating.rst:54
#: ../../rst/user_guide/playbooks_tests.rst:402
#: ../../rst/user_guide/playbooks_variables.rst:465
#: ../../rst/user_guide/windows_dsc.rst:504
#: ../../rst/user_guide/windows_faq.rst:235
#: ../../rst/user_guide/windows_setup.rst:572
#: ../../rst/user_guide/windows_usage.rst:512
#: ../../rst/user_guide/windows_winrm.rst:912
msgid "`irc.freenode.net <http://irc.freenode.net>`_"
msgstr ""

#: ../../rst/user_guide/command_line_tools.rst:4
msgid "Working with command line tools"
msgstr ""

#: ../../rst/user_guide/command_line_tools.rst:6
msgid "Most users are familiar with `ansible` and `ansible-playbook`, but those are not the only utilities Ansible provides. Below is a complete list of Ansible utilities. Each page contains a description of the utility and a listing of supported parameters."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:4
msgid "Data manipulation"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:6
msgid "In many cases, you need to do some complex operation with your variables, while Ansible is not recommended as a data processing/manipulation tool, you can use the existing Jinja2 templating in conjunction with the many added Ansible filters, lookups and tests to do some very complex transformations."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:11
msgid "Let's start with a quick definition of each type of plugin:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:9
msgid "lookups: Mainly used to query 'external data', in Ansible these were the primary part of loops using the ``with_<lookup>`` construct, but they can be used independently to return data for processing. They normally return a list due to their primary function in loops as mentioned previously. Used with the ``lookup`` or ``query`` Jinja2 operators."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:10
msgid "filters: used to change/transform data, used with the ``|`` Jinja2 operator."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:11
msgid "tests: used to validate data, used with the ``is`` Jinja2 operator."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:19
msgid "Loops and list comprehensions"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:21
msgid "Most programming languages have loops (``for``, ``while``, and so on) and list comprehensions to do transformations on lists including lists of objects. Jinja2 has a few filters that provide this functionality: ``map``, ``select``, ``reject``, ``selectattr``, ``rejectattr``."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:23
msgid "map: this is a basic for loop that just allows you to change every item in a list, using the 'attribute' keyword you can do the transformation based on attributes of the list elements."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:24
msgid "select/reject: this is a for loop with a condition, that allows you to create a subset of a list that matches (or not) based on the result of the condition."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:25
msgid "selectattr/rejectattr: very similar to the above but it uses a specific attribute of the list elements for the conditional statement."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:30
msgid "Use a loop to create exponential backoff for retries/until."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:44
msgid "Extract keys from a dictionary matching elements from a list"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:46
msgid "The Python equivalent code would be:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:55
msgid "There are several ways to do it in Ansible, this is just one example:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:57
msgid "Way to extract matching keys from a list of dictionaries"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:84
msgid "Results of debug task, a list with the extracted keys"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:100
msgid "Find mount point"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:102
msgid "In this case, we want to find the mount point for a given path across our machines, since we already collect mount facts, we can use the following:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:104
msgid "Use selectattr to filter mounts into list I can then sort and select the last from"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:120
msgid "Omit elements from a list"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:122
msgid "The special ``omit`` variable ONLY works with module options, but we can still use it in other ways as an identifier to tailor a list of elements:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:124
msgid "Inline list filtering when feeding a module option"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:138
msgid "Another way is to avoid adding elements to the list in the first place, so you can just use it directly:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:140
msgid "Using set_fact in a loop to increment a list conditionally"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:157
msgid "Complex Type transformations"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:159
msgid "Jinja provides filters for simple data type transformations (``int``, ``bool``, and so on), but when you want to transform data structures things are not as easy. You can use loops and list comprehensions as shown above to help, also other filters and lookups can be chained and leveraged to achieve more complex transformations."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:166
msgid "Create dictionary from list"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:168
msgid "In most languages it is easy to create a dictionary (a.k.a. map/associative array/hash and so on) from a list of pairs, in Ansible there are a couple of ways to do it and the best one for you might depend on the source of your data."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:171
msgid "These example produces ``{\"a\": \"b\", \"c\": \"d\"}``"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:173
msgid "Simple list to dict by assuming the list is [key, value , key, value, ...]"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:181
msgid "It is simpler when we have a list of pairs:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:188
msgid "Both end up being the same thing, with the ``slice(2) | list`` transforming ``single_list`` to the same structure as ``list_of_pairs``."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:192
msgid "A bit more complex, using ``set_fact`` and a ``loop`` to create/update a dictionary with key value pairs from 2 lists:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:194
msgid "Using set_fact to create a dictionary from a set of lists"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:212
msgid "This results in ``{\"foo\": \"a\", \"var\": \"b\", \"bar\": \"c\"}``."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:215
msgid "You can even combine these simple examples with other filters and lookups to create a dictionary dynamically by matching patterns to variable names:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:217
msgid "Using 'vars' to define dictionary from a set of lists without needing a task"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:224
msgid "A quick explanation, since there is a lot to unpack from these two lines:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:226
msgid "The ``varnames`` lookup returns a list of variables that match \"begin with ``my``\"."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:227
msgid "Then feeding the list from the previous step into the ``vars`` lookup to get the list of values. The ``*`` is used to 'dereference the list' (a pythonism that works in Jinja), otherwise it would take the list as a single argument."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:229
msgid "Both lists get passed to the ``zip`` filter to pair them off into a unified list (key, value, key2, value2, ...)."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:230
msgid "The dict function then takes this 'list of pairs' to create the dictionary."
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:233
msgid "An example on how to use facts to find a host's data that meets condition X:"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:242
msgid "Using an example from @zoradache on reddit, to show the 'uptime in days/hours/minutes' (assumes facts where gathered). https://www.reddit.com/r/ansible/comments/gj5a93/trying_to_get_uptime_from_seconds/fqj2qr3/"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:254
msgid ":doc:`playbooks_filters`"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:255
msgid "Jinja2 filters included with Ansible"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:256
msgid ":doc:`playbooks_tests`"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:257
msgid "Jinja2 tests included with Ansible"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:258
msgid "`Jinja2 Docs <https://jinja.palletsprojects.com/>`_"
msgstr ""

#: ../../rst/user_guide/complex_data_manipulation.rst:259
msgid "Jinja2 documentation, includes lists for core filters and tests"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:5
msgid "Connection methods and details"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:7
msgid "This section shows you how to expand and refine the connection methods Ansible uses for your inventory."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:10
msgid "ControlPersist and paramiko"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:12
msgid "By default, Ansible uses native OpenSSH, because it supports ControlPersist (a performance feature), Kerberos, and options in ``~/.ssh/config`` such as Jump Host setup. If your control machine uses an older version of OpenSSH that does not support ControlPersist, Ansible will fallback to a Python implementation of OpenSSH called 'paramiko'."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:17
msgid "Setting a remote user"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:19
msgid "By default, Ansible connects to all remote devices with the user name you are using on the control node. If that user name does not exist on a remote device, you can set a different user name for the connection. If you just need to do some tasks as a different user, look at :ref:`become`. You can set the connection user in a playbook:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:32
msgid "as a host variable in inventory:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:39
msgid "or as a group variable in inventory:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:51
msgid "Setting up SSH keys"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:53
msgid "By default, Ansible assumes you are using SSH keys to connect to remote machines.  SSH keys are encouraged, but you can use password authentication if needed with the ``--ask-pass`` option. If you need to provide a password for :ref:`privilege escalation <become>` (sudo, pbrun, and so on), use ``--ask-become-pass``."
msgstr ""

#: ../../rst/user_guide/shared_snippets/SSH_password_prompt.txt:2
msgid "Ansible does not expose a channel to allow communication between the user and the ssh process to accept a password manually to decrypt an ssh key when using the ssh connection plugin (which is the default). The use of ``ssh-agent`` is highly recommended."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:57
msgid "To set up SSH agent to avoid retyping passwords, you can do:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:64
msgid "Depending on your setup, you may wish to use Ansible's ``--private-key`` command line option to specify a pem file instead.  You can also add the private key file:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:71
msgid "Another way to add private key files without using ssh-agent is using ``ansible_ssh_private_key_file`` in an inventory file as explained here:  :ref:`intro_inventory`."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:74
msgid "Running against localhost"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:76
msgid "You can run commands against the control node by using \"localhost\" or \"127.0.0.1\" for the server name:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:82
msgid "You can specify localhost explicitly by adding this to your inventory file:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:91
msgid "Managing host key checking"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:93
msgid "Ansible enables host key checking by default. Checking host keys guards against server spoofing and man-in-the-middle attacks, but it does require some maintenance."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:95
msgid "If a host is reinstalled and has a different key in 'known_hosts', this will result in an error message until corrected.  If a new host is not in 'known_hosts' your control node may prompt for confirmation of the key, which results in an interactive experience if using Ansible, from say, cron. You might not want this."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:97
msgid "If you understand the implications and wish to disable this behavior, you can do so by editing ``/etc/ansible/ansible.cfg`` or ``~/.ansible.cfg``:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:104
msgid "Alternatively this can be set by the :envvar:`ANSIBLE_HOST_KEY_CHECKING` environment variable:"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:110
msgid "Also note that host key checking in paramiko mode is reasonably slow, therefore switching to 'ssh' is also recommended when using this feature."
msgstr ""

#: ../../rst/user_guide/connection_details.rst:113
msgid "Other connection methods"
msgstr ""

#: ../../rst/user_guide/connection_details.rst:115
msgid "Ansible can use a variety of connection methods beyond SSH. You can select any connection plugin, including managing things locally and managing chroot, lxc, and jail containers. A mode called 'ansible-pull' can also invert the system and have systems 'phone home' via scheduled git checkouts to pull configuration directives from a central repository."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:3
msgid "Playbook Example: Continuous Delivery and Rolling Upgrades"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:11
msgid "What is continuous delivery?"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:13
msgid "Continuous delivery (CD) means frequently delivering updates to your software application."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:15
msgid "The idea is that by updating more often, you do not have to wait for a specific timed period, and your organization gets better at the process of responding to change."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:18
msgid "Some Ansible users are deploying updates to their end users on an hourly or even more frequent basis -- sometimes every time there is an approved code change.  To achieve this, you need tools to be able to quickly apply those updates in a zero-downtime way."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:21
msgid "This document describes in detail how to achieve this goal, using one of Ansible's most complete example playbooks as a template: lamp_haproxy. This example uses a lot of Ansible features: roles, templates, and group variables, and it also comes with an orchestration playbook that can do zero-downtime rolling upgrades of the web application stack."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:28
msgid "`Click here for the latest playbooks for this example <https://github.com/ansible/ansible-examples/tree/master/lamp_haproxy>`_."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:31
msgid "The playbooks deploy Apache, PHP, MySQL, Nagios, and HAProxy to a CentOS-based set of servers."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:33
msgid "We're not going to cover how to run these playbooks here. Read the included README in the github project along with the example for that information. Instead, we're going to take a close look at every part of the playbook and describe what it does."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:39
msgid "Site deployment"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:41
msgid "Let's start with ``site.yml``. This is our site-wide deployment playbook. It can be used to initially deploy the site, as well as push updates to all of the servers:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:86
msgid "If you're not familiar with terms like playbooks and plays, you should review :ref:`working_with_playbooks`."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:88
msgid "In this playbook we have 5 plays. The first one targets ``all`` hosts and applies the ``common`` role to all of the hosts. This is for site-wide things like yum repository configuration, firewall configuration, and anything else that needs to apply to all of the servers."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:91
msgid "The next four plays run against specific host groups and apply specific roles to those servers. Along with the roles for Nagios monitoring, the database, and the web application, we've implemented a ``base-apache`` role that installs and configures a basic Apache setup. This is used by both the sample web application and the Nagios hosts."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:99
msgid "Reusable content: roles"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:101
msgid "By now you should have a bit of understanding about roles and how they work in Ansible. Roles are a way to organize content: tasks, handlers, templates, and files, into reusable components."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:104
msgid "This example has six roles: ``common``, ``base-apache``, ``db``, ``haproxy``, ``nagios``, and ``web``. How you organize your roles is up to you and your application, but most sites will have one or more common roles that are applied to all systems, and then a series of application-specific roles that install and configure particular parts of the site."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:108
msgid "Roles can have variables and dependencies, and you can pass in parameters to roles to modify their behavior. You can read more about roles in the :ref:`playbooks_reuse_roles` section."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:114
msgid "Configuration: group variables"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:116
msgid "Group variables are variables that are applied to groups of servers. They can be used in templates and in playbooks to customize behavior and to provide easily-changed settings and parameters. They are stored in a directory called ``group_vars`` in the same location as your inventory. Here is lamp_haproxy's ``group_vars/all`` file. As you might expect, these variables are applied to all of the machines in your inventory:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:127
msgid "This is a YAML file, and you can create lists and dictionaries for more complex variable structures. In this case, we are just setting two variables, one for the port for the web server, and one for the NTP server that our machines should use for time synchronization."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:131
msgid "Here's another group variables file. This is ``group_vars/dbservers`` which applies to the hosts in the ``dbservers`` group:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:142
msgid "If you look in the example, there are group variables for the ``webservers`` group and the ``lbservers`` group, similarly."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:144
msgid "These variables are used in a variety of places. You can use them in playbooks, like this, in ``roles/db/tasks/main.yml``:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:161
msgid "You can also use these variables in templates, like this, in ``roles/common/templates/ntp.conf.j2``:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:176
msgid "You can see that the variable substitution syntax of {{ and }} is the same for both templates and variables. The syntax inside the curly braces is Jinja2, and you can do all sorts of operations and apply different filters to the data inside. In templates, you can also use for loops and if statements to handle more complex situations, like this, in ``roles/common/templates/iptables.j2``:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:187
msgid "This is testing to see if the inventory name of the machine we're currently operating on (``inventory_hostname``) exists in the inventory group ``dbservers``. If so, that machine will get an iptables ACCEPT line for port 3306."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:190
msgid "Here's another example, from the same template:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:198
msgid "This loops over all of the hosts in the group called ``monitoring``, and adds an ACCEPT line for each monitoring hosts' default IPv4 address to the current machine's iptables configuration, so that Nagios can monitor those hosts."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:201
msgid "You can learn a lot more about Jinja2 and its capabilities `here <https://jinja.palletsprojects.com/>`_, and you can read more about Ansible variables in general in the :ref:`playbooks_variables` section."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:207
msgid "The rolling upgrade"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:209
msgid "Now you have a fully-deployed site with web servers, a load balancer, and monitoring. How do you update it? This is where Ansible's orchestration features come into play. While some applications use the term 'orchestration' to mean basic ordering or command-blasting, Ansible refers to orchestration as 'conducting machines like an orchestra', and has a pretty sophisticated engine for it."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:213
msgid "Ansible has the capability to do operations on multi-tier applications in a coordinated way, making it easy to orchestrate a sophisticated zero-downtime rolling upgrade of our web application. This is implemented in a separate playbook, called ``rolling_update.yml``."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:215
msgid "Looking at the playbook, you can see it is made up of two plays. The first play is very simple and looks like this:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:222
msgid "What's going on here, and why are there no tasks? You might know that Ansible gathers \"facts\" from the servers before operating upon them. These facts are useful for all sorts of things: networking information, OS/distribution versions, and so on. In our case, we need to know something about all of the monitoring servers in our environment before we perform the update, so this simple play forces a fact-gathering step on our monitoring servers. You will see this pattern sometimes, and it's a useful trick to know."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:224
msgid "The next part is the update play. The first part looks like this:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:232
msgid "This is just a normal play definition, operating on the ``webservers`` group. The ``serial`` keyword tells Ansible how many servers to operate on at once. If it's not specified, Ansible will parallelize these operations up to the default \"forks\" limit specified in the configuration file. But for a zero-downtime rolling upgrade, you may not want to operate on that many hosts at once. If you had just a handful of webservers, you may want to set ``serial`` to 1, for one host at a time. If you have 100, maybe you could set ``serial`` to 10, for ten at a time."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:234
msgid "Here is the next part of the update play:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:253
msgid "The ``serial`` keyword forces the play to be executed in 'batches'. Each batch counts as a full play with a subselection of hosts. This has some consequences on play behavior. For example, if all hosts in a batch fails, the play fails, which in turn fails the entire run. You should consider this when combining with ``max_fail_percentage``."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:256
msgid "The ``pre_tasks`` keyword just lets you list tasks to run before the roles are called. This will make more sense in a minute. If you look at the names of these tasks, you can see that we are disabling Nagios alerts and then removing the webserver that we are currently updating from the HAProxy load balancing pool."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:258
msgid "The ``delegate_to`` and ``loop`` arguments, used together, cause Ansible to loop over each monitoring server and load balancer, and perform that operation (delegate that operation) on the monitoring or load balancing server, \"on behalf\" of the webserver. In programming terms, the outer loop is the list of web servers, and the inner loop is the list of monitoring servers."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:260
msgid "Note that the HAProxy step looks a little complicated.  We're using HAProxy in this example because it's freely available, though if you have (for instance) an F5 or Netscaler in your infrastructure (or maybe you have an AWS Elastic IP setup?), you can use Ansible modules  to communicate with them instead.  You might also wish to use other monitoring modules instead of nagios, but this just shows the main goal of the 'pre tasks' section -- take the server out of monitoring, and take it out of rotation."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:262
msgid "The next step simply re-applies the proper roles to the web servers. This will cause any configuration management declarations in ``web`` and ``base-apache`` roles to be applied to the web servers, including an update of the web application code itself. We don't have to do it this way--we could instead just purely update the web application, but this is a good example of how roles can be used to reuse tasks:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:271
msgid "Finally, in the ``post_tasks`` section, we reverse the changes to the Nagios configuration and put the web server back in the load balancing pool:"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:289
msgid "Again, if you were using a Netscaler or F5 or Elastic Load Balancer, you would just substitute in the appropriate modules instead."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:294
msgid "Managing other load balancers"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:296
msgid "In this example, we use the simple HAProxy load balancer to front-end the web servers. It's easy to configure and easy to manage. As we have mentioned, Ansible has support for a variety of other load balancers like Citrix NetScaler, F5 BigIP, Amazon Elastic Load Balancers, and more. See the :ref:`working_with_modules` documentation for more information."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:298
msgid "For other load balancers, you may need to send shell commands to them (like we do for HAProxy above), or call an API, if your load balancer exposes one. For the load balancers for which Ansible has modules, you may want to run them as a ``local_action`` if they contact an API. You can read more about local actions in the :ref:`playbooks_delegation` section.  Should you develop anything interesting for some hardware where there is not a module, it might make for a good contribution!"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:303
msgid "Continuous delivery end-to-end"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:305
msgid "Now that you have an automated way to deploy updates to your application, how do you tie it all together? A lot of organizations use a continuous integration tool like `Jenkins <https://jenkins.io/>`_ or `Atlassian Bamboo <https://www.atlassian.com/software/bamboo>`_ to tie the development, test, release, and deploy steps together. You may also want to use a tool like `Gerrit <https://www.gerritcodereview.com/>`_ to add a code review step to commits to either the application code itself, or to your Ansible playbooks, or both."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:307
msgid "Depending on your environment, you might be deploying continuously to a test environment, running an integration test battery against that environment, and then deploying automatically into production.  Or you could keep it simple and just use the rolling-update for on-demand deployment into test or production specifically.  This is all up to you."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:309
msgid "For integration with Continuous Integration systems, you can easily trigger playbook runs using the ``ansible-playbook`` command line tool, or, if you're using :ref:`ansible_tower`, the ``tower-cli`` or the built-in REST API.  (The tower-cli command 'joblaunch' will spawn a remote job over the REST API and is pretty slick)."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:311
msgid "This should give you a good idea of how to structure a multi-tier application with Ansible, and orchestrate operations upon that app, with the eventual goal of continuous delivery to your customers. You could extend the idea of the rolling upgrade to lots of different parts of the app; maybe add front-end web servers along with application servers, for instance, or replace the SQL database with something like MongoDB or Riak. Ansible gives you the capability to easily manage complicated environments and automate common operations."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:315
msgid "`lamp_haproxy example <https://github.com/ansible/ansible-examples/tree/master/lamp_haproxy>`_"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:316
msgid "The lamp_haproxy example discussed here."
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:317
#: ../../rst/user_guide/intro_adhoc.rst:201
#: ../../rst/user_guide/intro_bsd.rst:99
#: ../../rst/user_guide/intro_getting_started.rst:137
#: ../../rst/user_guide/intro_inventory.rst:786
#: ../../rst/user_guide/intro_patterns.rst:166
#: ../../rst/user_guide/modules_intro.rst:43
#: ../../rst/user_guide/modules_support.rst:65
#: ../../rst/user_guide/playbooks_best_practices.rst:156
#: ../../rst/user_guide/playbooks_conditionals.rst:497
#: ../../rst/user_guide/playbooks_lookups.rst:26
#: ../../rst/user_guide/playbooks_reuse.rst:186
#: ../../rst/user_guide/playbooks_reuse_includes.rst:15
#: ../../rst/user_guide/playbooks_reuse_roles.rst:471
#: ../../rst/user_guide/playbooks_roles.rst:15
#: ../../rst/user_guide/sample_setup.rst:274
msgid ":ref:`working_with_playbooks`"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:318
#: ../../rst/user_guide/playbooks_async.rst:157
#: ../../rst/user_guide/playbooks_blocks.rst:183
#: ../../rst/user_guide/playbooks_conditionals.rst:498
#: ../../rst/user_guide/playbooks_debugger.rst:325
#: ../../rst/user_guide/playbooks_delegation.rst:128
#: ../../rst/user_guide/playbooks_environment.rst:137
#: ../../rst/user_guide/playbooks_error_handling.rst:235
#: ../../rst/user_guide/playbooks_filters.rst:1720
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:727
#: ../../rst/user_guide/playbooks_lookups.rst:27
#: ../../rst/user_guide/playbooks_loops.rst:433
#: ../../rst/user_guide/playbooks_prompts.rst:108
#: ../../rst/user_guide/playbooks_startnstep.rst:38
#: ../../rst/user_guide/playbooks_strategies.rst:214
#: ../../rst/user_guide/playbooks_tags.rst:423
#: ../../rst/user_guide/playbooks_templating.rst:43
#: ../../rst/user_guide/playbooks_tests.rst:389
#: ../../rst/user_guide/playbooks_variables.rst:450
#: ../../rst/user_guide/windows_dsc.rst:497
#: ../../rst/user_guide/windows_faq.rst:230
#: ../../rst/user_guide/windows_setup.rst:565
#: ../../rst/user_guide/windows_usage.rst:505
#: ../../rst/user_guide/windows_winrm.rst:905
msgid "An introduction to playbooks"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:319
#: ../../rst/user_guide/playbooks_blocks.rst:184
#: ../../rst/user_guide/playbooks_conditionals.rst:499
#: ../../rst/user_guide/playbooks_filters.rst:1727
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:736
#: ../../rst/user_guide/playbooks_loops.rst:434
#: ../../rst/user_guide/playbooks_strategies.rst:217
#: ../../rst/user_guide/playbooks_tags.rst:424
#: ../../rst/user_guide/playbooks_templating.rst:48
#: ../../rst/user_guide/playbooks_tests.rst:396
#: ../../rst/user_guide/playbooks_variables.rst:457
msgid ":ref:`playbooks_reuse_roles`"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:320
msgid "An introduction to playbook roles"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:321
#: ../../rst/user_guide/playbooks_advanced_syntax.rst:105
#: ../../rst/user_guide/playbooks_conditionals.rst:503
#: ../../rst/user_guide/playbooks_error_handling.rst:240
#: ../../rst/user_guide/playbooks_filters.rst:1723
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:732
#: ../../rst/user_guide/playbooks_lookups.rst:30
#: ../../rst/user_guide/playbooks_loops.rst:440
#: ../../rst/user_guide/playbooks_prompts.rst:111
#: ../../rst/user_guide/playbooks_reuse.rst:188
#: ../../rst/user_guide/playbooks_reuse_includes.rst:19
#: ../../rst/user_guide/playbooks_reuse_roles.rst:475
#: ../../rst/user_guide/playbooks_tests.rst:392
msgid ":ref:`playbooks_variables`"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:322
msgid "An introduction to Ansible variables"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:323
msgid "`Ansible.com: Continuous Delivery <https://www.ansible.com/use-cases/continuous-delivery>`_"
msgstr ""

#: ../../rst/user_guide/guide_rolling_upgrade.rst:324
msgid "An introduction to Continuous Delivery with Ansible"
msgstr ""

#: ../../rst/user_guide/index.rst:5
msgid "User Guide"
msgstr ""

#: ../../rst/user_guide/index.rst:7
msgid "Welcome to the Ansible User Guide! This guide covers how to work with Ansible, including using the command line, working with inventory, interacting with data, writing tasks, plays, and playbooks; executing playbooks, and reference materials. This page outlines the most common situations and questions that bring readers to this section. If you prefer a traditional table of contents, you can find one at the bottom of the page."
msgstr ""

#: ../../rst/user_guide/index.rst:10
msgid "Getting started"
msgstr ""

#: ../../rst/user_guide/index.rst:12
msgid "I'd like an overview of how Ansible works. Where can I find:"
msgstr ""

#: ../../rst/user_guide/index.rst:14
msgid "a :ref:`quick video overview <quickstart_guide>`"
msgstr ""

#: ../../rst/user_guide/index.rst:15
msgid "a :ref:`text introduction <intro_getting_started>`"
msgstr ""

#: ../../rst/user_guide/index.rst:17
msgid "I'm ready to learn about Ansible. What :ref:`basic_concepts` do I need to learn?"
msgstr ""

#: ../../rst/user_guide/index.rst:18
msgid "I want to use Ansible without writing a playbook. How do I use :ref:`ad-hoc commands <intro_adhoc>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:21
msgid "Writing tasks, plays, and playbooks"
msgstr ""

#: ../../rst/user_guide/index.rst:23
msgid "I'm writing my first playbook. What should I :ref:`know before I begin <playbooks_tips_and_tricks>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:24
msgid "I have a specific use case for a task or play:"
msgstr ""

#: ../../rst/user_guide/index.rst:26
msgid "Executing tasks with elevated privileges or as a different user with :ref:`become <become>`"
msgstr ""

#: ../../rst/user_guide/index.rst:27
msgid "Repeating a task once for each item in a list with :ref:`loops <playbooks_loops>`"
msgstr ""

#: ../../rst/user_guide/index.rst:28
msgid "Executing tasks on a different machine with :ref:`delegation <playbooks_delegation>`"
msgstr ""

#: ../../rst/user_guide/index.rst:29
msgid "Running tasks only when certain conditions apply with :ref:`conditionals <playbooks_conditionals>` and evaluating conditions with :ref:`tests <playbooks_tests>`"
msgstr ""

#: ../../rst/user_guide/index.rst:30
msgid "Grouping a set of tasks together with :ref:`blocks <playbooks_blocks>`"
msgstr ""

#: ../../rst/user_guide/index.rst:31
msgid "Running tasks only when something has changed with :ref:`handlers <handlers>`"
msgstr ""

#: ../../rst/user_guide/index.rst:32
msgid "Changing the way Ansible :ref:`handles failures <playbooks_error_handling>`"
msgstr ""

#: ../../rst/user_guide/index.rst:33
msgid "Setting remote :ref:`environment values <playbooks_environment>`"
msgstr ""

#: ../../rst/user_guide/index.rst:35
msgid "I want to leverage the power of re-usable Ansible artifacts. How do I create re-usable :ref:`files <playbooks_reuse>` and :ref:`roles <playbooks_reuse_roles>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:36
msgid "I need to incorporate one file or playbook inside another. What is the difference between :ref:`including and importing <playbooks_reuse_includes>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:37
msgid "I want to run selected parts of my playbook. How do I add and use :ref:`tags <tags>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:40
msgid "Working with inventory"
msgstr ""

#: ../../rst/user_guide/index.rst:42
msgid "I have a list of servers and devices I want to automate. How do I create :ref:`inventory <intro_inventory>` to track them?"
msgstr ""

#: ../../rst/user_guide/index.rst:43
msgid "I use cloud services and constantly have servers and devices starting and stopping. How do I track them using :ref:`dynamic inventory <intro_dynamic_inventory>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:44
msgid "I want to automate specific sub-sets of my inventory. How do I use :ref:`patterns <intro_patterns>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:47
msgid "Interacting with data"
msgstr ""

#: ../../rst/user_guide/index.rst:49
msgid "I want to use a single playbook against multiple systems with different attributes. How do I use :ref:`variables <playbooks_variables>` to handle the differences?"
msgstr ""

#: ../../rst/user_guide/index.rst:50
msgid "I want to retrieve data about my systems. How do I access :ref:`Ansible facts <vars_and_facts>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:51
msgid "I need to access sensitive data like passwords with Ansible. How can I protect that data with :ref:`Ansible vault <vault>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:52
msgid "I want to change the data I have, so I can use it in a task. How do I use :ref:`filters <playbooks_filters>` to transform my data?"
msgstr ""

#: ../../rst/user_guide/index.rst:53
msgid "I need to retrieve data from an external datastore. How do I use :ref:`lookups <playbooks_lookups>` to access databases and APIs?"
msgstr ""

#: ../../rst/user_guide/index.rst:54
msgid "I want to ask playbook users to supply data. How do I get user input with :ref:`prompts <playbooks_prompts>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:55
msgid "I use certain modules frequently. How do I streamline my inventory and playbooks by :ref:`setting default values for module parameters <module_defaults>`?"
msgstr ""

#: ../../rst/user_guide/index.rst:58
msgid "Executing playbooks"
msgstr ""

#: ../../rst/user_guide/index.rst:60
msgid "Once your playbook is ready to run, you may need to use these topics:"
msgstr ""

#: ../../rst/user_guide/index.rst:62
msgid "Executing \"dry run\" playbooks with :ref:`check mode and diff <check_mode_dry>`"
msgstr ""

#: ../../rst/user_guide/index.rst:63
msgid "Running playbooks while troubleshooting with :ref:`start and step <playbooks_start_and_step>`"
msgstr ""

#: ../../rst/user_guide/index.rst:64
msgid "Correcting tasks during execution with the :ref:`Ansible debugger <playbook_debugger>`"
msgstr ""

#: ../../rst/user_guide/index.rst:65
msgid "Controlling how my playbook executes with :ref:`strategies and more <playbooks_strategies>`"
msgstr ""

#: ../../rst/user_guide/index.rst:66
msgid "Running tasks, plays, and playbooks :ref:`asynchronously <playbooks_async>`"
msgstr ""

#: ../../rst/user_guide/index.rst:69
msgid "Advanced features and reference"
msgstr ""

#: ../../rst/user_guide/index.rst:71
msgid "Using :ref:`advanced syntax <playbooks_advanced_syntax>`"
msgstr ""

#: ../../rst/user_guide/index.rst:72
msgid "Manipulating :ref:`complex data <complex_data_manipulation>`"
msgstr ""

#: ../../rst/user_guide/index.rst:73
msgid "Using :ref:`plugins <plugins_lookup>`"
msgstr ""

#: ../../rst/user_guide/index.rst:74
msgid "Using :ref:`playbook keywords <playbook_keywords>`"
msgstr ""

#: ../../rst/user_guide/index.rst:75
msgid "Using :ref:`command-line tools <command_line_tools>`"
msgstr ""

#: ../../rst/user_guide/index.rst:76
msgid "Rejecting :ref:`specific modules <plugin_filtering_config>`"
msgstr ""

#: ../../rst/user_guide/index.rst:77
msgid "Module :ref:`maintenance <modules_support>`"
msgstr ""

#: ../../rst/user_guide/index.rst:80
msgid "Traditional Table of Contents"
msgstr ""

#: ../../rst/user_guide/index.rst:82
msgid "If you prefer to read the entire User Guide, here's a list of the pages in order:"
msgstr ""

#: ../../rst/user_guide/intro.rst:4
msgid "Introduction"
msgstr ""

#: ../../rst/user_guide/intro.rst:6
msgid "Before we start exploring the main components of Ansible -- playbooks, configuration management, deployment, and orchestration -- we'll learn how to get Ansible installed and cover some basic concepts.  We'll also go over how to execute ad-hoc commands in parallel across your nodes using /usr/bin/ansible, and see what modules are available in Ansible's core (you can also write your own, which is covered later)."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:5
msgid "Introduction to ad-hoc commands"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:7
msgid "An Ansible ad-hoc command uses the `/usr/bin/ansible` command-line tool to automate a single task on one or more managed nodes. Ad-hoc commands are quick and easy, but they are not reusable. So why learn about ad-hoc commands first? Ad-hoc commands demonstrate the simplicity and power of Ansible. The concepts you learn here will port over directly to the playbook language. Before reading and executing these examples, please read :ref:`intro_inventory`."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:13
msgid "Why use ad-hoc commands?"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:15
msgid "Ad-hoc commands are great for tasks you repeat rarely. For example, if you want to power off all the machines in your lab for Christmas vacation, you could execute a quick one-liner in Ansible without writing a playbook. An ad-hoc command looks like this:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:21
msgid "You can learn more about :ref:`patterns<intro_patterns>` and :ref:`modules<working_with_modules>` on other pages."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:24
msgid "Use cases for ad-hoc tasks"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:26
msgid "Ad-hoc tasks can be used to reboot servers, copy files, manage packages and users, and much more. You can use any Ansible module in an ad-hoc task. Ad-hoc tasks, like playbooks, use a declarative model, calculating and executing the actions required to reach a specified final state. They achieve a form of idempotence by checking the current state before they begin and doing nothing unless the current state is different from the specified final state."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:31
msgid "Rebooting servers"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:33
msgid "The default module for the ``ansible`` command-line utility is the :ref:`ansible.builtin.command module<command_module>`. You can use an ad-hoc task to call the command module and reboot all web servers in Atlanta, 10 at a time. Before Ansible can do this, you must have all servers in Atlanta listed in a group called [atlanta] in your inventory, and you must have working SSH credentials for each machine in that group. To reboot all the servers in the [atlanta] group:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:39
msgid "By default Ansible uses only 5 simultaneous processes. If you have more hosts than the value set for the fork count, Ansible will talk to them, but it will take a little longer. To reboot the [atlanta] servers with 10 parallel forks:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:45
msgid "/usr/bin/ansible will default to running from your user account. To connect as a different user:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:51
msgid "Rebooting probably requires privilege escalation. You can connect to the server as ``username`` and run the command as the ``root`` user by using the :ref:`become <become>` keyword:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:57
msgid "If you add ``--ask-become-pass`` or ``-K``, Ansible prompts you for the password to use for privilege escalation (sudo/su/pfexec/doas/etc)."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:60
msgid "The :ref:`command module <command_module>` does not support extended shell syntax like piping and redirects (although shell variables will always work). If your command requires shell-specific syntax, use the `shell` module instead. Read more about the differences on the :ref:`working_with_modules` page."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:65
msgid "So far all our examples have used the default 'command' module. To use a different module, pass ``-m`` for module name. For example, to use the :ref:`ansible.builtin.shell module <shell_module>`:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:71
msgid "When running any command with the Ansible *ad hoc* CLI (as opposed to :ref:`Playbooks <working_with_playbooks>`), pay particular attention to shell quoting rules, so the local shell retains the variable and passes it to Ansible. For example, using double rather than single quotes in the above example would evaluate the variable on the box you were on."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:80
msgid "Managing files"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:82
msgid "An ad-hoc task can harness the power of Ansible and SCP to transfer many files to multiple machines in parallel. To transfer a file directly to all servers in the [atlanta] group:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:88
msgid "If you plan to repeat a task like this, use the :ref:`ansible.builtin.template<template_module>` module in a playbook."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:90
msgid "The :ref:`ansible.builtin.file<file_module>` module allows changing ownership and permissions on files. These same options can be passed directly to the ``copy`` module as well:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:98
msgid "The ``file`` module can also create directories, similar to ``mkdir -p``:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:104
msgid "As well as delete directories (recursively) and delete files:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:113
msgid "Managing packages"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:115
msgid "You might also use an ad-hoc task to install, update, or remove packages on managed nodes using a package management module like yum. To ensure a package is installed without updating it:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:121
msgid "To ensure a specific version of a package is installed:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:127
msgid "To ensure a package is at the latest version:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:133
msgid "To ensure a package is not installed:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:139
msgid "Ansible has modules for managing packages under many platforms. If there is no module for your package manager, you can install packages using the command module or create a module for your package manager."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:144
msgid "Managing users and groups"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:146
msgid "You can create, manage, and remove user accounts on your managed nodes with ad-hoc tasks:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:154
msgid "See the :ref:`ansible.builtin.user <user_module>` module documentation for details on all of the available options, including how to manipulate groups and group membership."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:160
msgid "Managing services"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:162
msgid "Ensure a service is started on all webservers:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:168
msgid "Alternatively, restart a service on all webservers:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:174
msgid "Ensure a service is stopped:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:183
msgid "Gathering facts"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:185
msgid "Facts represent discovered variables about a system. You can use facts to implement conditional execution of tasks but also just to get ad-hoc information about your systems. To see all facts:"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:191
msgid "You can also filter this output to display only certain facts, see the :ref:`ansible.builtin.setup <setup_module>` module documentation for details."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:193
msgid "Now that you understand the basic elements of Ansible execution, you are ready to learn to automate repetitive tasks using :ref:`Ansible Playbooks <playbooks_intro>`."
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:197
msgid ":ref:`intro_configuration`"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:198
msgid "All about the Ansible config file"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:199
#: ../../rst/user_guide/playbooks_best_practices.rst:158
#: ../../rst/user_guide/playbooks_intro.rst:146
#: ../../rst/user_guide/playbooks_reuse_includes.rst:25
#: ../../rst/user_guide/playbooks_reuse_roles.rst:483
#: ../../rst/user_guide/sample_setup.rst:276
msgid ":ref:`list_of_collections`"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:200
#: ../../rst/user_guide/playbooks_best_practices.rst:159
#: ../../rst/user_guide/playbooks_intro.rst:147
#: ../../rst/user_guide/playbooks_reuse_includes.rst:26
#: ../../rst/user_guide/playbooks_reuse_roles.rst:484
#: ../../rst/user_guide/sample_setup.rst:277
msgid "Browse existing collections, modules, and plugins"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:202
msgid "Using Ansible for configuration management & deployment"
msgstr ""

#: ../../rst/user_guide/intro_adhoc.rst:203
#: ../../rst/user_guide/intro_bsd.rst:103
#: ../../rst/user_guide/intro_dynamic_inventory.rst:246
#: ../../rst/user_guide/intro_getting_started.rst:143
#: ../../rst/user_guide/intro_inventory.rst:788
#: ../../rst/user_guide/intro_patterns.rst:168
#: ../../rst/user_guide/modules.rst:33
#: ../../rst/user_guide/modules_intro.rst:49
#: ../../rst/user_guide/modules_support.rst:67
#: ../../rst/user_guide/playbooks_best_practices.rst:166
#: ../../rst/user_guide/playbooks_intro.rst:154
#: ../../rst/user_guide/playbooks_reuse.rst:200
#: ../../rst/user_guide/playbooks_reuse_includes.rst:31
#: ../../rst/user_guide/playbooks_reuse_roles.rst:489
#: ../../rst/user_guide/sample_setup.rst:284
msgid "`Mailing List <https://groups.google.com/group/ansible-project>`_"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:4
msgid "Ansible and BSD"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:6
msgid "Managing BSD machines is different from managing other Unix-like machines. If you have managed nodes running BSD, review these topics."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:12
msgid "Connecting to BSD nodes"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:14
msgid "Ansible connects to managed nodes using OpenSSH by default. This works on BSD if you use SSH keys for authentication. However, if you use SSH passwords for authentication, Ansible relies on sshpass. Most versions of sshpass do not deal well with BSD login prompts, so when using SSH passwords against BSD machines, use ``paramiko`` to connect instead of OpenSSH. You can do this in ansible.cfg globally or you can set it as an inventory/group/host variable. For example:"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:25
msgid "Bootstrapping BSD"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:27
msgid "Ansible is agentless by default, however, it requires Python on managed nodes. Only the :ref:`raw <raw_module>` module will operate without Python. Although this module can be used to bootstrap Ansible and install Python on BSD variants (see below), it is very limited and the use of Python is required to make full use of Ansible's features."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:29
msgid "The following example installs Python 2.7 which includes the json library required for full functionality of Ansible. On your control machine you can execute the following for most versions of FreeBSD:"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:36
msgid "Or for OpenBSD:"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:42
msgid "Once this is done you can now use other Ansible modules apart from the ``raw`` module."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:45
msgid "This example demonstrated using pkg on FreeBSD and pkg_add on OpenBSD, however you should be able to substitute the appropriate package tool for your BSD; the package name may also differ. Refer to the package list or documentation of the BSD variant you are using for the exact Python package name you intend to install."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:50
msgid "Setting the Python interpreter"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:52
msgid "To support a variety of Unix-like operating systems and distributions, Ansible cannot always rely on the existing environment or ``env`` variables to locate the correct Python binary. By default, modules point at ``/usr/bin/python`` as this is the most common location. On BSD variants, this path may differ, so it is advised to inform Ansible of the binary's location, through the ``ansible_python_interpreter`` inventory variable. For example:"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:61
msgid "If you use additional plugins beyond those bundled with Ansible, you can set similar variables for ``bash``, ``perl`` or ``ruby``, depending on how the plugin is written. For example:"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:71
msgid "Which modules are available?"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:73
msgid "The majority of the core Ansible modules are written for a combination of Unix-like machines and other generic services, so most should function well on the BSDs with the obvious exception of those that are aimed at Linux-only technologies (such as LVG)."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:76
msgid "Using BSD as the control node"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:78
msgid "Using BSD as the control machine is as simple as installing the Ansible package for your BSD variant or by following the ``pip`` or 'from source' instructions."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:83
msgid "BSD facts"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:85
msgid "Ansible gathers facts from the BSDs in a similar manner to Linux machines, but since the data, names and structures can vary for network, disks and other devices, one should expect the output to be slightly different yet still familiar to a BSD administrator."
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:90
msgid "BSD efforts and contributions"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:92
msgid "BSD support is important to us at Ansible. Even though the majority of our contributors use and target Linux we have an active BSD community and strive to be as BSD-friendly as possible. Please feel free to report any issues or incompatibilities you discover with BSD; pull requests with an included fix are also welcome!"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:97
#: ../../rst/user_guide/intro_getting_started.rst:135
#: ../../rst/user_guide/intro_inventory.rst:784
#: ../../rst/user_guide/intro_patterns.rst:164
#: ../../rst/user_guide/modules.rst:23
#: ../../rst/user_guide/modules_intro.rst:41
#: ../../rst/user_guide/modules_support.rst:63
msgid ":ref:`intro_adhoc`"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:98
#: ../../rst/user_guide/intro_getting_started.rst:136
#: ../../rst/user_guide/intro_inventory.rst:785
#: ../../rst/user_guide/intro_patterns.rst:165
msgid "Examples of basic commands"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:100
msgid "Learning ansible's configuration management language"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:101
#: ../../rst/user_guide/modules_intro.rst:45
#: ../../rst/user_guide/playbooks_best_practices.rst:160
#: ../../rst/user_guide/playbooks_intro.rst:148
#: ../../rst/user_guide/playbooks_reuse_includes.rst:27
#: ../../rst/user_guide/playbooks_reuse_roles.rst:485
#: ../../rst/user_guide/sample_setup.rst:278
msgid ":ref:`developing_modules`"
msgstr ""

#: ../../rst/user_guide/intro_bsd.rst:102
msgid "How to write modules"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:6
msgid "Working with dynamic inventory"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:11
msgid "If your Ansible inventory fluctuates over time, with hosts spinning up and shutting down in response to business demands, the static inventory solutions described in :ref:`inventory` will not serve your needs. You may need to track hosts from multiple sources: cloud providers, LDAP, `Cobbler <https://cobbler.github.io>`_, and/or enterprise CMDB systems."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:13
msgid "Ansible integrates all of these options through a dynamic external inventory system. Ansible supports two ways to connect with external inventory:  :ref:`inventory_plugins` and `inventory scripts`."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:15
msgid "Inventory plugins take advantage of the most recent updates to the Ansible core code. We recommend plugins over scripts for dynamic inventory. You can :ref:`write your own plugin <developing_inventory>` to connect to additional dynamic inventory sources."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:17
msgid "You can still use inventory scripts if you choose. When we implemented inventory plugins, we ensured backwards compatibility through the script inventory plugin. The examples below illustrate how to use inventory scripts."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:19
msgid "If you prefer a GUI for handling dynamic inventory, the :ref:`ansible_tower` inventory database syncs with all your dynamic inventory sources, provides web and REST access to the results, and offers a graphical inventory editor. With a database record of all of your hosts, you can correlate past event history and see which hosts have had failures on their last playbook runs."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:24
msgid "Inventory script example: Cobbler"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:26
msgid "Ansible integrates seamlessly with `Cobbler <https://cobbler.github.io>`_, a Linux installation server originally written by Michael DeHaan and now led by James Cammarata, who works for Ansible."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:28
msgid "While primarily used to kickoff OS installations and manage DHCP and DNS, Cobbler has a generic layer that can represent data for multiple configuration management systems (even at the same time) and serve as a 'lightweight CMDB'."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:31
msgid "To tie your Ansible inventory to Cobbler, copy `this script <https://raw.githubusercontent.com/ansible-collections/community.general/main/scripts/inventory/cobbler.py>`_ to ``/etc/ansible`` and ``chmod +x`` the file. Run ``cobblerd`` any time you use Ansible and use the ``-i`` command line option (for example, ``-i /etc/ansible/cobbler.py``) to communicate with Cobbler using Cobbler's XMLRPC API."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:33
msgid "Add a ``cobbler.ini`` file in ``/etc/ansible`` so Ansible knows where the Cobbler server is and some cache improvements can be used. For example:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:56
msgid "First test the script by running ``/etc/ansible/cobbler.py`` directly. You should see some JSON data output, but it may not have anything in it just yet."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:58
msgid "Let's explore what this does.  In Cobbler, assume a scenario somewhat like the following:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:67
msgid "In the example above, the system 'foo.example.com' is addressable by ansible directly, but is also addressable when using the group names 'webserver' or 'atlanta'. Since Ansible uses SSH, it contacts system foo over 'foo.example.com', only, never just 'foo'. Similarly, if you tried \"ansible foo\", it would not find the system... but \"ansible 'foo*'\" would do, because the system DNS name starts with 'foo'."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:69
msgid "The script provides more than host and group info. In addition, as a bonus, when the 'setup' module is run (which happens automatically when using playbooks), the variables 'a', 'b', and 'c' will all be auto-populated in the templates:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:76
msgid "Which could be executed just like this:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:84
msgid "The name 'webserver' came from Cobbler, as did the variables for the config file.  You can still pass in your own variables like normal in Ansible, but variables from the external inventory script will override any that have the same name."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:89
msgid "So, with the template above (``motd.j2``), this results in the following data being written to ``/etc/motd`` for system 'foo':"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:95
msgid "And on system 'bar' (bar.example.com):"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:101
msgid "And technically, though there is no major good reason to do it, this also works:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:107
msgid "So, in other words, you can use those variables in arguments/actions as well."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:112
msgid "Inventory script example: OpenStack"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:114
msgid "If you use an OpenStack-based cloud, instead of manually maintaining your own inventory file, you can use the ``openstack_inventory.py`` dynamic inventory to pull information about your compute instances directly from OpenStack."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:116
msgid "You can download the latest version of the OpenStack inventory script `here <https://raw.githubusercontent.com/openstack/ansible-collections-openstack/master/scripts/inventory/openstack_inventory.py>`_."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:118
msgid "You can use the inventory script explicitly (by passing the `-i openstack_inventory.py` argument to Ansible) or implicitly (by placing the script at `/etc/ansible/hosts`)."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:121
msgid "Explicit use of OpenStack inventory script"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:123
msgid "Download the latest version of the OpenStack dynamic inventory script and make it executable::"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:129
msgid "Do not name it `openstack.py`. This name will conflict with imports from openstacksdk."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:131
msgid "Source an OpenStack RC file:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:139
msgid "An OpenStack RC file contains the environment variables required by the client tools to establish a connection with the cloud provider, such as the authentication URL, user name, password and region name. For more information on how to download, create or source an OpenStack RC file, please refer to `Set environment variables using the OpenStack RC file <https://docs.openstack.org/user-guide/common/cli_set_environment_variables_using_openstack_rc.html>`_."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:141
msgid "You can confirm the file has been successfully sourced by running a simple command, such as `nova list` and ensuring it returns no errors."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:145
msgid "The OpenStack command line clients are required to run the `nova list` command. For more information on how to install them, please refer to `Install the OpenStack command-line clients <https://docs.openstack.org/user-guide/common/cli_install_openstack_command_line_clients.html>`_."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:147
msgid "You can test the OpenStack dynamic inventory script manually to confirm it is working as expected::"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:151
#: ../../rst/user_guide/intro_dynamic_inventory.rst:184
msgid "After a few moments you should see some JSON output with information about your compute instances."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:153
msgid "Once you confirm the dynamic inventory script is working as expected, you can tell Ansible to use the `openstack_inventory.py` script as an inventory file, as illustrated below:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:160
msgid "Implicit use of OpenStack inventory script"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:162
msgid "Download the latest version of the OpenStack dynamic inventory script, make it executable and copy it to `/etc/ansible/hosts`:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:170
msgid "Download the sample configuration file, modify it to suit your needs and copy it to `/etc/ansible/openstack.yml`:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:178
msgid "You can test the OpenStack dynamic inventory script manually to confirm it is working as expected:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:187
msgid "Refreshing the cache"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:189
msgid "Note that the OpenStack dynamic inventory script will cache results to avoid repeated API calls. To explicitly clear the cache, you can run the openstack_inventory.py (or hosts) script with the ``--refresh`` parameter:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:198
msgid "Other inventory scripts"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:200
msgid "In Ansible 2.10 and later, inventory scripts moved to their associated collections. Many are now in the `community.general scripts/inventory directory <https://github.com/ansible-collections/community.general/tree/main/scripts/inventory>`_. We recommend you use :ref:`inventory_plugins` instead."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:205
msgid "Using inventory directories and multiple inventory sources"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:207
msgid "If the location given to ``-i`` in Ansible is a directory (or as so configured in ``ansible.cfg``), Ansible can use multiple inventory sources at the same time.  When doing so, it is possible to mix both dynamic and statically managed inventory sources in the same ansible run. Instant hybrid cloud!"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:211
msgid "In an inventory directory, executable files are treated as dynamic inventory sources and most other files as static sources. Files which end with any of the following are ignored:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:217
msgid "You can replace this list with your own selection by configuring an ``inventory_ignore_extensions`` list in ``ansible.cfg``, or setting the :envvar:`ANSIBLE_INVENTORY_IGNORE` environment variable. The value in either case must be a comma-separated list of patterns, as shown above."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:219
msgid "Any ``group_vars`` and ``host_vars`` subdirectories in an inventory directory are interpreted as expected, making inventory directories a powerful way to organize different sets of configurations. See :ref:`using_multiple_inventory_sources` for more information."
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:224
msgid "Static groups of dynamic groups"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:226
msgid "When defining groups of groups in the static inventory file, the child groups must also be defined in the static inventory file, otherwise ansible returns an error. If you want to define a static group of dynamic child groups, define the dynamic groups as empty in the static inventory file. For example:"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:244
#: ../../rst/user_guide/intro_getting_started.rst:133
msgid ":ref:`intro_inventory`"
msgstr ""

#: ../../rst/user_guide/intro_dynamic_inventory.rst:245
msgid "All about static inventory files"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:5
msgid "Getting Started"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:7
msgid "Now that you have read the :ref:`installation guide<installation_guide>` and installed Ansible on a control node, you are ready to learn how Ansible works. A basic Ansible command or playbook:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:9
msgid "selects machines to execute against from inventory"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:10
msgid "connects to those machines (or network devices, or other managed nodes), usually over SSH"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:11
msgid "copies one or more modules to the remote machines and starts execution there"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:13
msgid "Ansible can do much more, but you should understand the most common use case before exploring all the powerful configuration, deployment, and orchestration features of Ansible. This page illustrates the basic process with a simple inventory and an ad-hoc command. Once you understand how Ansible works, you can read more details about :ref:`ad-hoc commands<intro_adhoc>`, organize your infrastructure with :ref:`inventory<intro_inventory>`, and harness the full power of Ansible with :ref:`playbooks<playbooks_intro>`."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:19
msgid "Selecting machines from inventory"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:21
msgid "Ansible reads information about which machines you want to manage from your inventory. Although you can pass an IP address to an ad-hoc command, you need inventory to take advantage of the full flexibility and repeatability of Ansible."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:24
msgid "Action: create a basic inventory"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:25
msgid "For this basic inventory, edit (or create) ``/etc/ansible/hosts`` and add a few remote systems to it. For this example, use either IP addresses or FQDNs:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:34
#: ../../rst/user_guide/intro_getting_started.rst:49
#: ../../rst/user_guide/intro_getting_started.rst:98
msgid "Beyond the basics"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:35
msgid "Your inventory can store much more than IPs and FQDNs. You can create :ref:`aliases<inventory_aliases>`, set variable values for a single host with :ref:`host vars<host_variables>`, or set variable values for multiple hosts with :ref:`group vars<group_variables>`."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:40
msgid "Connecting to remote nodes"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:42
msgid "Ansible communicates with remote machines over the `SSH protocol <https://www.ssh.com/ssh/protocol/>`_. By default, Ansible uses native OpenSSH and connects to remote machines using your current user name, just as SSH does."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:45
msgid "Action: check your SSH connections"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:46
msgid "Confirm that you can connect using SSH to all the nodes in your inventory using the same username. If necessary, add your public SSH key to the ``authorized_keys`` file on those systems."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:50
msgid "You can override the default remote user name in several ways, including:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:52
msgid "passing the ``-u`` parameter at the command line"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:53
msgid "setting user information in your inventory file"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:54
msgid "setting user information in your configuration file"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:55
msgid "setting environment variables"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:57
msgid "See :ref:`general_precedence_rules` for details on the (sometimes unintuitive) precedence of each method of passing user information. You can read more about connections in :ref:`connections`."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:60
msgid "Copying and executing modules"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:62
msgid "Once it has connected, Ansible transfers the modules required by your command or playbook to the remote machine(s) for execution."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:65
msgid "Action: run your first Ansible commands"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:66
msgid "Use the ping module to ping all the nodes in your inventory:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:72
#: ../../rst/user_guide/intro_getting_started.rst:90
msgid "You should see output for each host in your inventory, similar to this:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:84
msgid "Now run a live command on all of your nodes:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:99
msgid "By default Ansible uses SFTP to transfer files. If the machine or device you want to manage does not support SFTP, you can switch to SCP mode in :ref:`intro_configuration`. The files are placed in a temporary directory and executed from there."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:101
msgid "If you need privilege escalation (sudo and similar) to run a command, pass the ``become`` flags:"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:112
msgid "You can read more about privilege escalation in :ref:`become`."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:114
msgid "Congratulations! You have contacted your nodes using Ansible. You used a basic inventory file and an ad-hoc command to direct Ansible to connect to specific remote nodes, copy a module file there and execute it, and return output. You have a fully working infrastructure."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:117
msgid "Resources"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:118
msgid "`Product Demos <https://github.com/ansible/product-demos>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:119
msgid "`Katakoda <https://katacoda.com/rhel-labs>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:120
msgid "`Workshops <https://github.com/ansible/workshops>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:121
msgid "`Ansible Examples <https://github.com/ansible/ansible-examples>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:122
msgid "`Ansible Baseline <https://github.com/ansible/ansible-baseline>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:125
msgid "Next steps"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:126
msgid "Next you can read about more real-world cases in :ref:`intro_adhoc`, explore what you can do with different modules, or read about the Ansible :ref:`working_with_playbooks` language.  Ansible is not just about running commands, it also has powerful configuration management and deployment features."
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:134
msgid "More information about inventory"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:138
msgid "Learning Ansible's configuration management language"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:139
msgid "`Ansible Demos <https://github.com/ansible/product-demos>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:140
msgid "Demonstrations of different Ansible usecases"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:141
msgid "`RHEL Labs <https://katacoda.com/rhel-labs>`_"
msgstr ""

#: ../../rst/user_guide/intro_getting_started.rst:142
msgid "Labs to provide further knowledge on different topics"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:6
msgid "How to build your inventory"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:8
msgid "Ansible works against multiple managed nodes or \"hosts\" in your infrastructure at the same time, using a list or group of lists known as inventory. Once your inventory is defined, you use :ref:`patterns <intro_patterns>` to select the hosts or groups you want Ansible to run against."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:10
msgid "The default location for inventory is a file called ``/etc/ansible/hosts``. You can specify a different inventory file at the command line using the ``-i <path>`` option. You can also use multiple inventory files at the same time, and/or pull inventory from dynamic or cloud sources or different formats (YAML, ini, and so on), as described in :ref:`intro_dynamic_inventory`. Introduced in version 2.4, Ansible has :ref:`inventory_plugins` to make this flexible and customizable."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:19
msgid "Inventory basics: formats, hosts, and groups"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:21
msgid "The inventory file can be in one of many formats, depending on the inventory plugins you have. The most common formats are INI and YAML. A basic INI ``/etc/ansible/hosts`` might look like this:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:37
msgid "The headings in brackets are group names, which are used in classifying hosts and deciding what hosts you are controlling at what times and for what purpose. Group names should follow the same guidelines as :ref:`valid_variable_names`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:41
msgid "Here's that same basic inventory file in YAML format:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:62
msgid "Default groups"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:64
msgid "There are two default groups: ``all`` and ``ungrouped``. The ``all`` group contains every host. The ``ungrouped`` group contains all hosts that don't have another group aside from ``all``. Every host will always belong to at least 2 groups (``all`` and ``ungrouped`` or ``all`` and some other group). Though ``all`` and ``ungrouped`` are always present, they can be implicit and not appear in group listings like ``group_names``."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:71
msgid "Hosts in multiple groups"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:73
msgid "You can (and probably will) put each host in more than one group. For example a production webserver in a datacenter in Atlanta might be included in groups called [prod] and [atlanta] and [webservers]. You can create groups that track:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:75
msgid "What - An application, stack or microservice (for example, database servers, web servers, and so on)."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:76
msgid "Where - A datacenter or region, to talk to local DNS, storage, and so on (for example, east, west)."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:77
msgid "When - The development stage, to avoid testing on production resources (for example, prod, test)."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:79
msgid "Extending the previous YAML inventory to include what, when, and where would look like:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:115
msgid "You can see that ``one.example.com`` exists in the ``dbservers``, ``east``, and ``prod`` groups."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:117
msgid "You can also use nested groups to simplify ``prod`` and ``test`` in this inventory, for the same result:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:150
msgid "You can find more examples on how to organize your inventories and group your hosts in :ref:`inventory_setup_examples`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:153
msgid "Adding ranges of hosts"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:155
msgid "If you have a lot of hosts with a similar pattern, you can add them as a range rather than listing each hostname separately:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:157
#: ../../rst/user_guide/intro_inventory.rst:175
#: ../../rst/user_guide/intro_inventory.rst:256
#: ../../rst/user_guide/intro_inventory.rst:326
msgid "In INI:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:164
#: ../../rst/user_guide/intro_inventory.rst:182
#: ../../rst/user_guide/intro_inventory.rst:218
#: ../../rst/user_guide/intro_inventory.rst:262
#: ../../rst/user_guide/intro_inventory.rst:304
#: ../../rst/user_guide/intro_inventory.rst:354
msgid "In YAML:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:173
msgid "You can specify a stride (increments between sequence numbers) when defining a numeric range of hosts:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:191
msgid "For numeric patterns, leading zeros can be included or removed, as desired. Ranges are inclusive. You can also define alphabetic ranges:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:201
msgid "Adding variables to inventory"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:203
msgid "You can store variable values that relate to a specific host or group in inventory. To start with, you may add variables directly to the hosts and groups in your main inventory file. As you add more and more managed nodes to your Ansible inventory, however, you will likely want to store variables in separate host and group variable files. See :ref:`define_variables_in_inventory` for details."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:208
msgid "Assigning a variable to one machine: host variables"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:210
msgid "You can easily assign a variable to a single host, then use it later in playbooks. In INI:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:231
msgid "Unique values like non-standard SSH ports work well as host variables. You can add them to your Ansible inventory by adding the port number after the hostname with a colon:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:237
msgid "Connection variables also work well as host variables:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:247
msgid "If you list non-standard SSH ports in your SSH config file, the ``openssh`` connection will find and use them, but the ``paramiko`` connection will not."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:252
msgid "Inventory aliases"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:254
msgid "You can also define aliases in your inventory:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:272
msgid "In the above example, running Ansible against the host alias \"jumper\" will connect to 192.0.2.50 on port 5555. See :ref:`behavioral inventory parameters <behavioral_parameters>` to further customize the connection to hosts."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:275
msgid "Values passed in the INI format using the ``key=value`` syntax are interpreted differently depending on where they are declared:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:277
msgid "When declared inline with the host, INI values are interpreted as Python literal structures           (strings, numbers, tuples, lists, dicts, booleans, None). Host lines accept multiple ``key=value`` parameters per line. Therefore they need a way to indicate that a space is part of a value rather than a separator."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:279
msgid "When declared in a ``:vars`` section, INI values are interpreted as strings. For example ``var=FALSE`` would create a string equal to 'FALSE'. Unlike host lines, ``:vars`` sections accept only a single entry per line, so everything after the ``=`` must be the value for the entry."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:281
msgid "If a variable value set in an INI inventory must be a certain type (for example, a string or a boolean value), always specify the type with a filter in your task. Do not rely on types set in INI inventories when consuming variables."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:283
msgid "Consider using YAML format for inventory sources to avoid confusion on the actual type of a variable. The YAML inventory plugin processes variable values consistently and correctly."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:285
msgid "Generally speaking, this is not the best way to define variables that describe your system policy. Setting variables in the main inventory file is only a shorthand. See :ref:`splitting_out_vars` for guidelines on storing variable values in individual files in the 'host_vars' directory."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:290
msgid "Assigning a variable to many machines: group variables"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:292
msgid "If all hosts in a group share a variable value, you can apply that variable to an entire group at once. In INI:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:316
msgid "Group variables are a convenient way to apply variables to multiple hosts at once. Before executing, however, Ansible always flattens variables, including inventory variables, to the host level. If a host is a member of multiple groups, Ansible reads variable values from all of those groups. If you assign different values to the same variable in different groups, Ansible chooses which value to use based on internal :ref:`rules for merging <how_we_merge>`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:321
msgid "Inheriting variable values: group variables for groups of groups"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:323
msgid "You can make groups of groups using the ``:children`` suffix in INI or the ``children:`` entry in YAML. You can apply variables to these groups of groups using ``:vars`` or ``vars:``:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:381
msgid "If you need to store lists or hash data, or prefer to keep host and group specific variables separate from the inventory file, see :ref:`splitting_out_vars`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:383
msgid "Child groups have a couple of properties to note:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:385
msgid "Any host that is member of a child group is automatically a member of the parent group."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:386
msgid "A child group's variables will have higher precedence (override) a parent group's variables."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:387
msgid "Groups can have multiple parents and children, but not circular relationships."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:388
msgid "Hosts can also be in multiple groups, but there will only be **one** instance of a host, merging the data from the multiple groups."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:393
msgid "Organizing host and group variables"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:395
msgid "Although you can store variables in the main inventory file, storing separate host and group variables files may help you organize your variable values more easily. Host and group variable files must use YAML syntax. Valid file extensions include '.yml', '.yaml', '.json', or no file extension. See :ref:`yaml_syntax` if you are new to YAML."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:398
msgid "Ansible loads host and group variable files by searching paths relative to the inventory file or the playbook file. If your inventory file at ``/etc/ansible/hosts`` contains a host named 'foosball' that belongs to two groups, 'raleigh' and 'webservers', that host will use variables in YAML files at the following locations:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:406
msgid "For example, if you group hosts in your inventory by datacenter, and each datacenter uses its own NTP server and database server, you can create a file called ``/etc/ansible/group_vars/raleigh`` to store the variables for the ``raleigh`` group:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:414
msgid "You can also create *directories* named after your groups or hosts. Ansible will read all the files in these directories in lexicographical order. An example with the 'raleigh' group:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:421
msgid "All hosts in the 'raleigh' group will have the variables defined in these files available to them. This can be very useful to keep your variables organized when a single file gets too big, or when you want to use :ref:`Ansible Vault<playbooks_vault>` on some group variables."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:425
msgid "You can also add ``group_vars/`` and ``host_vars/`` directories to your playbook directory. The ``ansible-playbook`` command looks for these directories in the current working directory by default. Other Ansible commands (for example, ``ansible``, ``ansible-console``, and so on) will only look for ``group_vars/`` and ``host_vars/`` in the inventory directory. If you want other commands to load group and host variables from a playbook directory, you must provide the ``--playbook-dir`` option on the command line. If you load inventory files from both the playbook directory and the inventory directory, variables in the playbook directory will override variables set in the inventory directory."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:428
msgid "Keeping your inventory file and variables in a git repo (or other version control) is an excellent way to track changes to your inventory and host variables."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:434
msgid "How variables are merged"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:436
msgid "By default variables are merged/flattened to the specific host before a play is run. This keeps Ansible focused on the Host and Task, so groups don't really survive outside of inventory and host matching. By default, Ansible overwrites variables including the ones defined for a group and/or host (see :ref:`DEFAULT_HASH_BEHAVIOUR<DEFAULT_HASH_BEHAVIOUR>`). The order/precedence is (from lowest to highest):"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:438
msgid "all group (because it is the 'parent' of all other groups)"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:439
msgid "parent group"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:440
msgid "child group"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:441
msgid "host"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:443
msgid "By default Ansible merges groups at the same parent/child level in ASCII order, and the last group loaded overwrites the previous groups. For example, an a_group will be merged with b_group and b_group vars that match will overwrite the ones in a_group."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:445
msgid "You can change this behavior by setting the group variable ``ansible_group_priority`` to change the merge order for groups of the same level (after the parent/child order is resolved). The larger the number, the later it will be merged, giving it higher priority. This variable defaults to ``1`` if not set. For example:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:457
msgid "In this example, if both groups have the same priority, the result would normally have been ``testvar == b``, but since we are giving the ``a_group`` a higher priority the result will be ``testvar == a``."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:459
msgid "``ansible_group_priority`` can only be set in the inventory source and not in group_vars/, as the variable is used in the loading of group_vars."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:464
msgid "Using multiple inventory sources"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:466
msgid "You can target multiple inventory sources (directories, dynamic inventory scripts or files supported by inventory plugins) at the same time by giving multiple inventory parameters from the command line or by configuring :envvar:`ANSIBLE_INVENTORY`. This can be useful when you want to target normally separate environments, like staging and production, at the same time for a specific action."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:471
msgid "Target two sources from the command line like this:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:477
msgid "Keep in mind that if there are variable conflicts in the inventories, they are resolved according to the rules described in :ref:`how_we_merge` and :ref:`ansible_variable_precedence`. The merging order is controlled by the order of the inventory source parameters. If ``[all:vars]`` in staging inventory defines ``myvar = 1``, but production inventory defines ``myvar = 2``, the playbook will be run with ``myvar = 2``. The result would be reversed if the playbook was run with ``-i production -i staging``."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:484
msgid "**Aggregating inventory sources with a directory**"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:486
msgid "You can also create an inventory by combining multiple inventory sources and source types under a directory. This can be useful for combining static and dynamic hosts and managing them as one inventory. The following inventory combines an inventory plugin source, a dynamic inventory script, and a file with static hosts:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:500
msgid "You can target this inventory directory simply like this:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:506
msgid "It can be useful to control the merging order of the inventory sources if there's variable conflicts or group of groups dependencies to the other inventory sources. The inventories are merged in ASCII order according to the filenames so the result can be controlled by adding prefixes to the files:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:520
msgid "If ``01-openstack.yml`` defines ``myvar = 1`` for the group ``all``, ``02-dynamic-inventory.py`` defines ``myvar = 2``, and ``03-static-inventory`` defines ``myvar = 3``, the playbook will be run with ``myvar = 3``."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:523
msgid "For more details on inventory plugins and dynamic inventory scripts see :ref:`inventory_plugins` and :ref:`intro_dynamic_inventory`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:528
msgid "Connecting to hosts: behavioral inventory parameters"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:530
msgid "As described above, setting the following variables control how Ansible interacts with remote hosts."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:532
msgid "Host connection:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:537
msgid "ansible_connection"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:537
msgid "Connection type to the host. This can be the name of any of ansible's connection plugins. SSH protocol types are ``smart``, ``ssh`` or ``paramiko``.  The default is smart. Non-SSH based types are described in the next section."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:539
msgid "General for all connections:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:541
#: ../../rst/user_guide/intro_inventory.rst:644
msgid "ansible_host"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:542
msgid "The name of the host to connect to, if different from the alias you wish to give to it."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:543
msgid "ansible_port"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:544
msgid "The connection port number, if not the default (22 for ssh)"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:545
#: ../../rst/user_guide/intro_inventory.rst:646
msgid "ansible_user"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:546
msgid "The user name to use when connecting to the host"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:549
msgid "ansible_password"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:548
msgid "The password to use to authenticate to the host (never store this variable in plain text; always use a vault. See :ref:`tip_for_variables_and_vaults`)"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:551
msgid "Specific to the SSH connection:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:553
msgid "ansible_ssh_private_key_file"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:554
msgid "Private key file used by ssh.  Useful if using multiple keys and you don't want to use SSH agent."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:557
msgid "ansible_ssh_common_args"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:556
msgid "This setting is always appended to the default command line for :command:`sftp`, :command:`scp`, and :command:`ssh`. Useful to configure a ``ProxyCommand`` for a certain host (or group)."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:559
msgid "ansible_sftp_extra_args"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:560
msgid "This setting is always appended to the default :command:`sftp` command line."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:561
msgid "ansible_scp_extra_args"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:562
msgid "This setting is always appended to the default :command:`scp` command line."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:563
msgid "ansible_ssh_extra_args"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:564
msgid "This setting is always appended to the default :command:`ssh` command line."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:565
msgid "ansible_ssh_pipelining"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:566
msgid "Determines whether or not to use SSH pipelining. This can override the ``pipelining`` setting in :file:`ansible.cfg`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:569
msgid "ansible_ssh_executable (added in version 2.2)"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:568
msgid "This setting overrides the default behavior to use the system :command:`ssh`. This can override the ``ssh_executable`` setting in :file:`ansible.cfg`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:571
msgid "Privilege escalation (see :ref:`Ansible Privilege Escalation<become>` for further details):"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:574
msgid "Equivalent to ``ansible_sudo`` or ``ansible_su``, allows to force privilege escalation"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:576
msgid "Allows to set privilege escalation method"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:578
msgid "Equivalent to ``ansible_sudo_user`` or ``ansible_su_user``, allows to set the user you become through privilege escalation"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:580
msgid "Equivalent to ``ansible_sudo_password`` or ``ansible_su_password``, allows you to set the privilege escalation password (never store this variable in plain text; always use a vault. See :ref:`tip_for_variables_and_vaults`)"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:581
msgid "ansible_become_exe"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:582
msgid "Equivalent to ``ansible_sudo_exe`` or ``ansible_su_exe``, allows you to set the executable for the escalation method selected"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:584
msgid "ansible_become_flags"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:584
msgid "Equivalent to ``ansible_sudo_flags`` or ``ansible_su_flags``, allows you to set the flags passed to the selected escalation method. This can be also set globally in :file:`ansible.cfg` in the ``sudo_flags`` option"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:586
msgid "Remote host environment parameters:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:594
msgid "ansible_shell_type"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:591
msgid "The shell type of the target system. You should not use this setting unless you have set the :ref:`ansible_shell_executable<ansible_shell_executable>` to a non-Bourne (sh) compatible shell.  By default commands are formatted using ``sh``-style syntax.  Setting this to ``csh`` or ``fish`` will cause commands executed on target systems to follow those shell's syntax instead."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:603
msgid "ansible_python_interpreter"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:599
msgid "The target host python path. This is useful for systems with more than one Python or not located at :command:`/usr/bin/python` such as \\*BSD, or where :command:`/usr/bin/python` is not a 2.X series Python.  We do not use the :command:`/usr/bin/env` mechanism as that requires the remote user's path to be set right and also assumes the :program:`python` executable is named python, where the executable might be named something like :program:`python2.6`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:607
msgid "ansible_*_interpreter"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:606
msgid "Works for anything such as ruby or perl and works just like :ref:`ansible_python_interpreter<ansible_python_interpreter>`. This replaces shebang of modules which will run on that host."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:618
msgid "ansible_shell_executable"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:614
msgid "This sets the shell the ansible controller will use on the target machine, overrides ``executable`` in :file:`ansible.cfg` which defaults to :command:`/bin/sh`.  You should really only change it if is not possible to use :command:`/bin/sh` (in other words, if :command:`/bin/sh` is not installed on the target machine or cannot be run from sudo.)."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:620
msgid "Examples from an Ansible-INI host file:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:630
msgid "Non-SSH connection types"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:632
msgid "As stated in the previous section, Ansible executes playbooks over SSH but it is not limited to this connection type. With the host specific parameter ``ansible_connection=<connector>``, the connection type can be changed. The following non-SSH based connectors are available:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:636
msgid "**local**"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:638
msgid "This connector can be used to deploy the playbook to the control machine itself."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:640
msgid "**docker**"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:642
msgid "This connector deploys the playbook directly into Docker containers using the local Docker client. The following parameters are processed by this connector:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:645
msgid "The name of the Docker container to connect to."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:647
msgid "The user name to operate within the container. The user must exist inside the container."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:649
msgid "If set to ``true`` the ``become_user`` will be used to operate within the container."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:651
msgid "ansible_docker_extra_args"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:651
msgid "Could be a string with any additional arguments understood by Docker, which are not command specific. This parameter is mainly used to configure a remote Docker daemon to use."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:653
msgid "Here is an example of how to instantly deploy to created containers:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:677
msgid "For a full list with available plugins and examples, see :ref:`connection_plugin_list`."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:679
msgid "If you're reading the docs from the beginning, this may be the first example you've seen of an Ansible playbook. This is not an inventory file. Playbooks will be covered in great detail later in the docs."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:685
msgid "Inventory setup examples"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:687
msgid "See also :ref:`sample_setup`, which shows inventory along with playbooks and other Ansible artifacts."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:692
msgid "Example: One inventory per environment"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:694
msgid "If you need to manage multiple environments it's sometimes prudent to have only hosts of a single environment defined per inventory. This way, it is harder to, for instance, accidentally change the state of nodes inside the \"test\" environment when you actually wanted to update some \"staging\" servers."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:700
msgid "For the example mentioned above you could have an :file:`inventory_test` file:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:714
msgid "That file only includes hosts that are part of the \"test\" environment. Define the \"staging\" machines in another file called :file:`inventory_staging`:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:729
msgid "To apply a playbook called :file:`site.yml` to all the app servers in the test environment, use the following command::"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:738
msgid "Example: Group by function"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:740
msgid "In the previous section you already saw an example for using groups in order to cluster hosts that have the same function. This allows you, for instance, to define firewall rules inside a playbook or role affecting only database servers:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:758
msgid "Example: Group by location"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:760
msgid "Other tasks might be focused on where a certain host is located. Let's say that ``db01.test.example.com`` and ``app01.test.example.com`` are located in DC1 while ``db02.test.example.com`` is in DC2:"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:773
msgid "In practice, you might even end up mixing all these setups as you might need to, on one day, update all nodes in a specific data center while, on another day, update all the application servers no matter their location."
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:780
msgid ":ref:`inventory_plugins`"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:781
msgid "Pulling inventory from dynamic or static sources"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:782
msgid ":ref:`intro_dynamic_inventory`"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:783
msgid "Pulling inventory from dynamic sources, such as cloud providers"
msgstr ""

#: ../../rst/user_guide/intro_inventory.rst:787
msgid "Learning Ansible's configuration, deployment, and orchestration language."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:4
msgid "Patterns: targeting hosts and groups"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:6
msgid "When you execute Ansible through an ad-hoc command or by running a playbook, you must choose which managed nodes or groups you want to execute against. Patterns let you run commands and playbooks against specific hosts and/or groups in your inventory. An Ansible pattern can refer to a single host, an IP address, an inventory group, a set of groups, or all hosts in your inventory. Patterns are highly flexible - you can exclude or require subsets of hosts, use wildcards or regular expressions, and more. Ansible executes on all inventory hosts included in the pattern."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:12
msgid "Using patterns"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:14
msgid "You use a pattern almost any time you execute an ad-hoc command or a playbook. The pattern is the only element of an :ref:`ad-hoc command<intro_adhoc>` that has no flag. It is usually the second element::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:18
#: ../../rst/user_guide/intro_patterns.rst:29
#: ../../rst/user_guide/playbooks_checkmode.rst:31
#: ../../rst/user_guide/playbooks_filters.rst:663
#: ../../rst/user_guide/playbooks_tests.rst:307
#: ../../rst/user_guide/playbooks_tests.rst:328
msgid "For example::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:22
msgid "In a playbook the pattern is the content of the ``hosts:`` line for each play:"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:34
msgid "Since you often want to run a command or playbook against multiple hosts at once, patterns often refer to inventory groups. Both the ad-hoc command and the playbook above will execute against all machines in the ``webservers`` group."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:39
msgid "Common patterns"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:41
msgid "This table lists common patterns for targeting inventory hosts and groups."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:47
#: ../../rst/user_guide/playbooks_loops.rst:394
msgid "Description"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:47
msgid "Pattern(s)"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:47
msgid "Targets"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:49
msgid "All hosts"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:49
msgid "all (or \\*)"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:51
msgid "One host"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:51
msgid "host1"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:53
msgid "Multiple hosts"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:53
msgid "host1:host2 (or host1,host2)"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:55
msgid "One group"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:55
msgid "webservers"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:57
msgid "Multiple groups"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:57
msgid "webservers:dbservers"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:57
msgid "all hosts in webservers plus all hosts in dbservers"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:59
msgid "Excluding groups"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:59
msgid "webservers:!atlanta"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:59
msgid "all hosts in webservers except those in atlanta"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:61
msgid "Intersection of groups"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:61
msgid "webservers:&staging"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:61
msgid "any hosts in webservers that are also in staging"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:64
msgid "You can use either a comma (``,``) or a colon (``:``) to separate a list of hosts. The comma is preferred when dealing with ranges and IPv6 addresses."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:66
msgid "Once you know the basic patterns, you can combine them. This example::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:70
msgid "targets all machines in the groups 'webservers' and 'dbservers' that are also in the group 'staging', except any machines in the group 'phoenix'."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:73
msgid "You can use wildcard patterns with FQDNs or IP addresses, as long as the hosts are named in your inventory by FQDN or IP address::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:79
msgid "You can mix wildcard patterns and groups at the same time::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:84
msgid "Limitations of patterns"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:86
msgid "Patterns depend on inventory. If a host or group is not listed in your inventory, you cannot use a pattern to target it. If your pattern includes an IP address or hostname that does not appear in your inventory, you will see an error like this:"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:93
msgid "Your pattern must match your inventory syntax. If you define a host as an :ref:`alias<inventory_aliases>`:"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:103
msgid "you must use the alias in your pattern. In the example above, you must use ``host1`` in your pattern. If you use the IP address, you will once again get the error::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:108
msgid "Advanced pattern options"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:110
msgid "The common patterns described above will meet most of your needs, but Ansible offers several other ways to define the hosts and groups you want to target."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:113
msgid "Using variables in patterns"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:115
msgid "You can use variables to enable passing group specifiers via the ``-e`` argument to ansible-playbook::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:120
msgid "Using group position in patterns"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:122
msgid "You can define a host or subset of hosts by its position in a group. For example, given the following group::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:129
msgid "you can use subscripts to select individual hosts or ranges within the webservers group::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:139
msgid "Using regexes in patterns"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:141
msgid "You can specify a pattern as a regular expression by starting the pattern with ``~``::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:146
msgid "Patterns and ansible-playbook flags"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:148
msgid "You can change the behavior of the patterns defined in playbooks using command-line options. For example, you can run a playbook that defines ``hosts: all`` on a single host by specifying ``-i 127.0.0.2,`` (note the trailing comma). This works even if the host you target is not defined in your inventory. You can also limit the hosts you target on a particular run with the ``--limit`` flag::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:152
msgid "Finally, you can use ``--limit`` to read the list of hosts from a file by prefixing the file name with ``@``::"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:156
msgid "If :ref:`RETRY_FILES_ENABLED` is set to ``True``, a ``.retry`` file will be created after the ``ansible-playbook`` run containing a list of failed hosts from all plays. This file is overwritten each time ``ansible-playbook`` finishes running."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:158
msgid "ansible-playbook site.yml --limit @site.retry"
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:160
msgid "To apply your knowledge of patterns with Ansible commands and playbooks, read :ref:`intro_adhoc` and :ref:`playbooks_intro`."
msgstr ""

#: ../../rst/user_guide/intro_patterns.rst:167
msgid "Learning the Ansible configuration management language"
msgstr ""

#: ../../rst/user_guide/intro_windows.rst:2
msgid "Windows Support"
msgstr ""

#: ../../rst/user_guide/intro_windows.rst:4
msgid "This page has been split up and moved to the new section :ref:`windows`."
msgstr ""

#: ../../rst/user_guide/modules.rst:4
msgid "Working With Modules"
msgstr ""

#: ../../rst/user_guide/modules.rst:14
msgid "Ansible ships with a number of modules (called the 'module library') that can be executed directly on remote hosts or through :ref:`Playbooks <working_with_playbooks>`."
msgstr ""

#: ../../rst/user_guide/modules.rst:17
msgid "Users can also write their own modules. These modules can control system resources, like services, packages, or files (anything really), or handle executing system commands."
msgstr ""

#: ../../rst/user_guide/modules.rst:24
#: ../../rst/user_guide/modules_intro.rst:42
#: ../../rst/user_guide/modules_support.rst:64
msgid "Examples of using modules in /usr/bin/ansible"
msgstr ""

#: ../../rst/user_guide/modules.rst:25
#: ../../rst/user_guide/playbooks_async.rst:156
#: ../../rst/user_guide/playbooks_blocks.rst:182
#: ../../rst/user_guide/playbooks_debugger.rst:324
#: ../../rst/user_guide/playbooks_delegation.rst:127
#: ../../rst/user_guide/playbooks_environment.rst:136
#: ../../rst/user_guide/playbooks_error_handling.rst:234
#: ../../rst/user_guide/playbooks_prompts.rst:107
#: ../../rst/user_guide/playbooks_startnstep.rst:37
#: ../../rst/user_guide/playbooks_tags.rst:422
#: ../../rst/user_guide/playbooks_templating.rst:42
#: ../../rst/user_guide/playbooks_tests.rst:388
#: ../../rst/user_guide/windows_dsc.rst:496
#: ../../rst/user_guide/windows_usage.rst:504
#: ../../rst/user_guide/windows_winrm.rst:904
msgid ":ref:`playbooks_intro`"
msgstr ""

#: ../../rst/user_guide/modules.rst:26
msgid "Introduction to using modules with /usr/bin/ansible-playbook"
msgstr ""

#: ../../rst/user_guide/modules.rst:27
msgid ":ref:`developing_modules_general`"
msgstr ""

#: ../../rst/user_guide/modules.rst:28
#: ../../rst/user_guide/modules_intro.rst:46
msgid "How to write your own modules"
msgstr ""

#: ../../rst/user_guide/modules.rst:29
#: ../../rst/user_guide/modules_intro.rst:47
msgid ":ref:`developing_api`"
msgstr ""

#: ../../rst/user_guide/modules.rst:30
#: ../../rst/user_guide/modules_intro.rst:48
msgid "Examples of using modules with the Python API"
msgstr ""

#: ../../rst/user_guide/modules.rst:31
msgid ":ref:`interpreter_discovery`"
msgstr ""

#: ../../rst/user_guide/modules.rst:32
msgid "Configuring the right Python interpreter on target hosts"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:4
msgid "Introduction to modules"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:6
msgid "Modules (also referred to as \"task plugins\" or \"library plugins\") are discrete units of code that can be used from the command line or in a playbook task. Ansible executes each module, usually on the remote managed node, and collects return values. In Ansible 2.10 and later, most modules are hosted in collections."
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:8
msgid "You can execute modules from the command line::"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:14
msgid "Each module supports taking arguments.  Nearly all modules take ``key=value`` arguments, space delimited.  Some modules take no arguments, and the command/shell modules simply take the string of the command you want to run."
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:16
msgid "From playbooks, Ansible modules are executed in a very similar way::"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:21
msgid "Another way to pass arguments to a module is using YAML syntax, also called 'complex args' ::"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:28
msgid "All modules return JSON format data. This means modules can be written in any programming language. Modules should be idempotent, and should avoid making any changes if they detect that the current state matches the desired final state. When used in an Ansible playbook, modules can trigger 'change events' in the form of notifying :ref:`handlers <handlers>` to run additional tasks."
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:30
msgid "You can access the documentation for each module from the command line with the ansible-doc tool::"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:34
msgid "For a list of all available modules, see the :ref:`Collection docs <list_of_collections>`, or run the following at a command prompt::"
msgstr ""

#: ../../rst/user_guide/modules_intro.rst:44
#: ../../rst/user_guide/modules_support.rst:66
msgid "Examples of using modules with /usr/bin/ansible-playbook"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:5
msgid "Module Maintenance & Support"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:7
msgid "If you are using a module and you discover a bug, you may want to know where to report that bug, who is responsible for fixing it, and how you can track changes to the module. If you are a Red Hat subscriber, you may want to know whether you can get support for the issue you are facing."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:9
msgid "Starting in Ansible 2.10, most modules live in collections. The distribution method for each collection reflects the maintenance and support for the modules in that collection."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:15
msgid "Maintenance"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:21
msgid "Collection"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:21
msgid "Code location"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:21
msgid "Maintained by"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:23
msgid "ansible.builtin"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:23
msgid "`ansible/ansible repo`_ on GitHub"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:23
msgid "core team"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:25
msgid "distributed on Galaxy"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:25
#: ../../rst/user_guide/modules_support.rst:27
msgid "various; follow ``repo`` link"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:25
msgid "community or partners"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:27
msgid "distributed on Automation Hub"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:27
msgid "content team or partners"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:33
msgid "Issue Reporting"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:35
msgid "If you find a bug that affects a plugin in the main Ansible repo, also known as ``ansible-base``:"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:37
msgid "Confirm that you are running the latest stable version of Ansible or the devel branch."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:38
msgid "Look at the `issue tracker in the Ansible repo <https://github.com/ansible/ansible/issues>`_ to see if an issue has already been filed."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:39
#: ../../rst/user_guide/modules_support.rst:46
msgid "Create an issue if one does not already exist. Include as much detail as you can about the behavior you discovered."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:41
msgid "If you find a bug that affects a plugin in a Galaxy collection:"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:43
msgid "Find the collection on Galaxy."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:44
msgid "Find the issue tracker for the collection."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:45
msgid "Look there to see if an issue has already been filed."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:48
msgid "Some partner collections may be hosted in private repositories."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:50
msgid "If you are not sure whether the behavior you see is a bug, if you have questions, if you want to discuss development-oriented topics, or if you just want to get in touch, use one of our Google groups or IRC channels to  :ref:`communicate with Ansiblers <communication>`."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:52
msgid "If you find a bug that affects a module in an Automation Hub collection:"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:54
msgid "If the collection offers an Issue Tracker link on Automation Hub, click there and open an issue on the collection repository. If it does not, follow the standard process for reporting issues on the `Red Hat Customer Portal <https://access.redhat.com/>`_. You must have a subscription to the Red Hat Ansible Automation Platform to create an issue on the portal."
msgstr ""

#: ../../rst/user_guide/modules_support.rst:57
msgid "Support"
msgstr ""

#: ../../rst/user_guide/modules_support.rst:59
msgid "All plugins that remain in ``ansible-base`` and all collections hosted in Automation Hub are supported by Red Hat. No other plugins or collections are supported by Red Hat. If you have a subscription to the Red Hat Ansible Automation Platform, you can find more information and resources on the `Red Hat Customer Portal. <https://access.redhat.com/>`_"
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:5
msgid "Search paths in Ansible"
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:7
msgid "You can control the paths Ansible searches to find resources on your control node (including configuration, modules, roles, ssh keys, and more) as well as resources on the remote nodes you are managing. Use absolute paths to tell Ansible where to find resources whenever you can. However, absolute paths are not always practical. This page covers how Ansible interprets relative search paths, along with ways to troubleshoot when Ansible cannot find the resource you need."
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:13
msgid "Config paths"
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:15
msgid "By default these should be relative to the config file, some are specifically relative to the current working directory or the playbook and should have this noted in their description. Things like ssh keys are left to use the current working directory because it mirrors how the underlying tools would use it."
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:19
msgid "Task paths"
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:21
msgid "Task paths include two different scopes: task evaluation and task execution. For task evaluation, all paths are local, like in lookups. For task execution, which usually happens on the remote nodes, local paths do not usually apply. However, if a task uses an action plugin, it uses a local path. The template and copy modules are examples of modules that use action plugins, and therefore use local paths."
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:24
msgid "The magic of 'local' paths"
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:26
msgid "Lookups and action plugins both use a special 'search magic' to find things, taking the current play into account, it uses from most specific to most general playbook dir in which a task is contained (this includes roles and includes)."
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:28
msgid "Using this magic, relative paths get attempted first with a 'files|templates|vars' appended (if not already present), depending on action being taken, 'files' is the default. (in other words, include_vars will use vars/).  The paths will be searched from most specific to most general (in other words, role before play). dependent roles WILL be traversed (in other words, task is in role2, role2 is a dependency of role1, role2 will be looked at first, then role1, then play). i.e ::"
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:36
msgid "By default, Ansible does not search the current working directory unless it happens to coincide with one of the paths above. If you `include` a task file from a role, it  will NOT trigger role behavior, this only happens when running as a role, `include_role` will work. A new variable `ansible_search_path` var will have the search path used, in order (but without the appended subdirs). Using 5 \"v\"s (`-vvvvv`) should show the detail of the search as it happens."
msgstr ""

#: ../../rst/user_guide/playbook_pathing.rst:38
msgid "As for includes, they try the path of the included file first and fall back to the play/role that includes them."
msgstr ""

#: ../../rst/user_guide/playbooks.rst:4
msgid "Working with playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks.rst:6
msgid "Playbooks record and execute Ansible's configuration, deployment, and orchestration functions. They can describe a policy you want your remote systems to enforce, or a set of steps in a general IT process."
msgstr ""

#: ../../rst/user_guide/playbooks.rst:8
msgid "If Ansible modules are the tools in your workshop, playbooks are your instruction manuals, and your inventory of hosts are your raw material."
msgstr ""

#: ../../rst/user_guide/playbooks.rst:10
msgid "At a basic level, playbooks can be used to manage configurations of and deployments to remote machines.  At a more advanced level, they can sequence multi-tier rollouts involving rolling updates, and can delegate actions to other hosts, interacting with monitoring servers and load balancers along the way."
msgstr ""

#: ../../rst/user_guide/playbooks.rst:12
msgid "Playbooks are designed to be human-readable and are developed in a basic text language.  There are multiple ways to organize playbooks and the files they include, and we'll offer up some suggestions on that and making the most out of Ansible."
msgstr ""

#: ../../rst/user_guide/playbooks.rst:14
msgid "You should look at `Example Playbooks <https://github.com/ansible/ansible-examples>`_ while reading along with the playbook documentation.  These illustrate best practices as well as how to put many of the various concepts together."
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:5
msgid "Advanced Syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:7
msgid "The advanced YAML syntax examples on this page give you more control over the data placed in YAML files used by Ansible. You can find additional information about Python-specific YAML in the official `PyYAML Documentation <https://pyyaml.org/wiki/PyYAMLDocumentation#YAMLtagsandPythontypes>`_."
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:15
msgid "Unsafe or raw strings"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:17
#, python-format
msgid "When handling values returned by lookup plugins, Ansible uses a data type called ``unsafe`` to block templating. Marking data as unsafe prevents malicious users from abusing Jinja2 templates to execute arbitrary code on target machines. The Ansible implementation ensures that unsafe values are never templated. It is more comprehensive than escaping Jinja2 with ``{% raw %} ... {% endraw %}`` tags."
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:19
msgid "You can use the same ``unsafe`` data type in variables you define, to prevent templating errors and information disclosure. You can mark values supplied by :ref:`vars_prompts<unsafe_prompts>` as unsafe. You can also use ``unsafe`` in playbooks. The most common use cases include passwords that allow special characters like ``{`` or ``%``, and JSON arguments that look like templates but should not be templated. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:26
msgid "In a playbook::"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:35
msgid "For complex variables such as hashes or arrays, use ``!unsafe`` on the individual elements::"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:48
msgid "YAML anchors and aliases: sharing variable values"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:50
msgid "`YAML anchors and aliases <https://yaml.org/spec/1.2/spec.html#id2765878>`_ help you define, maintain, and use shared variable values in a flexible way. You define an anchor with ``&``, then refer to it using an alias, denoted with ``*``. Here's an example that sets three values with an anchor, uses two of those values with an alias, and overrides the third value::"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:67
msgid "Here, ``app1`` and ``app2`` share the values for ``opts`` and ``port`` using the anchor ``&jvm_opts`` and the alias ``*jvm_opts``. The value for ``path`` is merged by ``<<`` or `merge operator <https://yaml.org/type/merge.html>`_."
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:70
msgid "Anchors and aliases also let you share complex sets of variable values, including nested variables. If you have one variable value that includes another variable value, you can define them separately::"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:76
msgid "This is inefficient and, at scale, means more maintenance. To incorporate the version value in the name, you can use an anchor in ``app_version`` and an alias in ``custom_name``::"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:85
msgid "Now, you can re-use the value of ``app_version`` within the value of  ``custom_name`` and use the output in a template::"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:101
msgid "You've anchored the value of ``version`` with the ``&my_version`` anchor, and re-used it with the ``*my_version`` alias. Anchors and aliases let you access nested values inside dictionaries."
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:106
#: ../../rst/user_guide/playbooks_conditionals.rst:504
#: ../../rst/user_guide/playbooks_error_handling.rst:241
#: ../../rst/user_guide/playbooks_filters.rst:1724
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:733
#: ../../rst/user_guide/playbooks_lookups.rst:31
#: ../../rst/user_guide/playbooks_loops.rst:441
#: ../../rst/user_guide/playbooks_prompts.rst:112
#: ../../rst/user_guide/playbooks_tests.rst:393
msgid "All about variables"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:107
msgid ":doc:`complex_data_manipulation`"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:108
msgid "Doing complex data manipulation in Ansible"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:109
#: ../../rst/user_guide/windows_dsc.rst:502
#: ../../rst/user_guide/windows_faq.rst:233
#: ../../rst/user_guide/windows_setup.rst:570
#: ../../rst/user_guide/windows_usage.rst:510
#: ../../rst/user_guide/windows_winrm.rst:910
msgid "`User Mailing List <https://groups.google.com/group/ansible-project>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_advanced_syntax.rst:110
#: ../../rst/user_guide/playbooks_async.rst:159
#: ../../rst/user_guide/playbooks_blocks.rst:187
#: ../../rst/user_guide/playbooks_conditionals.rst:506
#: ../../rst/user_guide/playbooks_debugger.rst:327
#: ../../rst/user_guide/playbooks_delegation.rst:134
#: ../../rst/user_guide/playbooks_environment.rst:139
#: ../../rst/user_guide/playbooks_error_handling.rst:243
#: ../../rst/user_guide/playbooks_filters.rst:1732
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:741
#: ../../rst/user_guide/playbooks_lookups.rst:35
#: ../../rst/user_guide/playbooks_loops.rst:443
#: ../../rst/user_guide/playbooks_prompts.rst:114
#: ../../rst/user_guide/playbooks_strategies.rst:220
#: ../../rst/user_guide/playbooks_tags.rst:427
#: ../../rst/user_guide/playbooks_templating.rst:53
#: ../../rst/user_guide/playbooks_tests.rst:401
#: ../../rst/user_guide/playbooks_variables.rst:464
#: ../../rst/user_guide/windows_dsc.rst:503
#: ../../rst/user_guide/windows_faq.rst:234
#: ../../rst/user_guide/windows_setup.rst:571
#: ../../rst/user_guide/windows_usage.rst:511
#: ../../rst/user_guide/windows_winrm.rst:911
msgid "Have a question?  Stop by the google group!"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:4
msgid "Asynchronous actions and polling"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:6
msgid "By default Ansible runs tasks synchronously, holding the connection to the remote node open until the action is completed. This means within a playbook, each task blocks the next task by default, meaning subsequent tasks will not run until the current task completes. This behavior can create challenges. For example, a task may take longer to complete than the SSH session allows for, causing a timeout. Or you may want a long-running process to execute in the background while you perform other tasks concurrently. Asynchronous mode lets you control how long-running tasks execute."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:12
msgid "Asynchronous ad-hoc tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:14
msgid "You can execute long-running operations in the background with :ref:`ad-hoc tasks <intro_adhoc>`. For example, to execute ``long_running_operation`` asynchronously in the background, with a timeout (``-B``) of 3600 seconds, and without polling (``-P``)::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:18
msgid "To check on the job status later, use the ``async_status`` module, passing it the job ID that was returned when you ran the original job in the background::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:22
msgid "Ansible can also check on the status of your long-running job automatically with polling. In most cases, Ansible will keep the connection to your remote node open between polls. To run for 30 minutes and poll for status every 60 seconds::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:26
msgid "Poll mode is smart so all jobs will be started before polling begins on any machine. Be sure to use a high enough ``--forks`` value if you want to get all of your jobs started very quickly. After the time limit (in seconds) runs out (``-B``), the process on the remote nodes will be terminated."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:28
msgid "Asynchronous mode is best suited to long-running shell commands or software upgrades. Running the copy module asynchronously, for example, does not do a background file transfer."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:31
msgid "Asynchronous playbook tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:33
msgid ":ref:`Playbooks <working_with_playbooks>` also support asynchronous mode and polling, with a simplified syntax. You can use asynchronous mode in playbooks to avoid connection timeouts or to avoid blocking subsequent tasks. The behavior of asynchronous mode in a playbook depends on the value of `poll`."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:36
msgid "Avoid connection timeouts: poll > 0"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:38
msgid "If you want to set a longer timeout limit for a certain task in your playbook, use ``async`` with ``poll`` set to a positive value. Ansible will still block the next task in your playbook, waiting until the async task either completes, fails or times out. However, the task will only time out if it exceeds the timeout limit you set with the ``async`` parameter."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:40
msgid "To avoid timeouts on a task, specify its maximum runtime and how frequently you would like to poll for status::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:55
msgid "The default poll value is set by the :ref:`DEFAULT_POLL_INTERVAL` setting. There is no default for the async time limit.  If you leave off the 'async' keyword, the task runs synchronously, which is Ansible's default."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:61
msgid "As of Ansible 2.3, async does not support check mode and will fail the task when run in check mode. See :ref:`check_mode_dry` on how to skip a task in check mode."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:66
msgid "Run tasks concurrently: poll = 0"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:68
msgid "If you want to run multiple tasks in a playbook concurrently, use ``async`` with ``poll`` set to 0. When you set ``poll: 0``, Ansible starts the task and immediately moves on to the next task without waiting for a result. Each async task runs until it either completes, fails or times out (runs longer than its ``async`` value). The playbook run ends without checking back on async tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:70
msgid "To run a playbook task asynchronously::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:85
msgid "Do not specify a poll value of 0 with operations that require exclusive locks (such as yum transactions) if you expect to run other commands later in the playbook against those same resources."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:88
msgid "Using a higher value for ``--forks`` will result in kicking off asynchronous tasks even faster. This also increases the efficiency of polling."
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:90
msgid "If you need a synchronization point with an async task, you can register it to obtain its job ID and use the :ref:`async_status <async_status_module>` module to observe it in a later task. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:109
msgid "If the value of ``async:`` is not high enough, this will cause the \"check on it later\" task to fail because the temporary status file that the ``async_status:`` is looking for will not have been written or no longer exist"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:113
msgid "To run multiple asynchronous tasks while limiting the number of tasks running concurrently::"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:154
#: ../../rst/user_guide/playbooks_delegation.rst:129
msgid ":ref:`playbooks_strategies`"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:155
msgid "Options for controlling playbook execution"
msgstr ""

#: ../../rst/user_guide/playbooks_async.rst:158
#: ../../rst/user_guide/playbooks_blocks.rst:186
#: ../../rst/user_guide/playbooks_conditionals.rst:505
#: ../../rst/user_guide/playbooks_debugger.rst:326
#: ../../rst/user_guide/playbooks_delegation.rst:133
#: ../../rst/user_guide/playbooks_environment.rst:138
#: ../../rst/user_guide/playbooks_error_handling.rst:242
#: ../../rst/user_guide/playbooks_filters.rst:1731
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:740
#: ../../rst/user_guide/playbooks_lookups.rst:34
#: ../../rst/user_guide/playbooks_loops.rst:442
#: ../../rst/user_guide/playbooks_prompts.rst:113
#: ../../rst/user_guide/playbooks_strategies.rst:219
#: ../../rst/user_guide/playbooks_tags.rst:426
#: ../../rst/user_guide/playbooks_templating.rst:52
#: ../../rst/user_guide/playbooks_tests.rst:400
#: ../../rst/user_guide/playbooks_variables.rst:463
msgid "`User Mailing List <https://groups.google.com/group/ansible-devel>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:6
msgid "Tips and tricks"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:8
msgid "These tips and tricks have helped us optimize our Ansible usage, and we offer them here as suggestions. We hope they will help you organize content, write playbooks, maintain inventory, and execute Ansible. Ultimately, though, you should use Ansible in the way that makes most sense for your organization and your goals."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:14
msgid "General tips"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:16
msgid "These concepts apply to all Ansible activities and artifacts."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:19
msgid "Keep it simple"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:21
msgid "Whenever you can, do things simply. Use advanced features only when necessary, and select the feature that best matches your use case. For example, you will probably not need ``vars``, ``vars_files``, ``vars_prompt`` and ``--extra-vars`` all at once, while also using an external inventory file. If something feels complicated, it probably is. Take the time to look for a simpler solution."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:24
msgid "Use version control"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:26
msgid "Keep your playbooks, roles, inventory, and variables files in git or another version control system and make commits to the repository when you make changes. Version control gives you an audit trail describing when and why you changed the rules that automate your infrastructure."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:29
msgid "Playbook tips"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:31
msgid "These tips help make playbooks and roles easier to read, maintain, and debug."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:34
msgid "Use whitespace"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:36
msgid "Generous use of whitespace, for example, a blank line before each block or task, makes a playbook easy to scan."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:39
msgid "Always name tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:41
msgid "Task names are optional, but extremely useful. In its output, Ansible shows you the name of each task it runs. Choose names that describe what each task does and why."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:44
msgid "Always mention the state"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:46
msgid "For many modules, the 'state' parameter is optional. Different modules have different default settings for 'state', and some modules support several 'state' settings. Explicitly setting 'state=present' or 'state=absent' makes playbooks and roles clearer."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:49
msgid "Use comments"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:51
msgid "Even with task names and explicit state, sometimes a part of a playbook or role (or inventory/variable file) needs more explanation. Adding a comment (any line starting with '#') helps others (and possibly yourself in future) understand what a play or task (or variable setting) does, how it does it, and why."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:54
msgid "Inventory tips"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:56
msgid "These tips help keep your inventory well organized."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:59
msgid "Use dynamic inventory with clouds"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:61
msgid "With cloud providers and other systems that maintain canonical lists of your infrastructure, use :ref:`dynamic inventory <intro_dynamic_inventory>` to retrieve those lists instead of manually updating static inventory files. With cloud resources, you can use tags to differentiate production and staging environments."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:64
msgid "Group inventory by function"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:66
msgid "A system can be in multiple groups.  See :ref:`intro_inventory` and :ref:`intro_patterns`. If you create groups named for the function of the nodes in the group, for example *webservers* or *dbservers*, your playbooks can target machines based on function. You can assign function-specific variables using the group variable system, and design Ansible roles to handle function-specific use cases. See :ref:`playbooks_reuse_roles`."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:69
msgid "Separate production and staging inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:71
msgid "You can keep your production environment separate from development, test, and staging environments by using separate inventory files or directories for each environment. This way you pick with -i what you are targeting. Keeping all your environments in one file can lead to surprises!"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:76
msgid "Keep vaulted variables safely visible"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:78
msgid "You should encrypt sensitive or secret variables with Ansible Vault. However, encrypting the variable names as well as the variable values makes it hard to find the source of the values. You can keep the names of your variables accessible (by ``grep``, for example) without exposing any secrets by adding a layer of indirection:"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:80
msgid "Create a ``group_vars/`` subdirectory named after the group."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:81
msgid "Inside this subdirectory, create two files named ``vars`` and ``vault``."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:82
msgid "In the ``vars`` file, define all of the variables needed, including any sensitive ones."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:83
msgid "Copy all of the sensitive variables over to the ``vault`` file and prefix these variables with ``vault_``."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:84
msgid "Adjust the variables in the ``vars`` file to point to the matching ``vault_`` variables using jinja2 syntax: ``db_password: {{ vault_db_password }}``."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:85
msgid "Encrypt the ``vault`` file to protect its contents."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:86
msgid "Use the variable name from the ``vars`` file in your playbooks."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:88
msgid "When running a playbook, Ansible finds the variables in the unencrypted file, which pulls the sensitive variable values from the encrypted file. There is no limit to the number of variable and vault files or their names."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:91
msgid "Execution tricks"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:93
msgid "These tips apply to using Ansible, rather than to Ansible artifacts."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:96
msgid "Try it in staging first"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:98
msgid "Testing changes in a staging environment before rolling them out in production is always a great idea.  Your environments need not be the same size and you can use group variables to control the differences between those environments."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:101
msgid "Update in batches"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:103
msgid "Use the 'serial' keyword to control how many machines you update at once in the batch. See :ref:`playbooks_delegation`."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:108
msgid "Handling OS and distro differences"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:110
msgid "Group variables files and the ``group_by`` module work together to help Ansible execute across a range of operating systems and distributions that require different settings, packages, and tools. The ``group_by`` module creates a dynamic group of hosts matching certain criteria. This group does not need to be defined in the inventory file. This approach lets you execute different tasks on different operating systems or distributions. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:128
msgid "The first play categorizes all systems into dynamic groups based on the operating system name. Later plays can use these groups as patterns on the ``hosts`` line. You can also add group-specific settings in group vars files. All three names must match: the name created by the ``group_by`` task, the name of the pattern in subsequent plays, and the name of the group vars file. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:138
msgid "In this example, CentOS machines get the value of '42' for asdf, but other machines get '10'. This can be used not only to set variables, but also to apply certain roles to only certain systems."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:141
msgid "You can use the same setup with ``include_vars`` when you only need OS-specific variables, not tasks::"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:150
msgid "This pulls in variables from the group_vars/os_CentOS.yml file."
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:154
#: ../../rst/user_guide/playbooks_intro.rst:142
#: ../../rst/user_guide/playbooks_reuse_includes.rst:13
#: ../../rst/user_guide/playbooks_reuse_roles.rst:469
#: ../../rst/user_guide/sample_setup.rst:272
msgid ":ref:`yaml_syntax`"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:155
#: ../../rst/user_guide/playbooks_intro.rst:143
#: ../../rst/user_guide/playbooks_reuse_includes.rst:14
#: ../../rst/user_guide/playbooks_reuse_roles.rst:470
#: ../../rst/user_guide/sample_setup.rst:273
msgid "Learn about YAML syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:157
#: ../../rst/user_guide/sample_setup.rst:275
msgid "Review the basic playbook features"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:161
#: ../../rst/user_guide/playbooks_reuse_includes.rst:28
#: ../../rst/user_guide/sample_setup.rst:279
msgid "Learn how to extend Ansible by writing your own modules"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:162
#: ../../rst/user_guide/playbooks_intro.rst:150
#: ../../rst/user_guide/sample_setup.rst:280
msgid ":ref:`intro_patterns`"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:163
#: ../../rst/user_guide/playbooks_intro.rst:151
#: ../../rst/user_guide/sample_setup.rst:281
msgid "Learn about how to select hosts"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:164
#: ../../rst/user_guide/playbooks_intro.rst:152
#: ../../rst/user_guide/sample_setup.rst:282
msgid "`GitHub examples directory <https://github.com/ansible/ansible-examples>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_best_practices.rst:165
#: ../../rst/user_guide/sample_setup.rst:283
msgid "Complete playbook files from the github project source"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:5
msgid "Blocks"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:7
msgid "Blocks create logical groups of tasks. Blocks also offer ways to handle task errors, similar to exception handling in many programming languages."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:13
msgid "Grouping tasks with blocks"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:15
msgid "All tasks in a block inherit directives applied at the block level. Most of what you can apply to a single task (with the exception of loops) can be applied at the block level, so blocks make it much easier to set data or directives common to the tasks. The directive does not affect the block itself, it is only inherited by the tasks enclosed by a block. For example, a `when` statement is applied to the tasks within a block, not to the block itself."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:17
msgid "Block example with named tasks inside the block"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:46
msgid "In the example above, the 'when' condition will be evaluated before Ansible runs each of the three tasks in the block. All three tasks also inherit the privilege escalation directives, running as the root user. Finally, ``ignore_errors: yes`` ensures that Ansible continues to execute the playbook even if some of the tasks fail."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:48
msgid "Names for blocks have been available since Ansible 2.3. We recommend using names in all tasks, within blocks or elsewhere, for better visibility into the tasks being executed when you run the playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:53
msgid "Handling errors with blocks"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:55
msgid "You can control how Ansible responds to task errors using blocks with ``rescue`` and ``always`` sections."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:57
msgid "Rescue blocks specify tasks to run when an earlier task in a block fails. This approach is similar to exception handling in many programming languages. Ansible only runs rescue blocks after a task returns a 'failed' state. Bad task definitions and unreachable hosts will not trigger the rescue block."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:60
msgid "Block error handling example"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:82
msgid "You can also add an ``always`` section to a block. Tasks in the ``always`` section run no matter what the task status of the previous block is."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:85
msgid "Block with always section"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:106
msgid "Together, these elements offer complex error handling."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:108
msgid "Block with all sections"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:140
msgid "The tasks in the ``block`` execute normally. If any tasks in the block return ``failed``, the ``rescue`` section executes tasks to recover from the error. The ``always`` section runs regardless of the results of the ``block`` and ``rescue`` sections."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:142
msgid "If an error occurs in the block and the rescue task succeeds, Ansible reverts the failed status of the original task for the run and continues to run the play as if the original task had succeeded. The rescued task is considered successful, and does not trigger ``max_fail_percentage`` or ``any_errors_fatal`` configurations. However, Ansible still reports a failure in the playbook statistics."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:144
msgid "You can use blocks with ``flush_handlers`` in a rescue task to ensure that all handlers run even if an error occurs:"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:146
msgid "Block run handlers in error handling"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:172
msgid "Ansible provides a couple of variables for tasks in the ``rescue`` portion of a block:"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:175
msgid "ansible_failed_task"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:175
msgid "The task that returned 'failed' and triggered the rescue. For example, to get the name use ``ansible_failed_task.name``."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:178
msgid "ansible_failed_result"
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:178
msgid "The captured return result of the failed task that triggered the rescue. This would equate to having used this var in the ``register`` keyword."
msgstr ""

#: ../../rst/user_guide/playbooks_blocks.rst:185
#: ../../rst/user_guide/playbooks_conditionals.rst:500
#: ../../rst/user_guide/playbooks_filters.rst:1728
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:737
#: ../../rst/user_guide/playbooks_loops.rst:435
#: ../../rst/user_guide/playbooks_strategies.rst:218
#: ../../rst/user_guide/playbooks_tags.rst:425
#: ../../rst/user_guide/playbooks_templating.rst:49
#: ../../rst/user_guide/playbooks_tests.rst:397
#: ../../rst/user_guide/playbooks_variables.rst:458
msgid "Playbook organization by roles"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:5
msgid "Validating tasks: check mode and diff mode"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:7
msgid "Ansible provides two modes of execution that validate tasks: check mode and diff mode. These modes can be used separately or together. They are useful when you are creating or editing a playbook or role and you want to know what it will do. In check mode, Ansible runs without making any changes on remote systems. Modules that support check mode report the changes they would have made. Modules that do not support check mode report nothing and do nothing. In diff mode, Ansible provides before-and-after comparisons. Modules that support diff mode display detailed information. You can combine check mode and diff mode for detailed validation of your playbook or role."
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:13
msgid "Using check mode"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:15
msgid "Check mode is just a simulation. It will not generate output for tasks that use :ref:`conditionals based on registered variables <conditionals_registered_vars>` (results of prior tasks). However, it is great for validating configuration management playbooks that run on one node at a time. To run a playbook in check mode::"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:22
msgid "Enforcing or preventing check mode on tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:26
msgid "If you want certain tasks to run in check mode always, or never, regardless of whether you run the playbook with or without ``--check``, you can add the ``check_mode`` option to those tasks:"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:28
msgid "To force a task to run in check mode, even when the playbook is called without ``--check``, set ``check_mode: yes``."
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:29
msgid "To force a task to run in normal mode and make changes to the system, even when the playbook is called with ``--check``, set ``check_mode: no``."
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:46
msgid "Running single tasks with ``check_mode: yes`` can be useful for testing Ansible modules, either to test the module itself or to test the conditions under which a module would make changes. You can register variables (see :ref:`playbooks_conditionals`) on these tasks for even more detail on the potential changes."
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:48
msgid "Prior to version 2.2 only the equivalent of ``check_mode: no`` existed. The notation for that was ``always_run: yes``."
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:51
msgid "Skipping tasks or ignoring errors in check mode"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:55
msgid "If you want to skip a task or ignore errors on a task when you run Ansible in check mode, you can use a boolean magic variable ``ansible_check_mode``, which is set to ``True`` when Ansible runs in check mode. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:74
msgid "Using diff mode"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:76
msgid "The ``--diff`` option for ansible-playbook can be used alone or with ``--check``. When you run in diff mode, any module that supports diff mode reports the changes made or, if used with ``--check``, the changes that would have been made. Diff mode is most common in modules that manipulate files (for example, the template module) but other modules might also show 'before and after' information (for example, the user module)."
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:78
msgid "Diff mode produces a large amount of output, so it is best used when checking a single host at a time. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:85
msgid "Enforcing or preventing diff mode on tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_checkmode.rst:87
msgid "Because the ``--diff`` option can reveal sensitive information, you can disable it for a task by specifying ``diff: no``. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:5
msgid "Conditionals"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:7
msgid "In a playbook, you may want to execute different tasks, or have different goals, depending on the value of a fact (data about the remote system), a variable, or the result of a previous task. You may want the value of some variables to depend on the value of other variables. Or you may want to create additional groups of hosts based on whether the hosts match other criteria. You can do all of these things with conditionals."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:9
msgid "Ansible uses Jinja2 :ref:`tests <playbooks_tests>` and :ref:`filters <playbooks_filters>` in conditionals. Ansible supports all the standard tests and filters, and adds some unique ones as well."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:13
msgid "There are many options to control execution flow in Ansible. You can find more examples of supported conditionals at `<https://jinja.palletsprojects.com/en/master/templates/#comparisons>`_."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:21
msgid "Basic conditionals with ``when``"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:23
msgid "The simplest conditional statement applies to a single task. Create the task, then add a ``when`` statement that applies a test. The ``when`` clause is a raw Jinja2 expression without double curly braces (see :ref:`group_by_module`). When you run the task or playbook, Ansible evaluates the test for all hosts. On any host where the test passes (returns a value of True), Ansible runs that task. For example, if you are installing mysql on multiple machines, some of which have SELinux enabled, you might have a task to configure SELinux to allow mysql to run. You would only want that task to run on machines that have SELinux enabled:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:37
msgid "Conditionals based on ansible_facts"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:39
msgid "Often you want to execute or skip a task based on facts. Facts are attributes of individual hosts, including IP address, operating system, the status of a filesystem, and many more. With conditionals based on facts:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:41
msgid "You can install a certain package only when the operating system is a particular version."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:42
msgid "You can skip configuring a firewall on hosts with internal IP addresses."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:43
msgid "You can perform cleanup tasks only when a filesystem is getting full."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:45
msgid "See :ref:`commonly_used_facts` for a list of facts that frequently appear in conditional statements. Not all facts exist for all hosts. For example, the 'lsb_major_release' fact used in an example below only exists when the lsb_release package is installed on the target host. To see what facts are available on your systems, add a debug task to your playbook::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:51
msgid "Here is a sample conditional based on a fact:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:60
msgid "If you have multiple conditions, you can group them with parentheses:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:70
msgid "You can use `logical operators <https://jinja.palletsprojects.com/en/master/templates/#logic>`_ to combine conditions. When you have multiple conditions that all need to be true (that is, a logical ``and``), you can specify them as a list::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:79
msgid "If a fact or variable is a string, and you need to run a mathematical comparison on it, use a filter to ensure that Ansible reads the value as an integer::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:88
msgid "Conditions based on registered variables"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:90
msgid "Often in a playbook you want to execute or skip a task based on the outcome of an earlier task. For example, you might want to configure a service after it is upgraded by an earlier task. To create a conditional based on a registered variable:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:92
msgid "Register the outcome of the earlier task as a variable."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:93
msgid "Create a conditional test based on the registered variable."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:95
msgid "You create the name of the registered variable using the ``register`` keyword. A registered variable always contains the status of the task that created it as well as any output that task generated. You can use registered variables in templates and action lines as well as in conditional ``when`` statements. You can access the string contents of the registered variable using ``variable.stdout``. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:110
msgid "You can use registered results in the loop of a task if the variable is a list. If the variable is not a list, you can convert it into a list, with either ``stdout_lines`` or with ``variable.stdout.split()``. You can also split the lines by other fields::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:128
msgid "The string content of a registered variable can be empty. If you want to run another task only on hosts where the stdout of your registered variable is empty, check the registered variable's string contents for emptiness:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:146
msgid "Ansible always registers something in a registered variable for every host, even on hosts where a task fails or Ansible skips a task because a condition is not met. To run a follow-up task on these hosts, query the registered variable for ``is skipped`` (not for \"undefined\" or \"default\"). See :ref:`registered_variables` for more information. Here are sample conditionals based on the success or failure of a task. Remember to ignore errors if you want Ansible to continue executing on a host when a failure occurs:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:168
msgid "Older versions of Ansible used ``success`` and ``fail``, but ``succeeded`` and ``failed`` use the correct tense. All of these options are now valid."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:172
msgid "Conditionals based on variables"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:174
msgid "You can also create conditionals based on variables defined in the playbooks or inventory. Because conditionals require boolean input (a test must evaluate as True to trigger the condition), you must apply the ``| bool`` filter to non boolean variables, such as string variables with content like 'yes', 'on', '1', or 'true'. You can define variables like this:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:182
msgid "With the variables above, Ansible would run one of these tasks and skip the other:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:195
msgid "If a required variable has not been set, you can skip or fail using Jinja2's `defined` test. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:208
msgid "This is especially useful in combination with the conditional import of vars files (see below). As the examples show, you do not need to use `{{ }}` to use variables inside conditionals, as these are already implied."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:214
msgid "Using conditionals in loops"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:216
msgid "If you combine a ``when`` statement with a :ref:`loop <playbooks_loops>`, Ansible processes the condition separately for each item. This is by design, so you can execute the task on some items in the loop and skip it on other items. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:226
msgid "If you need to skip the whole task when the loop variable is undefined, use the `|default` filter to provide an empty iterator. For example, when looping over a list:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:235
msgid "You can do the same thing when looping over a dict:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:247
msgid "Loading custom facts"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:249
msgid "You can provide your own facts, as described in :ref:`developing_modules`.  To run them, just make a call to your own custom fact gathering module at the top of your list of tasks, and variables returned there will be accessible to future tasks:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:264
msgid "Conditionals with re-use"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:266
msgid "You can use conditionals with re-usable tasks files, playbooks, or roles. Ansible executes these conditional statements differently for dynamic re-use (includes) and for static re-use (imports). See :ref:`playbooks_reuse` for more information on re-use in Ansible."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:271
msgid "Conditionals with imports"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:273
msgid "When you add a conditional to an import statement, Ansible applies the condition to all tasks within the imported file. This behavior is the equivalent of :ref:`tag_inheritance`. Ansible applies the condition to every task, and evaluates each task separately. For example, you might have a playbook called ``main.yml`` and a tasks file called ``other_tasks.yml``::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:289
#: ../../rst/user_guide/playbooks_conditionals.rst:329
msgid "Ansible expands this at execution time to the equivalent of::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:303
msgid "Thus if ``x`` is initially undefined, the ``debug`` task will be skipped. If this is not the behavior you want, use an ``include_*`` statement to apply a condition only to that statement itself."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:305
msgid "You can apply conditions to ``import_playbook`` as well as to the other ``import_*`` statements. When you use this approach, Ansible returns a 'skipped' message for every task on every host that does not match the criteria, creating repetitive output. In many cases the :ref:`group_by module <group_by_module>` can be a more streamlined way to accomplish the same objective; see :ref:`os_variance`."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:310
msgid "Conditionals with includes"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:312
msgid "When you use a conditional on an ``include_*`` statement, the condition is applied only to the include task itself and not to any other tasks within the included file(s). To contrast with the example used for conditionals on imports above, look at the same playbook and tasks file, but using an include instead of an import::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:347
msgid "By using ``include_tasks`` instead of ``import_tasks``, both tasks from ``other_tasks.yml`` will be executed as expected. For more information on the differences between ``include`` v ``import`` see :ref:`playbooks_reuse`."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:350
msgid "Conditionals with roles"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:352
msgid "There are three ways to apply conditions to roles:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:354
msgid "Add the same condition or conditions to all tasks in the role by placing your ``when`` statement under the ``roles`` keyword. See the example in this section."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:355
msgid "Add the same condition or conditions to all tasks in the role by placing your ``when`` statement on a static ``import_role`` in your playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:356
msgid "Add a condition or conditions to individual tasks or blocks within the role itself. This is the only approach that allows you to select or skip some tasks within the role based on your ``when`` statement. To select or skip tasks within the role, you must have conditions set on individual tasks or blocks, use the dynamic ``include_role`` in your playbook, and add the condition or conditions to the include. When you use this approach, Ansible applies the condition to the include itself plus any tasks in the role that also have that ``when`` statement."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:358
msgid "When you incorporate a role in your playbook statically with the ``roles`` keyword, Ansible adds the conditions you define to all the tasks in the role. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:370
msgid "Selecting variables, files, or templates based on facts"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:372
msgid "Sometimes the facts about a host determine the values you want to use for certain variables or even the file or template you want to select for that host. For example, the names of packages are different on CentOS and on Debian. The configuration files for common services are also different on different OS flavors and versions. To load different variables file, templates, or other files based on a fact about the hosts:"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:374
msgid "name your vars files, templates, or files to match the Ansible fact that differentiates them"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:376
msgid "select the correct vars file, template, or file for each host with a variable based on that Ansible fact"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:378
msgid "Ansible separates variables from tasks, keeping your playbooks from turning into arbitrary code with nested conditionals. This approach results in more streamlined and auditable configuration rules because there are fewer decision points to track."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:381
msgid "Selecting variables files based on facts"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:383
msgid "You can create a playbook that works on multiple platforms and OS versions with a minimum of syntax by placing your variable values in vars files and conditionally importing them. If you want to install Apache on some CentOS and some Debian servers, create variables files with YAML keys and values. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:390
msgid "Then import those variables files based on the facts you gather on the hosts in your playbook::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:404
msgid "Ansible gathers facts on the hosts in the webservers group, then interpolates the variable \"ansible_facts['os_family']\" into a list of filenames. If you have hosts with Red Hat operating systems (CentOS, for example), Ansible looks for 'vars/RedHat.yml'. If that file does not exist, Ansible attempts to load 'vars/os_defaults.yml'. For Debian hosts, Ansible first looks for 'vars/Debian.yml', before falling back on 'vars/os_defaults.yml'. If no files in the list are found, Ansible raises an error."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:407
msgid "Selecting files and templates based on facts"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:409
msgid "You can use the same approach when different OS flavors or versions require different configuration files or templates. Select the appropriate file or template based on the variables assigned to each host. This approach is often much cleaner than putting a lot of conditionals into a single template to cover multiple OS or package versions."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:411
msgid "For example, you can template out a configuration file that is very different between, say, CentOS and Debian::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:427
msgid "Commonly-used facts"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:429
msgid "The following Ansible facts are frequently used in conditionals."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:434
msgid "ansible_facts['distribution']"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:436
#: ../../rst/user_guide/playbooks_conditionals.rst:474
msgid "Possible values (sample, not complete list)::"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:465
msgid "ansible_facts['distribution_major_version']"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:467
msgid "The major version of the operating system. For example, the value is `16` for Ubuntu 16.04."
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:472
msgid "ansible_facts['os_family']"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:501
#: ../../rst/user_guide/playbooks_error_handling.rst:236
#: ../../rst/user_guide/playbooks_filters.rst:1729
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:738
#: ../../rst/user_guide/playbooks_intro.rst:144
#: ../../rst/user_guide/playbooks_loops.rst:436
#: ../../rst/user_guide/playbooks_reuse.rst:194
#: ../../rst/user_guide/playbooks_reuse_includes.rst:17
#: ../../rst/user_guide/playbooks_reuse_roles.rst:473
#: ../../rst/user_guide/playbooks_templating.rst:50
#: ../../rst/user_guide/playbooks_tests.rst:398
#: ../../rst/user_guide/playbooks_variables.rst:459
#: ../../rst/user_guide/windows_dsc.rst:498
#: ../../rst/user_guide/windows_faq.rst:231
#: ../../rst/user_guide/windows_setup.rst:566
#: ../../rst/user_guide/windows_usage.rst:506
#: ../../rst/user_guide/windows_winrm.rst:906
msgid ":ref:`playbooks_best_practices`"
msgstr ""

#: ../../rst/user_guide/playbooks_conditionals.rst:502
#: ../../rst/user_guide/playbooks_error_handling.rst:237
#: ../../rst/user_guide/playbooks_filters.rst:1730
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:739
#: ../../rst/user_guide/playbooks_loops.rst:437
#: ../../rst/user_guide/playbooks_reuse.rst:195
#: ../../rst/user_guide/playbooks_reuse_includes.rst:18
#: ../../rst/user_guide/playbooks_reuse_roles.rst:474
#: ../../rst/user_guide/playbooks_templating.rst:51
#: ../../rst/user_guide/playbooks_tests.rst:399
#: ../../rst/user_guide/playbooks_variables.rst:460
#: ../../rst/user_guide/windows_dsc.rst:499
#: ../../rst/user_guide/windows_faq.rst:232
#: ../../rst/user_guide/windows_setup.rst:567
#: ../../rst/user_guide/windows_usage.rst:507
#: ../../rst/user_guide/windows_winrm.rst:907
msgid "Tips and tricks for playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:5
msgid "Debugging tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:7
msgid "Ansible offers a task debugger so you can fix errors during execution instead of editing your playbook and running it again to see if your change worked. You have access to all of the features of the debugger in the context of the task. You can check or set the value of variables, update module arguments, and re-run the task with the new variables and arguments. The debugger lets you resolve the cause of the failure and continue with playbook execution."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:13
msgid "Enabling the debugger"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:15
msgid "The debugger is not enabled by default. If you want to invoke the debugger during playbook execution, you must enable it first."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:17
msgid "Use one of these three methods to enable the debugger:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:19
msgid "with the debugger keyword"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:20
msgid "in configuration or an environment variable, or"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:21
msgid "as a strategy"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:24
msgid "Enabling the debugger with the ``debugger`` keyword"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:28
msgid "You can use the ``debugger`` keyword to enable (or disable) the debugger for a specific play, role, block, or task. This option is especially useful when developing or extending playbooks, plays, and roles. You can enable the debugger on new or updated tasks. If they fail, you can fix the errors efficiently. The ``debugger`` keyword accepts five values:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:34
msgid "Value"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:34
msgid "Result"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:36
msgid "always"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:36
msgid "Always invoke the debugger, regardless of the outcome"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:38
msgid "never"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:38
msgid "Never invoke the debugger, regardless of the outcome"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:40
msgid "on_failed"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:40
msgid "Only invoke the debugger if a task fails"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:42
msgid "on_unreachable"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:42
msgid "Only invoke the debugger if a host is unreachable"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:44
msgid "on_skipped"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:44
msgid "Only invoke the debugger if the task is skipped"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:48
msgid "When you use the ``debugger`` keyword, the value you specify overrides any global configuration to enable or disable the debugger. If you define ``debugger`` at multiple levels, such as in a role and in a task, Ansible honors the most granular definition. The definition at the play or role level applies to all blocks and tasks within that play or role, unless they specify a different value. The definition at the block level overrides the definition at the play or role level, and applies to all tasks within that block, unless they specify a different value. The definition at the task level always applies to the task; it overrides the definitions at the block, play, or role level."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:51
msgid "Examples of using the ``debugger`` keyword"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:53
msgid "Example of setting the ``debugger`` keyword on a task:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:61
msgid "Example of setting the ``debugger`` keyword on a play:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:73
msgid "Example of setting the ``debugger`` keyword at multiple levels:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:86
msgid "In this example, the debugger is set to ``never`` at the play level and to ``on_failed`` at the task level. If the task fails, Ansible invokes the debugger, because the definition on the task overrides the definition on its parent play."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:89
msgid "Enabling the debugger in configuration or an environment variable"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:93
msgid "You can enable the task debugger globally with a setting in ansible.cfg or with an environment variable. The only options are ``True`` or ``False``. If you set the configuration option or environment variable to ``True``, Ansible runs the debugger on failed tasks by default."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:95
msgid "To enable the task debugger from ansible.cfg, add this setting to the defaults section::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:100
msgid "To enable the task debugger with an environment variable, pass the variable when you run your playbook::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:104
msgid "When you enable the debugger globally, every failed task invokes the debugger, unless the role, play, block, or task explicity disables the debugger. If you need more granular control over what conditions trigger the debugger, use the ``debugger`` keyword."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:107
msgid "Enabling the debugger as a strategy"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:109
msgid "If you are running legacy playbooks or roles, you may see the debugger enabled as a :ref:`strategy <strategy_plugins>`. You can do this at the play level, in ansible.cfg, or with the environment variable ``ANSIBLE_STRATEGY=debug``. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:118
msgid "Or in ansible.cfg::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:125
msgid "This backwards-compatible method, which matches Ansible versions before 2.5, may be removed in a future release."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:128
msgid "Resolving errors in the debugger"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:130
msgid "After Ansible invokes the debugger, you can use the seven :ref:`debugger commands <available_commands>` to resolve the error that Ansible encountered. Consider this example playbook, which defines the ``var1`` variable but uses the undefined ``wrong_var`` variable in a task by mistake."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:143
msgid "If you run this playbook, Ansible invokes the debugger when the task fails. From the debug prompt, you can change the module arguments or the variables and run the task again."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:178
msgid "Changing the task arguments in the debugger to use ``var1`` instead of ``wrong_var`` makes the task run successfully."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:183
msgid "Available debug commands"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:185
msgid "You can use these seven commands at the debug prompt:"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:191
msgid "Command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:191
msgid "Shortcut"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:191
msgid "Action"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:193
msgid "print"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:193
msgid "p"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:193
msgid "Print information about the task"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:195
msgid "task.args[*key*] = *value*"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:195
#: ../../rst/user_guide/playbooks_debugger.rst:197
msgid "no shortcut"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:195
msgid "Update module arguments"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:197
msgid "task_vars[*key*] = *value*"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:197
msgid "Update task variables (you must ``update_task`` next)"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:199
msgid "update_task"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:199
msgid "u"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:199
msgid "Recreate a task with updated task variables"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:201
msgid "redo"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:201
msgid "r"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:201
msgid "Run the task again"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:203
msgid "continue"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:203
msgid "c"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:203
msgid "Continue executing, starting with the next task"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:205
msgid "quit"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:205
msgid "q"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:205
msgid "Quit the debugger"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:209
msgid "For more details, see the individual descriptions and examples below."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:214
msgid "Print command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:216
msgid "``print *task/task.args/task_vars/host/result*`` prints information about the task::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:241
msgid "Update args command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:243
msgid "``task.args[*key*] = *value*`` updates a module argument. This sample playbook has an invalid package name::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:254
msgid "When you run the playbook, the invalid package name triggers an error, and Ansible invokes the debugger. You can fix the package name by viewing, then updating the module argument::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:263
msgid "After you update the module argument, use ``redo`` to run the task again with the new args."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:268
msgid "Update vars command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:270
msgid "``task_vars[*key*] = *value*`` updates the ``task_vars``. You could fix the playbook above by viewing, then updating the task variables instead of the module args::"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:280
msgid "After you update the task variables, you must use ``update_task`` to load the new variables before using ``redo`` to run the task again."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:283
msgid "In 2.5 this was updated from ``vars`` to ``task_vars`` to avoid conflicts with the ``vars()`` python function."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:288
msgid "Update task command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:292
msgid "``u`` or ``update_task`` recreates the task from the original task data structure and templates with updated task variables. See the entry :ref:`update_vars_command` for an example of use."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:297
msgid "Redo command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:299
msgid "``r`` or ``redo`` runs the task again."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:304
msgid "Continue command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:306
msgid "``c`` or ``continue`` continues executing, starting with the next task."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:311
msgid "Quit command"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:313
msgid "``q`` or ``quit`` quits the debugger. The playbook execution is aborted."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:316
msgid "How the debugger interacts with the free strategy"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:318
msgid "With the default ``linear`` strategy enabled, Ansible halts execution while the debugger is active, and runs the debugged task immediately after you enter the ``redo`` command. With the ``free`` strategy enabled, however, Ansible does not wait for all hosts, and may queue later tasks on one host before a task fails on another host. With the ``free`` strategy, Ansible does not queue or execute any tasks while the debugger is active. However, all queued tasks remain in the queue and run as soon as you exit the debugger. If you use ``redo`` to reschedule a task from the debugger, other queued tasks may execute before your rescheduled task. For more information about strategies, see :ref:`playbooks_strategies`."
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:322
msgid ":ref:`playbooks_start_and_step`"
msgstr ""

#: ../../rst/user_guide/playbooks_debugger.rst:323
msgid "Running playbooks while debugging or testing"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:4
msgid "Controlling where tasks run: delegation and local actions"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:6
msgid "By default Ansible gathers facts and executes all tasks on the machines that match the ``hosts`` line of your playbook. This page shows you how to delegate tasks to a different machine or group, delegate facts to specific machines or groups, or run an entire playbook locally. Using these approaches, you can manage inter-related environments precisely and efficiently. For example, when updating your webservers, you might need to remove them from a load-balanced pool temporarily. You cannot perform this task on the webservers themselves. By delegating the task to localhost, you keep all the tasks within the same play."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:12
msgid "Tasks that cannot be delegated"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:14
msgid "Some tasks always execute on the controller. These tasks, including ``include``, ``add_host``, and ``debug``, cannot be delegated."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:19
msgid "Delegating tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:21
msgid "If you want to perform a task on one host with reference to other hosts, use the ``delegate_to`` keyword on a task. This is ideal for managing nodes in a load balanced pool or for controlling outage windows. You can use delegation with the :ref:`serial <rolling_update_batch_size>` keyword to control the number of hosts executing at one time::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:41
msgid "The first and third tasks in this play run on 127.0.0.1, which is the machine running Ansible. There is also a shorthand syntax that you can use on a per-task basis: ``local_action``. Here is the same playbook as above, but using the shorthand syntax for delegating to 127.0.0.1::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:55
msgid "You can use a local action to call 'rsync' to recursively copy files to the managed servers::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:64
msgid "Note that you must have passphrase-less SSH keys or an ssh-agent configured for this to work, otherwise rsync asks for a passphrase."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:66
msgid "To specify more arguments, use the following syntax::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:80
msgid "The `ansible_host` variable reflects the host a task is delegated to."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:85
msgid "Delegating facts"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:87
msgid "Delegating Ansible tasks is like delegating tasks in the real world - your groceries belong to you, even if someone else delivers them to your home. Similarly, any facts gathered by a delegated task are assigned by default to the `inventory_hostname` (the current host), not to the host which produced the facts (the delegated to host). To assign gathered facts to the delegated host instead of the current host, set ``delegate_facts`` to ``true``::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:99
msgid "This task gathers facts for the machines in the dbservers group and assigns the facts to those machines, even though the play targets the app_servers group. This way you can lookup `hostvars['dbhost1']['ansible_default_ipv4']['address']` even though dbservers were not part of the play, or left out by using `--limit`."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:104
msgid "Local playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:106
msgid "It may be useful to use a playbook locally on a remote host, rather than by connecting over SSH.  This can be useful for assuring the configuration of a system by putting a playbook in a crontab.  This may also be used to run a playbook inside an OS installer, such as an Anaconda kickstart."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:109
msgid "To run an entire playbook locally, just set the ``hosts:`` line to ``hosts: 127.0.0.1`` and then run the playbook like so::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:113
msgid "Alternatively, a local connection can be used in a single playbook play, even if other plays in the playbook use the default remote connection type::"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:121
msgid "If you set the connection to local and there is no ansible_python_interpreter set, modules will run under /usr/bin/python and not under {{ ansible_playbook_python }}. Be sure to set ansible_python_interpreter: \"{{ ansible_playbook_python }}\" in host_vars/localhost.yml, for example. You can avoid this issue by using ``local_action`` or ``delegate_to: localhost`` instead."
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:130
msgid "More ways to control how and where Ansible executes"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:131
msgid "`Ansible Examples on GitHub <https://github.com/ansible/ansible-examples>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_delegation.rst:132
msgid "Many examples of full-stack deployments"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:4
msgid "Setting the remote environment"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:8
msgid "You can use the ``environment`` keyword at the play, block, or task level to set an environment variable for an action on a remote host. With this keyword, you can enable using a proxy for a task that does http requests, set the required environment variables for language-specific version managers, and more."
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:10
msgid "When you set a value with ``environment:`` at the play or block level, it is available only to tasks within the play or block that are executed by the same user. The ``environment:`` keyword does not affect Ansible itself, Ansible configuration settings, the environment for other users, or the execution of other plugins like lookups and filters. Variables set with ``environment:`` do not automatically become Ansible facts, even when you set them at the play level. You must include an explicit ``gather_facts`` task in your playbook and set the ``environment`` keyword on that task to turn these values into Ansible facts."
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:16
msgid "Setting the remote environment in a task"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:18
msgid "You can set the environment directly at the task level::"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:32
msgid "You can re-use environment settings by defining them as variables in your play and accessing them in a task as you would access any stored Ansible variable::"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:50
msgid "You can store environment settings for re-use in multiple playbooks by defining them in a group_vars file::"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:61
msgid "You can set the remote environment at the play level::"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:72
msgid "These examples show proxy settings, but you can provide any number of settings this way."
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:75
msgid "Working with language-specific version managers"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:77
msgid "Some language-specific version managers (such as rbenv and nvm) require you to set environment variables while these tools are in use. When using these tools manually, you usually source some environment variables from a script or from lines added to your shell configuration file. In Ansible, you can do this with the environment keyword at the play level::"
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:114
msgid "The example above uses ``ansible_env`` as part of the PATH. Basing variables on ``ansible_env`` is risky. Ansible populates ``ansible_env`` values by gathering facts, so the value of the variables depends on the remote_user or become_user Ansible used when gathering those facts. If you change remote_user/become_user the values in ``ansible-env`` may not be the ones you expect."
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:117
msgid "Environment variables are normally passed in clear text (shell plugin dependent) so they are not a recommended way of passing secrets to the module being executed."
msgstr ""

#: ../../rst/user_guide/playbooks_environment.rst:119
msgid "You can also specify the environment at the task level::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:5
msgid "Error handling in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:7
msgid "When Ansible receives a non-zero return code from a command or a failure from a module, by default it stops executing on that host and continues on other hosts. However, in some circumstances you may want different behavior. Sometimes a non-zero return code indicates success. Sometimes you want a failure on one host to stop execution on all hosts. Ansible provides tools and settings to handle these situations and help you get the behavior, output, and reporting you want."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:15
msgid "Ignoring failed commands"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:17
msgid "By default Ansible stops executing tasks on a host when a task fails on that host. You can use ``ignore_errors`` to continue on in spite of the failure::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:23
msgid "The ``ignore_errors`` directive only works when the task is able to run and returns a value of 'failed'. It does not make Ansible ignore undefined variable errors, connection failures, execution issues (for example, missing packages), or syntax errors."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:26
msgid "Ignoring unreachable host errors"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:30
msgid "You can ignore a task failure due to the host instance being 'UNREACHABLE' with the ``ignore_unreachable`` keyword. Ansible ignores the task errors, but continues to execute future tasks against the unreachable host. For example, at the task level::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:39
msgid "And at the playbook level::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:54
msgid "Resetting unreachable hosts"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:56
msgid "If Ansible cannot connect to a host, it marks that host as 'UNREACHABLE' and removes it from the list of active hosts for the run. You can use `meta: clear_host_errors` to reactivate all hosts, so subsequent tasks can try to reach them again."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:62
msgid "Handlers and failure"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:64
msgid "Ansible runs :ref:`handlers <handlers>` at the end of each play. If a task notifies a handler but another task fails later in the play, by default the handler does *not* run on that host, which may leave the host in an unexpected state. For example, a task could update a configuration file and notify a handler to restart some service. If a task later in the same play fails, the configuration file might be changed but the service will not be restarted."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:71
msgid "You can change this behavior with the ``--force-handlers`` command-line option, by including ``force_handlers: True`` in a play, or by adding ``force_handlers = True`` to ansible.cfg. When handlers are forced, Ansible will run all notified handlers on all hosts, even hosts with failed tasks. (Note that certain errors could still prevent the handler from running, such as a host becoming unreachable.)"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:80
msgid "Defining failure"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:82
msgid "Ansible lets you define what \"failure\" means in each task using the ``failed_when`` conditional. As with all conditionals in Ansible, lists of multiple ``failed_when`` conditions are joined with an implicit ``and``, meaning the task only fails when *all* conditions are met. If you want to trigger a failure when any of the conditions is met, you must define the conditions in a string with an explicit ``or`` operator."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:84
msgid "You may check for failure by searching for a word or phrase in the output of a command::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:91
msgid "or based on the return code::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:98
msgid "You can also combine multiple conditions for failure. This task will fail if both conditions are true::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:107
msgid "If you want the task to fail when only one condition is satisfied, change the ``failed_when`` definition to::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:111
msgid "If you have too many conditions to fit neatly into one line, you can split it into a multi-line yaml value with ``>``::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:124
msgid "Defining \"changed\""
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:126
msgid "Ansible lets you define when a particular task has \"changed\" a remote node using the ``changed_when`` conditional. This lets you determine, based on return codes or output, whether a change should be reported in Ansible statistics and whether a handler should be triggered or not. As with all conditionals in Ansible, lists of multiple ``changed_when`` conditions are joined with an implicit ``and``, meaning the task only reports a change when *all* conditions are met. If you want to report a change when any of the conditions is met, you must define the conditions in a string with an explicit ``or`` operator. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:139
msgid "You can also combine multiple conditions to override \"changed\" result::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:149
msgid "See :ref:`controlling_what_defines_failure` for more conditional syntax examples."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:152
msgid "Ensuring success for command and shell"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:154
msgid "The :ref:`command <command_module>` and :ref:`shell <shell_module>` modules care about return codes, so if you have a command whose successful exit code is not zero, you can do this::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:162
msgid "Aborting a play on all hosts"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:164
msgid "Sometimes you want a failure on a single host, or failures on a certain percentage of hosts, to abort the entire play on all hosts. You can stop play execution after the first failure happens with ``any_errors_fatal``. For finer-grained control, you can use ``max_fail_percentage`` to abort the run after a given percentage of hosts has failed."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:167
msgid "Aborting on the first error: any_errors_fatal"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:169
msgid "If you set ``any_errors_fatal`` and a task returns an error, Ansible finishes the fatal task on all hosts in the current batch, then stops executing the play on all hosts. Subsequent tasks and plays are not executed. You can recover from fatal errors by adding a :ref:`rescue section <block_error_handling>` to the block. You can set ``any_errors_fatal`` at the play or block level::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:182
#, python-format
msgid "You can use this feature when all tasks must be 100% successful to continue playbook execution. For example, if you run a service on machines in multiple data centers with load balancers to pass traffic from users to the service, you want all load balancers to be disabled before you stop the service for maintenance. To ensure that any failure in the task that disables the load balancers will stop all other tasks::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:207
msgid "In this example Ansible starts the software upgrade on the front ends only if all of the load balancers are successfully disabled."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:212
msgid "Setting a maximum failure percentage"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:214
msgid "By default, Ansible continues to execute tasks as long as there are hosts that have not yet failed. In some situations, such as when executing a rolling update, you may want to abort the play when a certain threshold of failures has been reached. To achieve this, you can set a maximum failure percentage on a play::"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:221
msgid "The ``max_fail_percentage`` setting applies to each batch when you use it with :ref:`serial <rolling_update_batch_size>`. In the example above, if more than 3 of the 10 servers in the first (or any) batch of servers failed, the rest of the play would be aborted."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:225
msgid "The percentage set must be exceeded, not equaled. For example, if serial were set to 4 and you wanted the task to abort the play when 2 of the systems failed, set the max_fail_percentage at 49 rather than 50."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:228
msgid "Controlling errors in blocks"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:230
msgid "You can also use blocks to define responses to task errors. This approach is similar to exception handling in many programming languages. See :ref:`block_error_handling` for details and examples."
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:238
#: ../../rst/user_guide/playbooks_filters.rst:1721
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:730
#: ../../rst/user_guide/playbooks_lookups.rst:28
#: ../../rst/user_guide/playbooks_loops.rst:438
#: ../../rst/user_guide/playbooks_prompts.rst:109
#: ../../rst/user_guide/playbooks_reuse.rst:190
#: ../../rst/user_guide/playbooks_reuse_includes.rst:21
#: ../../rst/user_guide/playbooks_reuse_roles.rst:477
#: ../../rst/user_guide/playbooks_templating.rst:44
#: ../../rst/user_guide/playbooks_tests.rst:390
#: ../../rst/user_guide/playbooks_variables.rst:451
msgid ":ref:`playbooks_conditionals`"
msgstr ""

#: ../../rst/user_guide/playbooks_error_handling.rst:239
#: ../../rst/user_guide/playbooks_filters.rst:1722
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:731
#: ../../rst/user_guide/playbooks_lookups.rst:29
#: ../../rst/user_guide/playbooks_loops.rst:439
#: ../../rst/user_guide/playbooks_prompts.rst:110
#: ../../rst/user_guide/playbooks_templating.rst:45
#: ../../rst/user_guide/playbooks_tests.rst:391
#: ../../rst/user_guide/playbooks_variables.rst:452
msgid "Conditional statements in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:5
msgid "Using filters to manipulate data"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:7
msgid "Filters let you transform JSON data into YAML data, split a URL to extract the hostname, get the SHA1 hash of a string, add or multiply integers, and much more. You can use the Ansible-specific filters documented here to manipulate your data, or use any of the standard filters shipped with Jinja2 - see the list of :ref:`built-in filters <jinja2:builtin-filters>` in the official Jinja2 template documentation. You can also use :ref:`Python methods <jinja2:python-methods>` to transform data. You can :ref:`create custom Ansible filters as plugins <developing_filter_plugins>`, though we generally welcome new filters into the ansible-base repo so everyone can use them."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:9
msgid "Because templating happens on the Ansible controller, **not** on the target host, filters execute on the controller and transform data locally."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:15
msgid "Handling undefined variables"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:17
msgid "Filters can help you manage missing or undefined variables by providing defaults or making some variables optional. If you configure Ansible to ignore most undefined variables, you can mark some variables as requiring values with the ``mandatory`` filter."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:22
msgid "Providing default values"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:24
msgid "You can provide default values for variables directly in your templates using the Jinja2 'default' filter. This is often a better approach than failing if a variable is not defined::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:28
msgid "In the above example, if the variable 'some_variable' is not defined, Ansible uses the default value 5, rather than raising an \"undefined variable\" error and failing. If you are working within a role, you can also add a ``defaults/main.yml`` to define the default values for variables in your role."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:30
msgid "Beginning in version 2.8, attempting to access an attribute of an Undefined value in Jinja will return another Undefined value, rather than throwing an error immediately. This means that you can now simply use a default with a value in a nested data structure (in other words, :code:`{{ foo.bar.baz | default('DEFAULT') }}`) when you do not know if the intermediate values are defined."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:33
msgid "If you want to use the default value when variables evaluate to false or an empty string you have to set the second parameter to ``true``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:40
msgid "Making variables optional"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:42
msgid "By default Ansible requires values for all variables in a templated expression. However, you can make specific variables optional. For example, you might want to use a system default for some items and control the value for others. To make a variable optional, set the default value to the special variable ``omit``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:55
msgid "In this example, the default mode for the files ``/tmp/foo`` and ``/tmp/bar`` is determined by the umask of the system. Ansible does not send a value for ``mode``. Only the third file, ``/tmp/baz``, receives the `mode=0444` option."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:57
msgid "If you are \"chaining\" additional filters after the ``default(omit)`` filter, you should instead do something like this: ``\"{{ foo | default(None) | some_filter or omit }}\"``. In this example, the default ``None`` (Python null) value will cause the later filters to fail, which will trigger the ``or omit`` portion of the logic. Using ``omit`` in this manner is very specific to the later filters you are chaining though, so be prepared for some trial and error if you do this."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:63
msgid "Defining mandatory values"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:65
msgid "If you configure Ansible to ignore undefined variables, you may want to define some values as mandatory. By default, Ansible fails if a variable in your playbook or command is undefined. You can configure Ansible to allow undefined variables by setting :ref:`DEFAULT_UNDEFINED_VAR_BEHAVIOR` to ``false``. In that case, you may want to require some variables to be defined. You can do this with::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:69
msgid "The variable value will be used as is, but the template evaluation will raise an error if it is undefined."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:72
msgid "Defining different values for true/false/null (ternary)"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:74
msgid "You can create a test, then define one value to use when the test returns true and another when the test returns false (new in version 1.9)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:78
msgid "In addition, you can define a one value to use on true, one value on false and a third value on null (new in version 2.8)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:83
msgid "Managing data types"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:85
msgid "You might need to know, change, or set the data type on a variable. For example, a registered variable might contain a dictionary when your next task needs a list, or a user :ref:`prompt <playbooks_prompts>` might return a string when your playbook needs a boolean value. Use the ``type_debug``, ``dict2items``, and ``items2dict`` filters to manage data types. You can also use the data type itself to cast a value as a specific data type."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:88
msgid "Discovering the data type"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:92
msgid "If you are unsure of the underlying Python type of a variable, you can use the ``type_debug`` filter to display it. This is useful in debugging when you need a particular type of variable::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:100
msgid "Transforming dictionaries into lists"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:105
msgid "Use the ``dict2items`` filter to transform a dictionary into a list of items suitable for :ref:`looping <playbooks_loops>`::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:109
#: ../../rst/user_guide/playbooks_filters.rst:130
msgid "Dictionary data (before applying the ``dict2items`` filter)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:115
#: ../../rst/user_guide/playbooks_filters.rst:136
msgid "List data (after applying the ``dict2items`` filter)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:124
msgid "The ``dict2items`` filter is the reverse of the ``items2dict`` filter."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:126
msgid "If you want to configure the names of the keys, the ``dict2items`` filter accepts 2 keyword arguments. Pass the ``key_name`` and ``value_name`` arguments to configure the names of the keys in the list output::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:145
msgid "Transforming lists into dictionaries"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:149
msgid "Use the ``items2dict`` filter to transform a list into a dictionary, mapping the content into ``key: value`` pairs::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:153
msgid "List data (before applying the ``items2dict`` filter)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:161
msgid "Dictionary data (after applying the ``items2dict`` filter)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:166
msgid "The ``items2dict`` filter is the reverse of the ``dict2items`` filter."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:168
msgid "Not all lists use ``key`` to designate keys and ``value`` to designate values. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:178
msgid "In this example, you must pass the ``key_name`` and ``value_name`` arguments to configure the transformation. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:182
msgid "If you do not pass these arguments, or do not pass the correct values for your list, you will see ``KeyError: key`` or ``KeyError: my_typo``."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:185
msgid "Forcing the data type"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:187
msgid "You can cast values as certain types. For example, if you expect the input \"True\" from a :ref:`vars_prompt <playbooks_prompts>` and you want Ansible to recognize it as a boolean value instead of a string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:193
msgid "If you want to perform a mathematical comparison on a fact and you want Ansible to recognize it as an integer instead of a string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:204
msgid "Formatting data: YAML and JSON"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:206
msgid "You can switch a data structure in a template from or to JSON or YAML format, with options for formatting, indenting, and loading data. The basic filters are occasionally useful for debugging::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:211
msgid "For human readable output, you can use::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:216
msgid "You can change the indentation of either format::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:221
msgid "The ``to_yaml`` and ``to_nice_yaml`` filters use the `PyYAML library`_ which has a default 80 symbol string length limit. That causes unexpected line break after 80th symbol (if there is a space after 80th symbol) To avoid such behavior and generate long lines, use the ``width`` option. You must use a hardcoded number to define the width, instead of a construction like ``float(\"inf\")``, because the filter does not support proxying Python functions. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:227
msgid "The filter does support passing through other YAML parameters. For a full list, see the `PyYAML documentation`_."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:229
msgid "If you are reading in some already formatted data::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:234
#: ../../rst/user_guide/playbooks_filters.rst:268
msgid "for example::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:247
msgid "Filter `to_json` and Unicode support"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:249
msgid "By default `to_json` and `to_nice_json` will convert data received to ASCII, so::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:253
msgid "will return::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:257
msgid "To keep Unicode characters, pass the parameter `ensure_ascii=False` to the filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:265
msgid "To parse multi-document YAML strings, the ``from_yaml_all`` filter is provided. The ``from_yaml_all`` filter will return a generator of parsed YAML documents."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:281
msgid "Combining and selecting data"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:283
msgid "You can combine data from multiple sources and types, and select values from large data structures, giving you precise control over complex data."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:288
msgid "Combining items from multiple lists: zip and zip_longest"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:292
msgid "To get a list combining the elements of other lists use ``zip``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:302
msgid "To always exhaust all lists use ``zip_longest``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:308
msgid "Similarly to the output of the ``items2dict`` filter mentioned above, these filters can be used to construct a ``dict``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:312
msgid "List data (before applying the ``zip`` filter)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:321
msgid "Dictionary data (after applying the ``zip`` filter)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:327
msgid "Combining objects and subelements"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:331
msgid "The ``subelements`` filter produces a product of an object and the subelement values of that object, similar to the ``subelements`` lookup. This lets you specify individual subelements to use in a template. For example, this expression::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:335
msgid "Data before applying the ``subelements`` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:351
msgid "Data after applying the ``subelements`` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:379
msgid "You can use the transformed data with ``loop`` to iterate over the same subelement for multiple objects::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:390
msgid "Combining hashes/dictionaries"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:394
msgid "The ``combine`` filter allows hashes to be merged. For example, the following would override keys in one hash::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:398
msgid "The resulting hash would be::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:402
msgid "The filter can also take multiple arguments to merge::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:407
msgid "In this case, keys in ``d`` would override those in ``c``, which would override those in ``b``, and so on."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:409
msgid "The filter also accepts two optional parameters: ``recursive`` and ``list_merge``."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:414
msgid "recursive"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:412
msgid "Is a boolean, default to ``False``. Should the ``combine`` recursively merge nested hashes. Note: It does **not** depend on the value of the ``hash_behaviour`` setting in ``ansible.cfg``."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:418
msgid "list_merge"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:417
msgid "Is a string, its possible values are ``replace`` (default), ``keep``, ``append``, ``prepend``, ``append_rp`` or ``prepend_rp``. It modifies the behaviour of ``combine`` when the hashes to merge contain arrays/lists."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:434
msgid "If ``recursive=False`` (the default), nested hash aren't merged::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:438
#: ../../rst/user_guide/playbooks_filters.rst:450
#: ../../rst/user_guide/playbooks_filters.rst:472
#: ../../rst/user_guide/playbooks_filters.rst:481
#: ../../rst/user_guide/playbooks_filters.rst:490
#: ../../rst/user_guide/playbooks_filters.rst:500
#: ../../rst/user_guide/playbooks_filters.rst:525
#: ../../rst/user_guide/playbooks_filters.rst:540
#: ../../rst/user_guide/playbooks_filters.rst:582
#: ../../rst/user_guide/playbooks_filters.rst:669
#: ../../rst/user_guide/playbooks_tests.rst:319
#: ../../rst/user_guide/playbooks_tests.rst:342
msgid "This would result in::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:446
msgid "If ``recursive=True``, recurse into nested hash and merge their keys::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:459
msgid "If ``list_merge='replace'`` (the default), arrays from the right hash will \"replace\" the ones in the left hash::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:477
msgid "If ``list_merge='keep'``, arrays from the left hash will be kept::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:486
msgid "If ``list_merge='append'``, arrays from the right hash will be appended to the ones in the left hash::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:496
msgid "If ``list_merge='prepend'``, arrays from the right hash will be prepended to the ones in the left hash::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:506
msgid "If ``list_merge='append_rp'``, arrays from the right hash will be appended to the ones in the left hash. Elements of arrays in the left hash that are also in the corresponding array of the right hash will be removed (\"rp\" stands for \"remove present\"). Duplicate elements that aren't in both hashes are kept::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:536
msgid "If ``list_merge='prepend_rp'``, the behavior is similar to the one for ``append_rp``, but elements of arrays in the right hash are prepended::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:551
msgid "``recursive`` and ``list_merge`` can be used together::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:605
msgid "Selecting values from arrays or hashtables"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:609
msgid "The `extract` filter is used to map from a list of indices to a list of values from a container (hash or array)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:614
msgid "The results of the above expressions would be::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:619
msgid "The filter can take another argument::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:623
msgid "This takes the list of hosts in group 'x', looks them up in `hostvars`, and then looks up the `ec2_ip_address` of the result. The final result is a list of IP addresses for the hosts in group 'x'."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:625
msgid "The third argument to the filter can also be a list, for a recursive lookup inside the container::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:629
msgid "This would return a list containing the value of `b['a']['x']['y']`."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:632
msgid "Combining lists"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:634
msgid "This set of filters returns a list of combined lists."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:638
msgid "permutations"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:639
msgid "To get permutations of a list::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:650
msgid "combinations"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:651
msgid "Combinations always require a set size::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:657
msgid "Also see the :ref:`zip_filter`"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:660
msgid "products"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:661
msgid "The product filter returns the `cartesian product <https://docs.python.org/3/library/itertools.html#itertools.product>`_ of the input iterables. This is roughly equivalent to nested for-loops in a generator expression."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:676
msgid "Selecting JSON data: JSON queries"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:678
msgid "To select a single element or a data subset from a complex data structure in JSON format (for example, Ansible facts), use the ``json_query`` filter.  The ``json_query`` filter lets you query a complex JSON structure and iterate over it using a loop structure."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:682
#: ../../rst/user_guide/playbooks_filters.rst:823
msgid "This filter has migrated to the `community.general <https://galaxy.ansible.com/community/general>`_ collection. Follow the installation instructions to install that collection."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:685
msgid "This filter is built upon **jmespath**, and you can use the same syntax. For examples, see `jmespath examples <http://jmespath.org/examples.html>`_."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:687
msgid "Consider this data structure::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:736
msgid "To extract all clusters from this structure, you can use the following query::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:743
msgid "To extract all server names::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:750
msgid "To extract ports from cluster1::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:759
msgid "You can use a variable to make the query more readable."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:761
msgid "To print out the ports from cluster1 in a comma separated string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:767
msgid "In the example above, quoting literals using backticks avoids escaping quotes and maintains readability."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:769
msgid "You can use YAML `single quote escaping <https://yaml.org/spec/current.html#id2534365>`_::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:776
msgid "Escaping single quotes within single quotes in YAML is done by doubling the single quote."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:778
msgid "To get a hash map with all ports and names of a cluster::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:787
msgid "To extract ports from all clusters with name starting with 'server1'::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:795
msgid "To extract ports from all clusters with name containing 'server1'::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:803
msgid "while using ``starts_with`` and ``contains``, you have to use `` to_json | from_json `` filter for correct parsing of data structure."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:807
msgid "Randomizing data"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:809
msgid "When you need a randomly generated value, use one of these filters."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:815
msgid "Random MAC addresses"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:819
msgid "This filter can be used to generate a random MAC address from a string prefix."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:825
msgid "To get a random MAC address from a string prefix starting with '52:54:00'::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:830
msgid "Note that if anything is wrong with the prefix string, the filter will issue an error."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:834
msgid "As of Ansible version 2.9, you can also initialize the random number generator from a seed to create random-but-idempotent MAC addresses::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:842
msgid "Random items or numbers"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:844
msgid "The ``random`` filter in Ansible is an extension of the default Jinja2 random filter, and can be used to return a random item from a sequence of items or to generate a random number based on a range."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:846
msgid "To get a random item from a list::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:851
msgid "To get a random number between 0 and a specified number::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:856
msgid "To get a random number from 0 to 100 but in steps of 10::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:861
msgid "To get a random number from 1 to 100 but in steps of 10::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:868
msgid "You can initialize the random number generator from a seed to create random-but-idempotent numbers::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:873
msgid "Shuffling a list"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:875
msgid "The ``shuffle`` filter randomizes an existing list, giving a different order every invocation."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:877
msgid "To get a random list from an existing  list::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:884
msgid "You can initialize the shuffle generator from a seed to generate a random-but-idempotent order::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:889
msgid "The shuffle filter returns a list whenever possible. If you use it with a non 'listable' item, the filter does nothing."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:895
msgid "Managing list variables"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:897
msgid "You can search for the minimum or maximum value in a list, or flatten a multi-level list."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:899
msgid "To get the minimum value from list of numbers::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:905
msgid "To get the minimum value in a list of objects::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:909
msgid "To get the maximum value from a list of numbers::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:915
msgid "To get the maximum value in a list of objects::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:921
msgid "Flatten a list (same thing the `flatten` lookup does)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:925
msgid "Flatten only the first level of a list (akin to the `items` lookup)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:932
msgid "Preserve nulls in a list, by default flatten removes them. ::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:941
msgid "Selecting from sets or lists (set theory)"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:943
msgid "You can select or combine items from sets or lists."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:947
msgid "To get a unique set from a list::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:953
msgid "To get a union of two lists::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:960
msgid "To get the intersection of 2 lists (unique list of all items in both)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:967
msgid "To get the difference of 2 lists (items in 1 that don't exist in 2)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:974
msgid "To get the symmetric difference of 2 lists (items exclusive to each list)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:984
msgid "Calculating numbers (math)"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:988
msgid "You can calculate logs, powers, and roots of numbers with Ansible filters. Jinja2 provides other mathematical functions like abs() and round()."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:990
msgid "Get the logarithm (default is e)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:994
msgid "Get the base 10 logarithm::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:998
msgid "Give me the power of 2! (or 5)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1003
msgid "Square root, or the 5th::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1010
msgid "Managing network interactions"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1012
msgid "These filters help you with common network tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1016
msgid "These filters have migrated to the `ansible.netcommon <https://galaxy.ansible.com/ansible/netcommon>`_ collection. Follow the installation instructions to install that collection."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1021
msgid "IP address filters"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1025
msgid "To test if a string is a valid IP address::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1029
msgid "You can also require a specific IP protocol version::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1034
msgid "IP address filter can also be used to extract specific information from an IP address. For example, to get the IP address itself from a CIDR, you can use::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1039
msgid "More information about ``ipaddr`` filter and complete usage guide can be found in :ref:`playbooks_filters_ipaddr`."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1045
msgid "Network CLI filters"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1049
msgid "To convert the output of a network device CLI command into structured JSON output, use the ``parse_cli`` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1054
msgid "The ``parse_cli`` filter will load the spec file and pass the command output through it, returning JSON output. The YAML spec file defines how to parse the CLI output."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1057
msgid "The spec file should be valid formatted YAML.  It defines how to parse the CLI output and return JSON data.  Below is an example of a valid spec file that will parse the output from the ``show vlan`` command."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1079
#: ../../rst/user_guide/playbooks_filters.rst:1181
msgid "The spec file above will return a JSON data structure that is a list of hashes with the parsed VLAN information."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1082
msgid "The same command could be parsed into a hash by using the key and values directives.  Here is an example of how to parse the output into a hash value using the same ``show vlan`` command."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1105
msgid "Another common use case for parsing CLI commands is to break a large command into blocks that can be parsed.  This can be done using the ``start_block`` and ``end_block`` directives to break the command into blocks that can be parsed."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1129
msgid "The example above will parse the output of ``show interface`` into a list of hashes."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1132
msgid "The network filters also support parsing the output of a CLI command using the TextFSM library.  To parse the CLI output with TextFSM use the following filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1138
msgid "Use of the TextFSM filter requires the TextFSM library to be installed."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1141
msgid "Network XML filters"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1145
msgid "To convert the XML output of a network device command into structured JSON output, use the ``parse_xml`` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1150
msgid "The ``parse_xml`` filter will load the spec file and pass the command output through formatted as JSON."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1153
msgid "The spec file should be valid formatted YAML. It defines how to parse the XML output and return JSON data."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1156
msgid "Below is an example of a valid spec file that will parse the output from the ``show vlan | display xml`` command."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1184
msgid "The same command could be parsed into a hash by using the key and values directives.  Here is an example of how to parse the output into a hash value using the same ``show vlan | display xml`` command."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1212
msgid "The value of ``top`` is the XPath relative to the XML root node. In the example XML output given below, the value of ``top`` is ``configuration/vlans/vlan``, which is an XPath expression relative to the root node (<rpc-reply>). ``configuration`` in the value of ``top`` is the outer most container node, and ``vlan`` is the inner-most container node."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1218
msgid "``items`` is a dictionary of key-value pairs that map user-defined names to XPath expressions that select elements. The Xpath expression is relative to the value of the XPath value contained in ``top``. For example, the ``vlan_id`` in the spec file is a user defined name and its value ``vlan-id`` is the relative to the value of XPath in ``top``"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1223
msgid "Attributes of XML tags can be extracted using XPath expressions. The value of ``state`` in the spec is an XPath expression used to get the attributes of the ``vlan`` tag in output XML.::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1239
msgid "For more information on supported XPath expressions, see `XPath Support <https://docs.python.org/2/library/xml.etree.elementtree.html#xpath-support>`_."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1242
msgid "Network VLAN filters"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1246
msgid "Use the ``vlan_parser`` filter to transform an unsorted list of VLAN integers into a sorted string list of integers according to IOS-like VLAN list rules. This list has the following properties:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1249
msgid "Vlans are listed in ascending order."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1250
msgid "Three or more consecutive VLANs are listed with a dash."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1251
msgid "The first line of the list can be first_line_len characters long."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1252
msgid "Subsequent list lines can be other_line_len characters."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1254
msgid "To sort a VLAN list::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1258
msgid "This example renders the following sorted list::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1263
msgid "Another example Jinja template::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1270
msgid "This allows for dynamic generation of VLAN lists on a Cisco IOS tagged interface. You can store an exhaustive raw list of the exact VLANs required for an interface and then compare that to the parsed IOS output that would actually be generated for the configuration."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1276
msgid "Encrypting and checksumming strings and passwords"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1280
msgid "To get the sha1 hash of a string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1284
msgid "To get the md5 hash of a string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1288
msgid "Get a string checksum::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1292
msgid "Other hashes (platform dependent)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1296
msgid "To get a sha512 password hash (random salt)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1300
msgid "To get a sha256 password hash with a specific salt::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1304
msgid "An idempotent method to generate unique hashes per system is to use a salt that is consistent between runs::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1308
msgid "Hash types available depend on the master system running Ansible, 'hash' depends on hashlib, password_hash depends on passlib (https://passlib.readthedocs.io/en/stable/lib/passlib.hash.html)."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1312
msgid "Some hash types allow providing a rounds parameter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1319
msgid "Manipulating text"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1321
msgid "Several filters work with text, including URLs, file names, and path names."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1326
msgid "Adding comments to files"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1328
msgid "The ``comment`` filter lets you create comments in a file from text in a template, with a variety of comment styles. By default Ansible uses ``#`` to start a comment line and adds a blank comment line above and below your comment text. For example the following::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1332
msgid "produces this output:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1340
msgid "Ansible offers styles for comments in C (``//...``), C block (``/*...*/``), Erlang (``%...``) and XML (``<!--...-->``)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1348
msgid "You can define a custom comment character. This filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1352
msgid "produces:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1360
msgid "You can fully customize the comment style::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1364
msgid "That creates the following output:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1376
msgid "The filter can also be applied to any Ansible variable. For example to make the output of the ``ansible_managed`` variable more readable, we can change the definition in the ``ansible.cfg`` file to this:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1390
msgid "and then use the variable with the `comment` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1394
msgid "which produces this output:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1408
msgid "Splitting URLs"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1412
msgid "The ``urlsplit`` filter extracts the fragment, hostname, netloc, password, path, port, query, scheme, and username from an URL. With no arguments, returns a dictionary of all the fields::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1456
msgid "Searching strings with regular expressions"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1458
msgid "To search a string with a regex, use the \"regex_search\" filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1470
msgid "To search for all occurrences of regex matches, use the \"regex_findall\" filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1476
msgid "To replace text in a string with regex, use the \"regex_replace\" filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1494
msgid "If you want to match the whole string and you are using ``*`` make sure to always wraparound your regular expression with the start/end anchors. For example ``^(.*)$`` will always match only one result, while ``(.*)`` on some Python versions will match the whole string and an empty string at the end, which means it will make two replacements::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1515
msgid "Prior to ansible 2.0, if \"regex_replace\" filter was used with variables inside YAML arguments (as opposed to simpler 'key=value' arguments), then you needed to escape backreferences (for example, ``\\\\1``) with 4 backslashes (``\\\\\\\\``) instead of 2 (``\\\\``)."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1519
msgid "To escape special characters within a standard Python regex, use the \"regex_escape\" filter (using the default re_type='python' option)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1526
msgid "To escape special characters within a POSIX basic regex, use the \"regex_escape\" filter with the re_type='posix_basic' option::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1533
msgid "Managing file names and path names"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1535
msgid "To get the last name of a file path, like 'foo.txt' out of '/etc/asdf/foo.txt'::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1539
msgid "To get the last name of a windows style file path (new in version 2.0)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1543
msgid "To separate the windows drive letter from the rest of a file path (new in version 2.0)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1547
msgid "To get only the windows drive letter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1551
msgid "To get the rest of the path without the drive letter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1555
msgid "To get the directory from a path::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1559
msgid "To get the directory from a windows path (new version 2.0)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1563
msgid "To expand a path containing a tilde (`~`) character (new in version 1.5)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1567
msgid "To expand a path containing environment variables::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1571
msgid "`expandvars` expands local variables; using it on remote paths can lead to errors."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1575
msgid "To get the real path of a link (new in version 1.8)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1579
msgid "To get the relative path of a link, from a start point (new in version 1.7)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1583
msgid "To get the root and extension of a path or file name (new in version 2.0)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1588
msgid "The ``splitext`` filter returns a string. The individual components can be accessed by using the ``first`` and ``last`` filters::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1596
msgid "To join one or more path components::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1603
msgid "Manipulating strings"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1605
msgid "To add quotes for shell usage::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1610
msgid "To concatenate a list into a string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1614
msgid "To work with Base64 encoded strings::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1619
msgid "As of version 2.6, you can define the type of encoding to use, the default is ``utf-8``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1624
msgid "The ``string`` filter is only required for Python 2 and ensures that text to encode is a unicode string. Without that filter before b64encode the wrong value will be encoded."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1629
msgid "Managing UUIDs"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1631
msgid "To create a namespaced UUIDv5::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1637
msgid "To create a namespaced UUIDv5 using the default Ansible namespace '361E6D51-FAEC-444A-9079-341386DA8E2E'::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1643
msgid "To make use of one attribute from each item in a list of complex variables, use the :func:`Jinja2 map filter <jinja2:map>`::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1649
msgid "Handling dates and times"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1651
msgid "To get a date object from a string use the `to_datetime` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1665
msgid "To format a date using a string (like with the shell date command), use the \"strftime\" filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1680
msgid "To get all string possibilities, check https://docs.python.org/3/library/time.html#time.strftime"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1683
msgid "Getting Kubernetes resource names"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1687
msgid "These filters have migrated to the `community.kubernetes <https://galaxy.ansible.com/community/kubernetes>`_ collection. Follow the installation instructions to install that collection."
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1689
msgid "Use the \"k8s_config_resource_name\" filter to obtain the name of a Kubernetes ConfigMap or Secret, including its hash::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1694
msgid "This can then be used to reference hashes in Pod specifications::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1719
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:726
#: ../../rst/user_guide/playbooks_loops.rst:432
#: ../../rst/user_guide/playbooks_strategies.rst:213
#: ../../rst/user_guide/playbooks_variables.rst:449
#: ../../rst/user_guide/windows_faq.rst:229
#: ../../rst/user_guide/windows_setup.rst:564
msgid ":ref:`about_playbooks`"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1725
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:734
#: ../../rst/user_guide/playbooks_lookups.rst:32
#: ../../rst/user_guide/playbooks_reuse.rst:192
#: ../../rst/user_guide/playbooks_reuse_includes.rst:23
#: ../../rst/user_guide/playbooks_reuse_roles.rst:479
#: ../../rst/user_guide/playbooks_templating.rst:46
#: ../../rst/user_guide/playbooks_tests.rst:394
#: ../../rst/user_guide/playbooks_variables.rst:455
msgid ":ref:`playbooks_loops`"
msgstr ""

#: ../../rst/user_guide/playbooks_filters.rst:1726
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:735
#: ../../rst/user_guide/playbooks_lookups.rst:33
#: ../../rst/user_guide/playbooks_templating.rst:47
#: ../../rst/user_guide/playbooks_tests.rst:395
#: ../../rst/user_guide/playbooks_variables.rst:456
msgid "Looping in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:6
msgid "ipaddr filter"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:10
msgid "``ipaddr()`` is a Jinja2 filter designed to provide an interface to the `netaddr`_ Python package from within Ansible. It can operate on strings or lists of items, test various data to check if they are valid IP addresses, and manipulate the input data to extract requested information. ``ipaddr()`` works with both IPv4 and IPv6 addresses in various forms. There are also additional functions available to manipulate IP subnets and MAC addresses."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:19
msgid "The ``ipaddr()`` filter migrated to the `ansible.netcommon <https://galaxy.ansible.com/ansible/netcommon>`_ collection. Follow the installation instructions to install that collection."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:21
msgid "To use this filter in Ansible, you need to install the `netaddr`_ Python library on a computer on which you use Ansible (it is not required on remote hosts). It can usually be installed with either your system package manager or using ``pip``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:34
#: ../../rst/user_guide/playbooks_roles.rst:7
#: ../../rst/user_guide/windows_dsc.rst:5
#: ../../rst/user_guide/windows_usage.rst:9
#: ../../rst/user_guide/windows_winrm.rst:9
msgid "Topics"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:37
msgid "Basic tests"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:39
msgid "``ipaddr()`` is designed to return the input value if a query is True, and ``False`` if a query is False. This way it can be easily used in chained filters. To use the filter, pass a string to it:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:47
msgid "You can also pass the values as variables::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:51
msgid "Here are some example test results of various input strings::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:69
msgid "Sometimes you need either IPv4 or IPv6 addresses. To filter only for a particular type, ``ipaddr()`` filter has two \"aliases\", ``ipv4()`` and ``ipv6()``."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:72
msgid "Example use of an IPv4 filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:76
msgid "A similar example of an IPv6 filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:80
msgid "Here's some example test results to look for IPv4 addresses::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:88
msgid "And the same data filtered for IPv6 addresses::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:98
msgid "Filtering lists"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:100
msgid "You can filter entire lists - ``ipaddr()`` will return a list with values valid for a particular query::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:117
msgid "Wrapping IPv6 addresses in [ ] brackets"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:119
msgid "Some configuration files require IPv6 addresses to be \"wrapped\" in square brackets (``[ ]``). To accomplish that, you can use the ``ipwrap()`` filter. It will wrap all IPv6 addresses and leave any other strings intact::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:126
msgid "As you can see, ``ipwrap()`` did not filter out non-IP address values, which is usually what you want when for example you are mixing IP addresses with hostnames. If you still want to filter out all non-IP address values, you can chain both filters together::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:136
msgid "Basic queries"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:138
msgid "You can provide a single argument to each ``ipaddr()`` filter. The filter will then treat it as a query and return values modified by that query. Lists will contain only values that you are querying for."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:142
msgid "Types of queries include:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:144
msgid "query by name: ``ansible.netcommon.ipaddr('address')``, ``ansible.netcommon.ipv4('network')``;"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:145
msgid "query by CIDR range: ``ansible.netcommon.ipaddr('192.168.0.0/24')``, ``ansible.netcommon.ipv6('2001:db8::/32')``;"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:146
msgid "query by index number: ``ansible.netcommon.ipaddr('1')``, ``ansible.netcommon.ipaddr('-1')``;"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:148
msgid "If a query type is not recognized, Ansible will raise an error."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:152
msgid "Getting information about hosts and networks"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:154
#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:357
msgid "Here's our test list again::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:159
msgid "Let's take the list above and get only those elements that are host IP addresses and not network ranges::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:165
msgid "As you can see, even though some values had a host address with a CIDR prefix, they were dropped by the filter. If you want host IP addresses with their correct CIDR prefixes (as is common with IPv6 addressing), you can use the ``ipaddr('host')`` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:173
msgid "Filtering by IP address type also works::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:181
msgid "You can check if IP addresses or network ranges are accessible on a public Internet, or if they are in private networks::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:190
msgid "You can check which values are specifically network ranges::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:195
msgid "You can also check how many IP addresses can be in a certain range::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:200
msgid "By specifying a network range as a query, you can check if a given value is in that range::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:206
msgid "If you specify a positive or negative integer as a query, ``ipaddr()`` will treat this as an index and will return the specific IP address from a network range, in the 'host/prefix' format::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:222
msgid "You can also select IP addresses from a range by their index, from the start or end of the range::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:238
msgid "Getting information from host/prefix values"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:240
msgid "You frequently use a combination of IP addresses and subnet prefixes (\"CIDR\"), this is even more common with IPv6. The ``ansible.netcommon.ipaddr()`` filter can extract useful data from these prefixes."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:244
msgid "Here's an example set of two host prefixes (with some \"control\" values)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:248
msgid "First, let's make sure that we only work with correct host/prefix values, not just subnets or single IP addresses::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:254
msgid "In Debian-based systems, the network configuration stored in the ``/etc/network/interfaces`` file uses a combination of IP address, network address, netmask and broadcast address to configure an IPv4 network interface. We can get these values from a single 'host/prefix' combination:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:273
msgid "In the above example, we needed to handle the fact that values were stored in a list, which is unusual in IPv4 networks, where only a single IP address can be set on an interface. However, IPv6 networks can have multiple IP addresses set on an interface:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:295
msgid "If needed, you can extract subnet and prefix information from the 'host/prefix' value:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:306
msgid "Converting subnet masks to CIDR notation"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:308
msgid "Given a subnet in the form of network address and subnet mask, the ``ipaddr()`` filter can convert it into CIDR notation.  This can be useful for converting Ansible facts gathered about network configuration from subnet masks into CIDR format::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:323
msgid "First concatenate the network and netmask::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:328
msgid "This result can be converted to canonical form with ``ipaddr()`` to produce a subnet in CIDR format::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:338
msgid "Getting information about the network in CIDR notation"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:340
msgid "Given an IP address, the ``ipaddr()`` filter can produce the network address in CIDR notation. This can be useful when you want to obtain the network address from the IP address in CIDR format."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:343
msgid "Here's an example of IP address::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:348
msgid "This can be used to obtain the network address in CIDR notation format::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:355
msgid "IP address conversion"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:362
msgid "You can convert IPv4 addresses into IPv6 addresses::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:367
msgid "Converting from IPv6 to IPv4 works very rarely::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:372
msgid "But we can make a double conversion if needed::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:377
msgid "You can convert IP addresses to integers, the same way that you can convert integers into IP addresses::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:383
msgid "You can convert IPv4 address to `Hexadecimal notation <https://en.wikipedia.org/wiki/Hexadecimal>`_ with optional delimiter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:390
msgid "You can convert IP addresses to PTR records::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:403
msgid "Converting IPv4 address to a 6to4 address"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:405
msgid "A `6to4`_ tunnel is a way to access the IPv6 Internet from an IPv4-only network. If you have a public IPv4 address, you can automatically configure its IPv6 equivalent in the ``2002::/16`` network range. After conversion you will gain access to a ``2002:xxxx:xxxx::/48`` subnet which could be split into 65535 ``/64`` subnets if needed."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:411
msgid "To convert your IPv4 address, just send it through the ``'6to4'`` filter. It will be automatically converted to a router address (with a ``::1/48`` host address)::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:421
msgid "Finding IP addresses within a range"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:423
msgid "To find usable IP addresses within an IP range, try these ``ipaddr`` filters:"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:425
msgid "To find the next usable IP address in a range, use ``next_usable`` ::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:430
msgid "To find the last usable IP address from a range, use ``last_usable``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:435
msgid "To find the available range of IP addresses from the given network address, use ``range_usable``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:440
msgid "To find the peer IP address for a point to point link, use ``peer``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:447
msgid "To return the nth ip from a network, use the filter ``nthhost``::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:452
msgid "``nthhost`` also supports a negative value::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:457
msgid "To find the next nth usable IP address in relation to another within a range, use ``next_nth_usable`` In the example, ``next_nth_usable`` returns the second usable IP address for the given IP range::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:463
msgid "If there is no usable address, it returns an empty string::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:468
msgid "Just like ``next_nth_ansible``, you have ``previous_nth_usable`` to find the previous usable address::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:475
msgid "Testing if a address belong to a network range"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:477
msgid "The ``network_in_usable`` filter returns whether an address passed as an argument is usable in a network. Usable addresses are addresses that can be assigned to a host. The network ID and the broadcast address are not usable addresses.::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:490
msgid "The ``network_in_network`` filter returns whether an address or a network passed as argument is in a network.::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:505
msgid "To check whether multiple addresses belong to a network, use the ``reduce_on_network`` filter::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:512
msgid "IP Math"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:516
msgid "The ``ipmath()`` filter can be used to do simple IP math/arithmetic."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:518
msgid "Here are a few simple examples::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:552
msgid "Subnet manipulation"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:554
msgid "The ``ipsubnet()`` filter can be used to manipulate network subnets in several ways."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:556
msgid "Here is an example IP address and subnet::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:561
msgid "To check if a given string is a subnet, pass it through the filter without any arguments. If the given string is an IP address, it will be converted into a subnet::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:571
msgid "If you specify a subnet size as the first parameter of the  ``ipsubnet()`` filter, and the subnet size is **smaller than the current one**, you will get the number of subnets a given subnet can be split into::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:578
msgid "The second argument of the ``ipsubnet()`` filter is an index number; by specifying it you can get a new subnet with the specified size::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:597
msgid "If you specify an IP address instead of a subnet, and give a subnet size as the first argument, the ``ipsubnet()`` filter will instead return the biggest subnet that contains that given IP address::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:604
msgid "By specifying an index number as a second argument, you can select smaller and smaller subnets::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:623
msgid "By specifying another subnet as a second argument, if the second subnet includes the first, you can determine the rank of the first subnet in the second ::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:642
msgid "If the second subnet doesn't include the first subnet, the ``ipsubnet()`` filter raises an error."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:645
msgid "You can use the ``ipsubnet()`` filter with the ``ipaddr()`` filter to, for example, split a given ``/48`` prefix into smaller ``/64`` subnets::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:651
msgid "Because of the size of IPv6 subnets, iteration over all of them to find the correct one may take some time on slower computers, depending on the size difference between the subnets."
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:657
msgid "Subnet Merging"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:661
msgid "The ``cidr_merge()`` filter can be used to merge subnets or individual addresses into their minimal representation, collapsing overlapping subnets and merging adjacent ones wherever possible::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:671
msgid "Changing the action from 'merge' to 'span' will instead return the smallest subnet which contains all of the inputs::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:682
msgid "MAC address filter"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:684
msgid "You can use the ``hwaddr()`` filter to check if a given string is a MAC address or convert it between various formats. Examples::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:702
msgid "The supported formats result in the following conversions for the ``1a:2b:3c:4d:5e:6f`` MAC address::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:714
msgid "Generate an IPv6 address in Stateless Configuration (SLAAC)"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:716
msgid "the filter ``slaac()`` generates an IPv6 address for a given network and a MAC Address in Stateless Configuration::"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:724
msgid "`ansible.netcommon <https://galaxy.ansible.com/ansible/netcommon>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:725
msgid "Ansible network collection for common code"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:728
#: ../../rst/user_guide/playbooks_variables.rst:453
msgid ":ref:`playbooks_filters`"
msgstr ""

#: ../../rst/user_guide/playbooks_filters_ipaddr.rst:729
msgid "Introduction to Jinja2 filters and their uses"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:4
msgid "Handlers: running operations on change"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:6
msgid "Sometimes you want a task to run only when a change is made on a machine. For example, you may want to restart a service if a task updates the configuration of that service, but not if the configuration is unchanged. Ansible uses handlers to address this use case. Handlers are tasks that only run when notified. Each handler should have a globally unique name."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:12
msgid "Handler example"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:14
msgid "This playbook, ``verify-apache.yml``, contains a single play with a handler::"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:47
msgid "In this example playbook, the second task notifies the handler. A single task can notify more than one handler::"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:69
msgid "Controlling when handlers run"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:71
msgid "By default, handlers run after all the tasks in a particular play have been completed. This approach is efficient, because the handler only runs once, regardless of how many tasks notify it. For example, if multiple tasks update a configuration file and notify a handler to restart Apache, Ansible only bounces Apache once to avoid unnecessary restarts."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:73
msgid "If you need handlers to run before the end of the play, add a task to flush them using the :ref:`meta module <meta_module>`, which executes Ansible actions::"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:85
msgid "The ``meta: flush_handlers`` task triggers any handlers that have been notified at that point in the play."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:88
msgid "Using variables with handlers"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:90
msgid "You may want your Ansible handlers to use variables. For example, if the name of a service varies slightly by distribution, you want your output to show the exact name of the restarted service for each target machine. Avoid placing variables in the name of the handler. Since handler names are templated early on, Ansible may not have a value available for a handler name like this::"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:96
msgid "If the variable used in the handler name is not available, the entire play fails. Changing that variable mid-play **will not** result in newly created handler."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:98
msgid "Instead, place variables in the task parameters of your handler. You can load the values using ``include_vars`` like this:"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:112
msgid "Handlers can also \"listen\" to generic topics, and tasks can notify those topics as follows::"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:132
msgid "This use makes it much easier to trigger multiple handlers. It also decouples handlers from their names, making it easier to share handlers among playbooks and roles (especially when using 3rd party roles from a shared source like Galaxy)."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:137
msgid "Handlers always run in the order they are defined, not in the order listed in the notify-statement. This is also the case for handlers using `listen`."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:138
msgid "Handler names and `listen` topics live in a global namespace."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:139
msgid "Handler names are templatable and `listen` topics are not."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:140
msgid "Use unique handler names. If you trigger more than one handler with the same name, the first one(s) get overwritten. Only the last one defined will run."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:141
msgid "You can notify a handler defined inside a static include."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:142
msgid "You cannot notify a handler defined inside a dynamic include."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:143
msgid "A handler can not run import_role or include_role."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:145
msgid "When using handlers within roles, note that:"
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:147
msgid "handlers notified within ``pre_tasks``, ``tasks``, and ``post_tasks`` sections are automatically flushed at the end of section where they were notified."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:148
msgid "handlers notified within ``roles`` section are automatically flushed at the end of ``tasks`` section, but before any ``tasks`` handlers."
msgstr ""

#: ../../rst/user_guide/playbooks_handlers.rst:149
msgid "handlers are play scoped and as such can be used outside of the role they are defined in."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:6
msgid "Intro to playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:8
msgid "Ansible Playbooks offer a repeatable, re-usable, simple configuration management and multi-machine deployment system, one that is well suited to deploying complex applications. If you need to execute a task with Ansible more than once, write a playbook and put it under source control. Then you can use the playbook to push out new configuration or confirm the configuration of remote systems. The playbooks in the `ansible-examples repository <https://github.com/ansible/ansible-examples>`_ illustrate many useful techniques. You may want to look at these in another tab as you read the documentation."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:10
msgid "Playbooks can:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:12
msgid "declare configurations"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:13
msgid "orchestrate steps of any manual ordered process, on multiple sets of machines, in a defined order"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:14
msgid "launch tasks synchronously or :ref:`asynchronously <playbooks_async>`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:22
msgid "Playbook syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:24
msgid "Playbooks are expressed in YAML format with a minimum of syntax. If you are not familiar with YAML, look at our overview of :ref:`yaml_syntax` and consider installing an add-on for your text editor (see :ref:`other_tools_and_programs`) to help you write clean YAML syntax in your playbooks."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:26
msgid "A playbook is composed of one or more 'plays' in an ordered list. The terms 'playbook' and 'play' are sports analogies. Each play executes part of the overall goal of the playbook, running one or more tasks. Each task calls an Ansible module."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:29
msgid "Playbook execution"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:31
msgid "A playbook runs in order from top to bottom. Within each play, tasks also run in order from top to bottom. Playbooks with multiple 'plays' can orchestrate multi-machine deployments, running one play on your webservers, then another play on your database servers, then a third play on your network infrastructure, and so on. At a minimum, each play defines two things:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:33
msgid "the managed nodes to target, using a :ref:`pattern <intro_patterns>`"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:34
msgid "at least one task to execute"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:38
msgid "In Ansible 2.10 and later, we recommend you use the fully-qualified collection name in your playbooks to ensure the correct module is selected, because multiple collections can contain modules with the same name (for example, ``user``). See :ref:`collections_using_playbook`."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:40
msgid "In this example, the first play targets the web servers; the second play targets the database servers::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:71
msgid "Your playbook can include more than just a hosts line and tasks. For example, the playbook above sets a ``remote_user`` for each play. This is the user account for the SSH connection. You can add other :ref:`playbook_keywords` at the playbook, play, or task level to influence how Ansible behaves. Playbook keywords can control the :ref:`connection plugin <connection_plugins>`, whether to use :ref:`privilege escalation <become>`, how to handle errors, and more. To support a variety of environments, Ansible lets you set many of these parameters as command-line flags, in your Ansible configuration, or in your inventory. Learning the :ref:`precedence rules <general_precedence_rules>` for these sources of data will help you as you expand your Ansible ecosystem."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:76
msgid "Task execution"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:78
msgid "By default, Ansible executes each task in order, one at a time, against all machines matched by the host pattern. Each task executes a module with specific arguments. When a task has executed on all target machines, Ansible moves on to the next task. You can use :ref:`strategies <playbooks_strategies>` to change this default behavior. Within each play, Ansible applies the same task directives to all hosts. If a task fails on a host, Ansible takes that host out of the rotation for the rest of the playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:80
msgid "When you run a playbook, Ansible returns information about connections, the ``name`` lines of all your plays and tasks, whether each task has succeeded or failed on each machine, and whether each task has made a change on each machine. At the bottom of the playbook execution, Ansible provides a summary of the nodes that were targeted and how they performed. General failures and fatal \"unreachable\" communication attempts are kept separate in the counts."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:85
msgid "Desired state and 'idempotency'"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:87
msgid "Most Ansible modules check whether the desired final state has already been achieved, and exit without performing any actions if that state has been achieved, so that repeating the task does not change the final state. Modules that behave this way are often called 'idempotent.' Whether you run a playbook once, or multiple times, the outcome should be the same. However, not all playbooks and not all modules behave this way. If you are unsure, test your playbooks in a sandbox environment before running them multiple times in production."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:92
msgid "Running playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:94
msgid "To run your playbook, use the :ref:`ansible-playbook` command::"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:98
msgid "Use the ``--verbose`` flag when running your playbook to see detailed output from successful modules as well as unsuccessful ones."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:103
msgid "Ansible-Pull"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:105
msgid "Should you want to invert the architecture of Ansible, so that nodes check in to a central location, instead of pushing configuration out to them, you can."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:108
msgid "The ``ansible-pull`` is a small script that will checkout a repo of configuration instructions from git, and then run ``ansible-playbook`` against that content."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:111
msgid "Assuming you load balance your checkout location, ``ansible-pull`` scales essentially infinitely."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:113
msgid "Run ``ansible-pull --help`` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:115
msgid "There's also a `clever playbook <https://github.com/ansible/ansible-examples/blob/master/language_features/ansible_pull.yml>`_ available to configure ``ansible-pull`` via a crontab from push mode."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:118
msgid "Verifying playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:120
msgid "You may want to verify your playbooks to catch syntax errors and other problems before you run them. The :ref:`ansible-playbook` command offers several options for verification, including ``--check``, ``--diff``, ``--list-hosts``, ``--list-tasks``, and ``--syntax-check``. The :ref:`validate-playbook-tools` describes other tools for validating and testing playbooks."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:125
msgid "ansible-lint"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:127
msgid "You can use `ansible-lint <https://docs.ansible.com/ansible-lint/index.html>`_ for detailed, Ansible-specific feedback on your playbooks before you execute them. For example, if you run ``ansible-lint`` on the playbook called ``verify-apache.yml`` near the top of this page, you should get the following results:"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:136
msgid "The `ansible-lint default rules <https://docs.ansible.com/ansible-lint/rules/default_rules.html>`_ page describes each error. For ``[403]``, the recommended fix is to change ``state: latest`` to ``state: present`` in the playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:140
msgid "`ansible-lint <https://docs.ansible.com/ansible-lint/index.html>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:141
msgid "Learn how to test Ansible Playbooks syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:145
msgid "Tips for managing playbooks in the real world"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:149
msgid "Learn to extend Ansible by writing your own modules"
msgstr ""

#: ../../rst/user_guide/playbooks_intro.rst:153
msgid "Complete end-to-end playbook examples"
msgstr ""

#: ../../rst/user_guide/playbooks_lookups.rst:5
msgid "Lookups"
msgstr ""

#: ../../rst/user_guide/playbooks_lookups.rst:7
msgid "Lookup plugins retrieve data from outside sources such as files, databases, key/value stores, APIs, and other services. Like all templating, lookups execute and are evaluated on the Ansible control machine. Ansible makes the data returned by a lookup plugin available using the standard templating system. Before Ansible 2.5, lookups were mostly used indirectly in ``with_<lookup>`` constructs for looping. Starting with Ansible 2.5, lookups are used more explicitly as part of Jinja2 expressions fed into the ``loop`` keyword."
msgstr ""

#: ../../rst/user_guide/playbooks_lookups.rst:12
msgid "Using lookups in variables"
msgstr ""

#: ../../rst/user_guide/playbooks_lookups.rst:14
msgid "You can populate variables using lookups. Ansible evaluates the value each time it is executed in a task (or template)::"
msgstr ""

#: ../../rst/user_guide/playbooks_lookups.rst:22
msgid "For more details and a list of lookup plugins in ansible-base, see :ref:`plugins_lookup`. You may also find lookup plugins in collections. You can review a list of lookup plugins installed on your control machine with the command ``ansible-doc -l -t lookup``."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:5
msgid "Loops"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:7
msgid "Ansible offers the ``loop``, ``with_<lookup>``, and ``until`` keywords to execute a task multiple times. Examples of commonly-used loops include changing ownership on several files and/or directories with the :ref:`file module <file_module>`, creating multiple users with the :ref:`user module <user_module>`, and repeating a polling step until a certain result is reached."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:11
msgid "We added ``loop`` in Ansible 2.5. It is not yet a full replacement for ``with_<lookup>``, but we recommend it for most use cases."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:12
msgid "We have not deprecated the use of ``with_<lookup>`` - that syntax will still be valid for the foreseeable future."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:13
msgid "We are looking to improve ``loop`` syntax - watch this page and the `changelog <https://github.com/ansible/ansible/tree/devel/changelogs>`_ for updates."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:19
msgid "Comparing ``loop`` and ``with_*``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:21
msgid "The ``with_<lookup>`` keywords rely on :ref:`lookup_plugins` - even  ``items`` is a lookup."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:22
msgid "The ``loop`` keyword is equivalent to ``with_list``, and is the best choice for simple loops."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:23
msgid "The ``loop`` keyword will not accept a string as input, see :ref:`query_vs_lookup`."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:24
msgid "Generally speaking, any use of ``with_*`` covered in :ref:`migrating_to_loop` can be updated to use ``loop``."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:25
msgid "Be careful when changing ``with_items`` to ``loop``, as ``with_items`` performed implicit single-level flattening. You may need to use ``flatten(1)`` with ``loop`` to match the exact outcome. For example, to get the same output as:"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:34
msgid "you would need::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:38
msgid "Any ``with_*`` statement that requires using ``lookup`` within a loop should not be converted to use the ``loop`` keyword. For example, instead of doing:"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:44
msgid "it's cleaner to keep::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:51
msgid "Standard loops"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:54
msgid "Iterating over a simple list"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:56
msgid "Repeated tasks can be written as standard loops over a simple list of strings. You can define the list directly in the task::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:67
msgid "You can define the list in a variables file, or in the 'vars' section of your play, then refer to the name of the list in the task::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:71
msgid "Either of these examples would be the equivalent of::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:85
msgid "You can pass a list directly to a parameter for some plugins. Most of the packaging modules, like :ref:`yum <yum_module>` and :ref:`apt <apt_module>`, have this capability. When available, passing the list to a parameter is better than looping over the task. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:98
msgid "Check the :ref:`module documentation <modules_by_category>` to see if you can pass a list to any particular module's parameter(s)."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:101
msgid "Iterating over a list of hashes"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:103
msgid "If you have a list of hashes, you can reference subkeys in a loop. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:114
msgid "When combining :ref:`conditionals <playbooks_conditionals>` with a loop, the ``when:`` statement is processed separately for each item. See :ref:`the_when_statement` for examples."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:118
msgid "Iterating over a dictionary"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:120
msgid "To loop over a dict, use the  :ref:`dict2items <dict_filter>`:"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:133
msgid "Here, we are iterating over `tag_data` and printing the key and the value from it."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:136
msgid "Registering variables with a loop"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:138
msgid "You can register the output of a loop as a variable. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:147
msgid "When you use ``register`` with a loop, the data structure placed in the variable will contain a ``results`` attribute that is a list of all responses from the module. This differs from the data structure returned when using ``register`` without a loop::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:186
msgid "Subsequent loops over the registered variable to inspect the results may look like::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:194
msgid "During iteration, the result of the current item will be placed in the variable::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:207
msgid "Complex loops"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:210
msgid "Iterating over nested lists"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:212
msgid "You can use Jinja2 expressions to iterate over complex lists. For example, a loop can combine nested lists::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:226
msgid "Retrying a task until a condition is met"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:230
msgid "You can use the ``until`` keyword to retry a task until a certain condition is met.  Here's an example::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:239
msgid "This task runs up to 5 times with a delay of 10 seconds between each attempt. If the result of any attempt has \"all systems go\" in its stdout, the task succeeds. The default value for \"retries\" is 3 and \"delay\" is 5."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:241
msgid "To see the results of individual retries, run the play with ``-vv``."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:243
msgid "When you run a task with ``until`` and register the result as a variable, the registered variable will include a key called \"attempts\", which records the number of the retries for the task."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:245
msgid "You must set the ``until`` parameter if you want a task to retry. If ``until`` is not defined, the value for the ``retries`` parameter is forced to 1."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:248
msgid "Looping over inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:250
msgid "To loop over your inventory, or just a subset of it, you can use a regular ``loop`` with the ``ansible_play_batch`` or ``groups`` variables::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:262
msgid "There is also a specific lookup plugin ``inventory_hostnames`` that can be used like this::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:274
msgid "More information on the patterns can be found in :ref:`intro_patterns`."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:279
msgid "Ensuring list input for ``loop``: using ``query`` rather than ``lookup``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:281
msgid "The ``loop`` keyword requires a list as input, but the ``lookup`` keyword returns a string of comma-separated values by default. Ansible 2.5 introduced a new Jinja2 function named :ref:`query <query>` that always returns a list, offering a simpler interface and more predictable output from lookup plugins when using the ``loop`` keyword."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:283
msgid "You can force ``lookup`` to return a list to ``loop`` by using ``wantlist=True``, or you can use ``query`` instead."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:285
msgid "These examples do the same thing::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:295
msgid "Adding controls to loops"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:298
msgid "The ``loop_control`` keyword lets you manage your loops in useful ways."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:301
msgid "Limiting loop output with ``label``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:304
msgid "When looping over complex data structures, the console output of your task can be enormous. To limit the displayed output, use the ``label`` directive with ``loop_control``::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:321
msgid "The output of this task will display just the ``name`` field for each ``item`` instead of the entire contents of the multi-line ``{{ item }}`` variable."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:323
msgid "This is for making console output more readable, not protecting sensitive data. If there is sensitive data in ``loop``, set ``no_log: yes`` on the task to prevent disclosure."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:326
msgid "Pausing within a loop"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:329
msgid "To control the time (in seconds) between the execution of each item in a task loop, use the ``pause`` directive with ``loop_control``::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:343
msgid "Tracking progress through a loop with ``index_var``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:346
msgid "To keep track of where you are in a loop, use the ``index_var`` directive with ``loop_control``. This directive specifies a variable name to contain the current loop index::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:358
msgid "`index_var` is 0 indexed."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:361
msgid "Defining inner and outer variable names with ``loop_var``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:364
msgid "You can nest two looping tasks using ``include_tasks``. However, by default Ansible sets the loop variable ``item`` for each loop. This means the inner, nested loop will overwrite the value of ``item`` from the outer loop. You can specify the name of the variable for each loop using ``loop_var`` with ``loop_control``::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:385
msgid "If Ansible detects that the current loop is using a variable which has already been defined, it will raise an error to fail the task."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:388
msgid "Extended loop variables"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:391
msgid "As of Ansible 2.8 you can get extended loop information using the ``extended`` option to loop control. This option will expose the following information."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:394
msgid "Variable"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:396
msgid "``ansible_loop.allitems``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:396
msgid "The list of all items in the loop"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:397
msgid "``ansible_loop.index``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:397
msgid "The current iteration of the loop. (1 indexed)"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:398
msgid "``ansible_loop.index0``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:398
msgid "The current iteration of the loop. (0 indexed)"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:399
msgid "``ansible_loop.revindex``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:399
msgid "The number of iterations from the end of the loop (1 indexed)"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:400
msgid "``ansible_loop.revindex0``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:400
msgid "The number of iterations from the end of the loop (0 indexed)"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:401
msgid "``ansible_loop.first``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:401
msgid "``True`` if first iteration"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:402
msgid "``ansible_loop.last``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:402
msgid "``True`` if last iteration"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:403
msgid "``ansible_loop.length``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:403
msgid "The number of items in the loop"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:404
msgid "``ansible_loop.previtem``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:404
msgid "The item from the previous iteration of the loop. Undefined during the first iteration."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:405
msgid "``ansible_loop.nextitem``"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:405
msgid "The item from the following iteration of the loop. Undefined during the last iteration."
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:414
msgid "Accessing the name of your loop_var"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:417
msgid "As of Ansible 2.8 you can get the name of the value provided to ``loop_control.loop_var`` using the ``ansible_loop_var`` variable"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:419
msgid "For role authors, writing roles that allow loops, instead of dictating the required ``loop_var`` value, you can gather the value via::"
msgstr ""

#: ../../rst/user_guide/playbooks_loops.rst:426
msgid "Migrating from with_X to loop"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:1
msgid "In most cases, loops work best with the ``loop`` keyword instead of ``with_X`` style loops. The ``loop`` syntax is usually best expressed using filters instead of more complex use of ``query`` or ``lookup``."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:3
msgid "These examples show how to convert many common ``with_`` style loops to ``loop`` and filters."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:6
msgid "with_list"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:8
msgid "``with_list`` is directly replaced by ``loop``."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:27
msgid "with_items"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:29
msgid "``with_items`` is replaced by ``loop`` and the ``flatten`` filter."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:44
msgid "with_indexed_items"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:46
msgid "``with_indexed_items`` is replaced by ``loop``, the ``flatten`` filter and ``loop_control.index_var``."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:63
msgid "with_flattened"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:65
msgid "``with_flattened`` is replaced by ``loop`` and the ``flatten`` filter."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:80
msgid "with_together"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:82
msgid "``with_together`` is replaced by ``loop`` and the ``zip`` filter."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:98
msgid "Another example with complex data"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:113
msgid "with_dict"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:115
msgid "``with_dict`` can be substituted by ``loop`` and either the ``dictsort`` or ``dict2items`` filters."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:135
msgid "with_sequence"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:137
msgid "``with_sequence`` is replaced by ``loop`` and the ``range`` function, and potentially the ``format`` filter."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:153
msgid "with_subelements"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:155
msgid "``with_subelements`` is replaced by ``loop`` and the ``subelements`` filter."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:172
msgid "with_nested/with_cartesian"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:174
msgid "``with_nested`` and ``with_cartesian`` are replaced by loop and the ``product`` filter."
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:191
msgid "with_random_choice"
msgstr ""

#: ../../rst/user_guide/shared_snippets/with2loop.txt:193
msgid "``with_random_choice`` is replaced by just use of the ``random`` filter, without need of ``loop``."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:4
msgid "Module defaults"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:6
msgid "If you frequently call the same module with the same arguments, it can be useful to define default arguments for that particular module using the ``module_defaults`` keyword."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:8
msgid "Here is a basic example::"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:32
msgid "The ``module_defaults`` keyword can be used at the play, block, and task level. Any module arguments explicitly specified in a task will override any established default for that module argument::"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:42
msgid "You can remove any previously established defaults for a module by specifying an empty dict::"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:52
msgid "Any module defaults set at the play level (and block/task level when using ``include_role`` or ``import_role``) will apply to any roles used, which may cause unexpected behavior in the role."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:54
msgid "Here are some more realistic use cases for this feature."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:56
msgid "Interacting with an API that requires auth::"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:77
msgid "Setting a default AWS region for specific EC2-related modules::"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:93
msgid "Module defaults groups"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:97
msgid "Ansible 2.7 adds a preview-status feature to group together modules that share common sets of parameters. This makes it easier to author playbooks making heavy use of API-based modules such as cloud modules."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:100
msgid "Group"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:100
msgid "Purpose"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:100
msgid "Ansible Version"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:102
msgid "aws"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:102
msgid "Amazon Web Services"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:102
#: ../../rst/user_guide/playbooks_module_defaults.rst:104
#: ../../rst/user_guide/playbooks_module_defaults.rst:106
msgid "2.7"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:104
msgid "azure"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:104
msgid "Azure"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:106
msgid "gcp"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:106
msgid "Google Cloud Platform"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:108
msgid "k8s"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:108
msgid "Kubernetes"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:108
#: ../../rst/user_guide/playbooks_module_defaults.rst:110
msgid "2.8"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:110
msgid "os"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:110
msgid "OpenStack"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:112
msgid "acme"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:112
msgid "ACME"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:112
#: ../../rst/user_guide/playbooks_module_defaults.rst:114
#: ../../rst/user_guide/playbooks_module_defaults.rst:116
#: ../../rst/user_guide/playbooks_module_defaults.rst:118
msgid "2.10"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:114
msgid "docker*"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:114
msgid "Docker"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:116
msgid "ovirt"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:116
msgid "oVirt"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:118
msgid "vmware"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:118
msgid "VMware"
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:121
msgid "The `docker_stack <docker_stack_module>`_ module is not included in the ``docker`` defaults group."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:123
msgid "Use the groups with ``module_defaults`` by prefixing the group name with ``group/`` - for example ``group/aws``."
msgstr ""

#: ../../rst/user_guide/playbooks_module_defaults.rst:125
msgid "In a playbook, you can set module defaults for whole groups of modules, such as setting a common AWS region."
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:5
msgid "Interactive input: prompts"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:7
msgid "If you want your playbook to prompt the user for certain input, add a 'vars_prompt' section. Prompting the user for variables lets you avoid recording sensitive data like passwords. In addition to security, prompts support flexibility. For example, if you use one playbook across multiple software releases, you could prompt for the particular release version."
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:12
msgid "Here is a most basic example::"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:31
msgid "The user input is hidden by default but it can be made visible by setting ``private: no``."
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:34
msgid "Prompts for individual ``vars_prompt`` variables will be skipped for any variable that is already defined through the command line ``--extra-vars`` option, or when running from a non-interactive session (such as cron or Ansible Tower). See :ref:`passing_variables_on_the_command_line`."
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:36
msgid "If you have a variable that changes infrequently, you can provide a default value that can be overridden::"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:45
msgid "Encrypting values supplied by ``vars_prompt``"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:47
msgid "You can encrypt the entered value so you can use it, for instance, with the user module to define a password::"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:58
msgid "If you have `Passlib <https://passlib.readthedocs.io/en/stable/>`_ installed, you can use any crypt scheme the library supports:"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:60
msgid "*des_crypt* - DES Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:61
msgid "*bsdi_crypt* - BSDi Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:62
msgid "*bigcrypt* - BigCrypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:63
msgid "*crypt16* - Crypt16"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:64
#: ../../rst/user_guide/playbooks_prompts.rst:87
msgid "*md5_crypt* - MD5 Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:65
#: ../../rst/user_guide/playbooks_prompts.rst:86
msgid "*bcrypt* - BCrypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:66
msgid "*sha1_crypt* - SHA-1 Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:67
msgid "*sun_md5_crypt* - Sun MD5 Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:68
#: ../../rst/user_guide/playbooks_prompts.rst:88
msgid "*sha256_crypt* - SHA-256 Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:69
#: ../../rst/user_guide/playbooks_prompts.rst:89
msgid "*sha512_crypt* - SHA-512 Crypt"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:70
msgid "*apr_md5_crypt* - Apache's MD5-Crypt variant"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:71
msgid "*phpass* - PHPass' Portable Hash"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:72
msgid "*pbkdf2_digest* - Generic PBKDF2 Hashes"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:73
msgid "*cta_pbkdf2_sha1* - Cryptacular's PBKDF2 hash"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:74
msgid "*dlitz_pbkdf2_sha1* - Dwayne Litzenberger's PBKDF2 hash"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:75
msgid "*scram* - SCRAM Hash"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:76
msgid "*bsd_nthash* - FreeBSD's MCF-compatible nthash encoding"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:78
msgid "The only parameters accepted are 'salt' or 'salt_size'. You can use your own salt by defining 'salt', or have one generated automatically using 'salt_size'. By default Ansible generates a salt of size 8."
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:84
msgid "If you do not have Passlib installed, Ansible uses the `crypt <https://docs.python.org/2/library/crypt.html>`_ library as a fallback. Ansible supports at most four crypt schemes, depending on your platform at most the following crypt schemes are supported:"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:95
msgid "Allowing special characters in ``vars_prompt`` values"
msgstr ""

#: ../../rst/user_guide/playbooks_prompts.rst:97
msgid "Some special characters, such as ``{`` and ``%`` can create templating errors. If you need to accept special characters, use the ``unsafe`` option::"
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:5
msgid "Python3 in templates"
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:7
msgid "Ansible uses Jinja2 to leverage Python data types and standard functions in templates and variables. You can use these data types and standard functions to perform a rich set of operations on your data. However, if you use templates, you must be aware of differences between Python versions."
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:11
msgid "These topics help you design templates that work on both Python2 and Python3. They might also help if you are upgrading from Python2 to Python3. Upgrading within Python2 or Python3 does not usually introduce changes that affect Jinja2 templates."
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:16
msgid "Dictionary views"
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:18
msgid "In Python2, the :meth:`dict.keys`, :meth:`dict.values`, and :meth:`dict.items` methods return a list.  Jinja2 returns that to Ansible via a string representation that Ansible can turn back into a list."
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:22
msgid "In Python3, those methods return a :ref:`dictionary view <python3:dict-views>` object. The string representation that Jinja2 returns for dictionary views cannot be parsed back into a list by Ansible.  It is, however, easy to make this portable by using the :func:`list <jinja2:list>` filter whenever using :meth:`dict.keys`, :meth:`dict.values`, or :meth:`dict.items`::"
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:43
msgid "dict.iteritems()"
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:45
msgid "Python2 dictionaries have :meth:`~dict.iterkeys`, :meth:`~dict.itervalues`, and :meth:`~dict.iteritems` methods."
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:47
msgid "Python3 dictionaries do not have these methods. Use :meth:`dict.keys`, :meth:`dict.values`, and :meth:`dict.items` to make your playbooks and templates compatible with both Python2 and Python3::"
msgstr ""

#: ../../rst/user_guide/playbooks_python_version.rst:62
msgid "The :ref:`pb-py-compat-dict-views` entry for information on why the :func:`list filter <jinja2:list>` is necessary here."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:5
msgid "Re-using Ansible artifacts"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:7
msgid "You can write a simple playbook in one very large file, and most users learn the one-file approach first. However, breaking tasks up into different files is an excellent way to organize complex sets of tasks and reuse them. Smaller, more distributed artifacts let you re-use the same variables, tasks, and plays in multiple playbooks to address different use cases. You can use distributed artifacts across multiple parent playbooks or even multiple times within one playbook. For example, you might want to update your customer database as part of several different playbooks. If you put all the tasks related to updating your database in a tasks file, you can re-use them in many playbooks while only maintaining them in one place."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:13
msgid "Creating re-usable files and roles"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:15
msgid "Ansible offers four distributed, re-usable artifacts: variables files, task files, playbooks, and roles."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:17
msgid "A variables file contains only variables."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:18
msgid "A task file contains only tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:19
msgid "A playbook contains at least one play, and may contain variables, tasks, and other content. You can re-use tightly focused playbooks, but you can only re-use them statically, not dynamically."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:20
msgid "A role contains a set of related tasks, variables, defaults, handlers, and even modules or other plugins in a defined file-tree. Unlike variables files, task files, or playbooks, roles can be easily uploaded and shared via Ansible Galaxy. See :ref:`playbooks_reuse_roles` for details about creating and using roles."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:25
msgid "Re-using playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:27
msgid "You can incorporate multiple playbooks into a master playbook. However, you can only use imports to re-use playbooks. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:34
msgid "Importing incorporates playbooks in other playbooks statically. Ansible runs the plays and tasks in each imported playbook in the order they are listed, just as if they had been defined directly in the master playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:37
msgid "Re-using files and roles"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:39
msgid "Ansible offers two ways to re-use files and roles in a playbook: dynamic and static."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:41
msgid "For dynamic re-use, add an ``include_*`` task in the tasks section of a play:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:43
msgid ":ref:`include_role <include_role_module>`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:44
msgid ":ref:`include_tasks <include_tasks_module>`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:45
msgid ":ref:`include_vars <include_vars_module>`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:47
msgid "For static re-use, add an ``import_*`` task in the tasks section of a play:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:49
msgid ":ref:`import_role <import_role_module>`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:50
msgid ":ref:`import_tasks <import_tasks_module>`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:52
msgid "Task include and import statements can be used at arbitrary depth."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:54
msgid "You can still use the bare :ref:`roles <roles_keyword>` keyword at the play level to incorporate a role in a playbook statically. However, the bare :ref:`include <include_module>` keyword, once used for both task files and playbook-level includes, is now deprecated."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:57
msgid "Includes: dynamic re-use"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:59
msgid "Including roles, tasks, or variables adds them to a playbook dynamically. Ansible processes included files and roles as they come up in a playbook, so included tasks can be affected by the results of earlier tasks within the top-level playbook. Included roles and tasks are similar to handlers - they may or may not run, depending on the results of other tasks in the top-level playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:61
msgid "The primary advantage of using ``include_*`` statements is looping. When a loop is used with an include, the included tasks or role will be executed once for each item in the loop."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:63
msgid "You can pass variables into includes. See :ref:`ansible_variable_precedence` for more details on variable inheritance and precedence."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:66
msgid "Imports: static re-use"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:68
msgid "Importing roles, tasks, or playbooks adds them to a playbook statically. Ansible pre-processes imported files and roles before it runs any tasks in a playbook, so imported content is never affected by other tasks within the top-level playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:70
msgid "You can pass variables to imports. You must pass variables if you want to run an imported file more than once in a playbook. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:87
msgid "See :ref:`ansible_variable_precedence` for more details on variable inheritance and precedence."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:92
msgid "Comparing includes and imports: dynamic and static re-use"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:94
msgid "Each approach to re-using distributed Ansible artifacts has advantages and limitations. You may choose dynamic re-use for some playbooks and static re-use for others. Although you can use both dynamic and static re-use in a single playbook, it is best to select one approach per playbook. Mixing static and dynamic re-use can introduce difficult-to-diagnose bugs into your playbooks. This table summarizes the main differences so you can choose the best approach for each playbook you create."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:100
msgid "Include_*"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:100
msgid "Import_*"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:102
msgid "Type of re-use"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:102
msgid "Dynamic"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:102
msgid "Static"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:104
msgid "When processed"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:104
msgid "At runtime, when encountered"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:104
msgid "Pre-processed during playbook parsing"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:106
msgid "Task or play"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:106
msgid "All includes are tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:106
msgid "``import_playbook`` cannot be a task"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:108
msgid "Task options"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:108
msgid "Apply only to include task itself"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:108
msgid "Apply to all child tasks in import"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:110
msgid "Calling from loops"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:110
msgid "Executed once for each loop item"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:110
msgid "Cannot be used in a loop"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:112
msgid "Using ``--list-tags``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:112
msgid "Tags within includes not listed"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:112
msgid "All tags appear with ``--list-tags``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:114
msgid "Using ``--list-tasks``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:114
msgid "Tasks within includes not listed"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:114
msgid "All tasks appear with ``--list-tasks``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:116
msgid "Notifying handlers"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:116
msgid "Cannot trigger handlers within includes"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:116
msgid "Can trigger individual imported handlers"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:118
msgid "Using ``--start-at-task``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:118
msgid "Cannot start at tasks within includes"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:118
msgid "Can start at imported tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:120
msgid "Using inventory variables"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:120
msgid "Can ``include_*: {{ inventory_var }}``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:120
msgid "Cannot ``import_*: {{ inventory_var }}``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:122
msgid "With playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:122
msgid "No ``include_playbook``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:122
msgid "Can import full playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:124
msgid "With variables files"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:124
msgid "Can include variables files"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:124
msgid "Use ``vars_files:`` to import variables"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:129
msgid "Re-using tasks as handlers"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:131
msgid "You can also use includes and imports in the :ref:`handlers` section of a playbook. For instance, if you want to define how to restart Apache, you only have to do that once for all of your playbooks. You might make a ``restarts.yml`` file that looks like:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:146
msgid "You can trigger handlers from either an import or an include, but the procedure is different for each method of re-use. If you include the file, you must notify the include itself, which triggers all the tasks in ``restarts.yml``. If you import the file, you must notify the individual task(s) within ``restarts.yml``. You can mix direct tasks and handlers with included or imported tasks and handlers."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:149
msgid "Triggering included (dynamic) handlers"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:151
msgid "Includes are executed at run-time, so the name of the include exists during play execution, but the included tasks do not exist until the include itself is triggered. To use the ``Restart apache`` task with dynamic re-use, refer to the name of the include itself. This approach triggers all tasks in the included file as handlers. For example, with the task file shown above:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:165
msgid "Triggering imported (static) handlers"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:167
msgid "Imports are processed before the play begins, so the name of the import no longer exists during play execution, but the names of the individual imported tasks do exist. To use the ``Restart apache`` task with static re-use, refer to the name of each task or tasks within the imported file. For example, with the task file shown above:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:184
msgid ":ref:`utilities_modules`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:185
msgid "Documentation of the ``include*`` and ``import*`` modules discussed here."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:187
#: ../../rst/user_guide/playbooks_reuse_includes.rst:16
#: ../../rst/user_guide/playbooks_reuse_roles.rst:472
#: ../../rst/user_guide/playbooks_roles.rst:16
msgid "Review the basic Playbook language features"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:189
#: ../../rst/user_guide/playbooks_reuse_includes.rst:20
msgid "All about variables in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:191
#: ../../rst/user_guide/playbooks_reuse_includes.rst:22
#: ../../rst/user_guide/playbooks_reuse_roles.rst:478
msgid "Conditionals in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:193
#: ../../rst/user_guide/playbooks_reuse_includes.rst:24
#: ../../rst/user_guide/playbooks_reuse_roles.rst:480
msgid "Loops in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:196
#: ../../rst/user_guide/playbooks_reuse_roles.rst:467
#: ../../rst/user_guide/playbooks_roles.rst:13
msgid ":ref:`ansible_galaxy`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:197
#: ../../rst/user_guide/playbooks_roles.rst:14
msgid "How to share roles on galaxy, role management"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:198
#: ../../rst/user_guide/playbooks_reuse_includes.rst:29
#: ../../rst/user_guide/playbooks_reuse_roles.rst:487
msgid "`GitHub Ansible examples <https://github.com/ansible/ansible-examples>`_"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse.rst:199
#: ../../rst/user_guide/playbooks_reuse_includes.rst:30
#: ../../rst/user_guide/playbooks_reuse_roles.rst:488
msgid "Complete playbook files from the GitHub project source"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_includes.rst:6
msgid "Including and importing"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_includes.rst:8
msgid "The content on this page has been moved to :ref:`playbooks_reuse`."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:5
msgid "Roles"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:7
msgid "Roles let you automatically load related vars, files, tasks, handlers, and other Ansible artifacts based on a known file structure. Once you group your content in roles, you can easily reuse them and share them with other users."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:13
msgid "Role directory structure"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:15
msgid "An Ansible role has a defined directory structure with seven main standard directories. You must include at least one of these directories in each role. You can omit any directories the role does not use. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:38
msgid "By default Ansible will look in each directory within a role for a ``main.yml`` file for relevant content (also ``main.yaml`` and ``main``):"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:40
msgid "``tasks/main.yml`` - the main list of tasks that the role executes."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:41
msgid "``handlers/main.yml`` - handlers, which may be used within or outside this role."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:42
msgid "``library/my_module.py`` - modules, which may be used within this role (see :ref:`embedding_modules_and_plugins_in_roles` for more information)."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:43
msgid "``defaults/main.yml`` - default variables for the role (see :ref:`playbooks_variables` for more information). These variables have the lowest priority of any variables available, and can be easily overridden by any other variable, including inventory variables."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:44
msgid "``vars/main.yml`` - other variables for the role (see :ref:`playbooks_variables` for more information)."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:45
msgid "``files/main.yml`` - files that the role deploys."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:46
msgid "``templates/main.yml`` - templates that the role deploys."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:47
msgid "``meta/main.yml`` - metadata for the role, including role dependencies."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:49
msgid "You can add other YAML files in some directories. For example, you can place platform-specific tasks in separate files and refer to them in the ``tasks/main.yml`` file:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:74
msgid "Roles may also include modules and other plugin types in a directory called ``library``. For more information, please refer to :ref:`embedding_modules_and_plugins_in_roles` below."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:79
msgid "Storing and finding roles"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:81
msgid "By default, Ansible looks for roles in two locations:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:83
msgid "in a directory called ``roles/``, relative to the playbook file"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:84
msgid "in ``/etc/ansible/roles``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:86
msgid "If you store your roles in a different location, set the :ref:`roles_path <DEFAULT_ROLES_PATH>` configuration option so Ansible can find your roles. Checking shared roles into a single location makes them easier to use in multiple playbooks. See :ref:`intro_configuration` for details about managing settings in ansible.cfg."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:88
msgid "Alternatively, you can call a role with a fully qualified path:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:98
msgid "Using roles"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:100
msgid "You can use roles in three ways:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:102
msgid "at the play level with the ``roles`` option: This is the classic way of using roles in a play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:103
msgid "at the tasks level with ``include_role``: You can reuse roles dynamically anywhere in the ``tasks`` section of a play using ``include_role``."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:104
msgid "at the tasks level with ``import_role``: You can reuse roles statically anywhere in the ``tasks`` section of a play using ``import_role``."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:109
msgid "Using roles at the play level"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:111
msgid "The classic (original) way to use roles is with the ``roles`` option for a given play:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:121
msgid "When you use the ``roles`` option at the play level, for each role 'x':"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:123
msgid "If roles/x/tasks/main.yml exists, Ansible adds the tasks in that file to the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:124
msgid "If roles/x/handlers/main.yml exists, Ansible adds the handlers in that file to the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:125
msgid "If roles/x/vars/main.yml exists, Ansible adds the variables in that file to the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:126
msgid "If roles/x/defaults/main.yml exists, Ansible adds the variables in that file to the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:127
msgid "If roles/x/meta/main.yml exists, Ansible adds any role dependencies in that file to the list of roles."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:128
msgid "Any copy, script, template or include tasks (in the role) can reference files in roles/x/{files,templates,tasks}/ (dir depends on task) without having to path them relatively or absolutely."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:130
msgid "When you use the ``roles`` option at the play level, Ansible treats the roles as static imports and processes them during playbook parsing. Ansible executes your playbook in this order:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:132
msgid "Any ``pre_tasks`` defined in the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:133
msgid "Any handlers triggered by pre_tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:134
msgid "Each role listed in ``roles:``, in the order listed. Any role dependencies defined in the role's ``meta/main.yml`` run first, subject to tag filtering and conditionals. See :ref:`role_dependencies` for more details."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:135
msgid "Any ``tasks`` defined in the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:136
msgid "Any handlers triggered by the roles or tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:137
msgid "Any ``post_tasks`` defined in the play."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:138
msgid "Any handlers triggered by post_tasks."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:141
msgid "If using tags with tasks in a role, be sure to also tag your pre_tasks, post_tasks, and role dependencies and pass those along as well, especially if the pre/post tasks and role dependencies are used for monitoring outage window control or load balancing. See :ref:`tags` for details on adding and using tags."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:143
msgid "You can pass other keywords to the ``roles`` option:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:162
msgid "When you add a tag to the ``role`` option, Ansible applies the tag to ALL tasks within the role."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:164
msgid "When using ``vars:`` within the ``roles:`` section of a playbook, the variables are added to the play variables, making them available to all tasks within the play before and after the role. This behavior can be changed by :ref:`DEFAULT_PRIVATE_ROLE_VARS`."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:167
msgid "Including roles: dynamic reuse"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:169
msgid "You can reuse roles dynamically anywhere in the ``tasks`` section of a play using ``include_role``. While roles added in a ``roles`` section run before any other tasks in a playbook, included roles run in the order they are defined. If there are other tasks before an ``include_role`` task, the other tasks will run first."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:171
msgid "To include a role:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:190
msgid "You can pass other keywords, including variables and tags, when including roles:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:206
msgid "When you add a :ref:`tag <tags>` to an ``include_role`` task, Ansible applies the tag `only` to the include itself. This means you can pass ``--tags`` to run only selected tasks from the role, if those tasks themselves have the same tag as the include statement. See :ref:`selective_reuse` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:208
msgid "You can conditionally include a role:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:221
msgid "Importing roles: static reuse"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:223
msgid "You can reuse roles statically anywhere in the ``tasks`` section of a play using ``import_role``. The behavior is the same as using the ``roles`` keyword. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:242
msgid "You can pass other keywords, including variables and tags, when importing roles:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:257
msgid "When you add a tag to an ``import_role`` statement, Ansible applies the tag to `all` tasks within the role. See :ref:`tag_inheritance` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:262
msgid "Running a role multiple times in one playbook"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:264
msgid "Ansible only executes each role once, even if you define it multiple times, unless the parameters defined on the role are different for each definition. For example, Ansible only runs the role ``foo`` once in a play like this:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:275
msgid "You have two options to force Ansible to run a role more than once."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:278
msgid "Passing different parameters"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:280
msgid "You can pass different parameters in each role definition as:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:290
msgid "or"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:304
msgid "In this example, because each role definition has different parameters, Ansible runs ``foo`` twice."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:307
msgid "Using ``allow_duplicates: true``"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:309
msgid "Add ``allow_duplicates: true`` to the ``meta/main.yml`` file for the role:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:324
msgid "In this example, Ansible runs ``foo`` twice because we have explicitly enabled it to do so."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:329
msgid "Using role dependencies"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:331
msgid "Role dependencies let you automatically pull in other roles when using a role. Ansible does not execute role dependencies when you include or import a role. You must use the ``roles`` keyword if you want Ansible to execute role dependencies."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:333
msgid "Role dependencies are stored in the ``meta/main.yml`` file within the role directory. This file should contain a list of roles and parameters to insert before the specified role. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:351
msgid "Ansible always executes role dependencies before the role that includes them. Ansible executes recursive role dependencies as well. If one role depends on a second role, and the second role depends on a third role, Ansible executes the third role, then the second role, then the first role."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:354
msgid "Running role dependencies multiple times in one playbook"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:356
msgid "Ansible treats duplicate role dependencies like duplicate roles listed under ``roles:``: Ansible only executes role dependencies once, even if defined multiple times, unless the parameters, tags, or when clause defined on the role are different for each definition. If two roles in a playbook both list a third role as a dependency, Ansible only runs that role dependency once, unless you pass different parameters, tags, when clause, or use ``allow_duplicates: true`` in the dependent (third) role. See :ref:`Galaxy role dependencies <galaxy_dependencies>` for more details."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:358
msgid "For example, a role named ``car`` depends on a role named ``wheel`` as follows:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:377
msgid "And the ``wheel`` role depends on two roles: ``tire`` and ``brake``. The ``meta/main.yml`` for wheel would then contain the following:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:386
msgid "And the ``meta/main.yml`` for ``tire`` and ``brake`` would contain the following:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:393
msgid "The resulting order of execution would be as follows:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:406
msgid "To use ``allow_duplicates: true`` with role dependencies, you must specify it for the dependent role, not for the parent role. In the example above, ``allow_duplicates: true`` appears in the ``meta/main.yml`` of the ``tire`` and ``brake`` roles. The ``wheel`` role does not require ``allow_duplicates: true``, because each instance defined by ``car`` uses different parameter values."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:409
msgid "See :ref:`playbooks_variables` for details on how Ansible chooses among variable values defined in different places (variable inheritance and scope)."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:414
msgid "Embedding modules and plugins in roles"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:416
msgid "If you write a custom module (see :ref:`developing_modules`) or a plugin (see :ref:`developing_plugins`), you might wish to distribute it as part of a role. For example, if you write a module that helps configure your company's internal software, and you want other people in your organization to use this module, but you do not want to tell everyone how to configure their Ansible library path, you can include the module in your internal_config role."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:418
msgid "To add a module or a plugin to a role: Alongside the 'tasks' and 'handlers' structure of a role, add a directory named 'library' and then include the module directly inside the 'library' directory."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:421
msgid "Assuming you had this:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:431
msgid "The module will be usable in the role itself, as well as any roles that are called *after* this role, as follows:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:442
msgid "If necessary, you can also embed a module in a role to modify a module in Ansible's core distribution. For example, you can use the development version of a particular module before it is released in production releases by copying the module and embedding the copy in a role. Use this approach with caution, as API signatures may change in core components, and this workaround is not guaranteed to work."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:444
msgid "The same mechanism can be used to embed and distribute plugins in a role, using the same schema. For example, for a filter plugin:"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:454
msgid "These filters can then be used in a Jinja template in any role called after 'my_custom_filter'."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:457
msgid "Sharing roles: Ansible Galaxy"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:459
msgid "`Ansible Galaxy <https://galaxy.ansible.com>`_ is a free site for finding, downloading, rating, and reviewing all kinds of community-developed Ansible roles and can be a great way to get a jumpstart on your automation projects."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:461
msgid "The client ``ansible-galaxy`` is included in Ansible. The Galaxy client allows you to download roles from Ansible Galaxy, and also provides an excellent default framework for creating your own roles."
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:463
msgid "Read the `Ansible Galaxy documentation <https://galaxy.ansible.com/docs/>`_ page for more information"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:468
msgid "How to create new roles, share roles on Galaxy, role management"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:476
msgid "Variables in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:481
msgid ":ref:`tags`"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:482
msgid "Using tags to select or skip roles/tasks in long playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_reuse_roles.rst:486
msgid "Extending Ansible by writing your own modules"
msgstr ""

#: ../../rst/user_guide/playbooks_roles.rst:4
msgid "Playbook Roles and Include Statements"
msgstr ""

#: ../../rst/user_guide/playbooks_roles.rst:9
msgid "The documentation regarding roles and includes for playbooks have moved. Their new location is here: :ref:`playbooks_reuse`. Please update any links you may have made directly to this page."
msgstr ""

#: ../../rst/user_guide/playbooks_roles.rst:17
msgid ":ref:`playbooks_reuse`"
msgstr ""

#: ../../rst/user_guide/playbooks_roles.rst:18
msgid "Creating reusable Playbooks."
msgstr ""

#: ../../rst/user_guide/playbooks_special_topics.rst:6
msgid "Advanced playbooks features"
msgstr ""

#: ../../rst/user_guide/playbooks_special_topics.rst:8
msgid "This page is obsolete. Refer to the :ref:`main User Guide index page <user_guide_index>` for links to all playbook-related topics. Please update any links you may have made directly to this page."
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:5
msgid "Executing playbooks for troubleshooting"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:7
msgid "When you are testing new plays or debugging playbooks, you may need to run the same play multiple times. To make this more efficient, Ansible offers two alternative ways to execute a playbook: start-at-task and step mode."
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:12
msgid "start-at-task"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:14
msgid "To start executing your playbook at a particular task (usually the task that failed on the previous run), use the ``--start-at-task`` option::"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:18
msgid "In this example, Ansible starts executing your playbook at a task named \"install packages\". This feature does not work with tasks inside dynamically re-used roles or tasks (``include_*``), see :ref:`dynamic_vs_static`."
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:23
msgid "Step mode"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:25
msgid "To execute a playbook interactively, use ``--step``::"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:29
msgid "With this option, Ansible stops on each task, and asks if it should execute that task. For example, if you have a task called \"configure ssh\", the playbook run will stop and ask::"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:33
msgid "Answer \"y\" to execute the task, answer \"n\" to skip the task, and answer \"c\" to exit step mode, executing all remaining tasks without asking."
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:39
msgid ":ref:`playbook_debugger`"
msgstr ""

#: ../../rst/user_guide/playbooks_startnstep.rst:40
msgid "Using the Ansible debugger"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:4
msgid "Controlling playbook execution: strategies and more"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:6
msgid "By default, Ansible runs each task on all hosts affected by a play before starting the next task on any host, using 5 forks. If you want to change this default behavior, you can use a different strategy plugin, change the number of forks, or apply one of several keywords like ``serial``."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:12
msgid "Selecting a strategy"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:13
msgid "The default behavior described above is the :ref:`linear strategy<linear_strategy>`. Ansible offers other strategies, including the :ref:`debug strategy<debug_strategy>` (see also  :ref:`playbook_debugger`) and the :ref:`free strategy<free_strategy>`, which allows each host to run until the end of the play as fast as it can::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:20
msgid "You can select a different strategy for each play as shown above, or set your preferred strategy globally in ``ansible.cfg``, under the ``defaults`` stanza::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:25
msgid "All strategies are implemented as :ref:`strategy plugins<strategy_plugins>`. Please review the documentation for each strategy plugin for details on how it works."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:28
msgid "Setting the number of forks"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:29
msgid "If you have the processing power available and want to use more forks, you can set the number in ``ansible.cfg``::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:34
msgid "or pass it on the command line: `ansible-playbook -f 30 my_playbook.yml`."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:37
msgid "Using keywords to control execution"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:39
msgid "In addition to strategies, several :ref:`keywords<playbook_keywords>` also affect play execution. You can set a number, a percentage, or a list of numbers of hosts you want to manage at a time with ``serial``. Ansible completes the play on the specified number or percentage of hosts before starting the next batch of hosts. You can restrict the number of workers allotted to a block or task with ``throttle``. You can control how Ansible selects the next host in a group to execute against with ``order``. You can run a task on a single host with ``run_once``. These keywords are not strategies. They are directives or options applied to a play, block, or task."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:44
msgid "Setting the batch size with ``serial``"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:46
msgid "By default, Ansible runs in parallel against all the hosts in the :ref:`pattern <intro_patterns>` you set in the ``hosts:`` field of each play. If you want to manage only a few machines at a time, for example during a rolling update, you can define how many hosts Ansible should manage at a single time using the ``serial`` keyword::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:60
msgid "In the above example, if we had 6 hosts in the group 'webservers', Ansible would execute the play completely (both tasks) on 3 of the hosts before moving on to the next 3 hosts::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:96
msgid "You can also specify a percentage with the ``serial`` keyword. Ansible applies the percentage to the total number of hosts in a play to determine the number of hosts per pass::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:103
msgid "If the number of hosts does not divide equally into the number of passes, the final pass contains the remainder. In this example, if you had 20 hosts in the webservers group, the first batch would contain 6 hosts, the second batch would contain 6 hosts, the third batch would contain 6 hosts, and the last batch would contain 2 hosts."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:105
msgid "You can also specify batch sizes as a list. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:115
msgid "In the above example, the first batch would contain a single host, the next would contain 5 hosts, and (if there are any hosts left), every following batch would contain either 10 hosts or all the remaining hosts, if fewer than 10 hosts remained."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:117
msgid "You can list multiple batch sizes as percentages::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:127
msgid "You can also mix and match the values::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:138
msgid "No matter how small the percentage, the number of hosts per pass will always be 1 or greater."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:141
msgid "Restricting execution with ``throttle``"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:143
msgid "The ``throttle`` keyword limits the number of workers for a particular task. It can be set at the block and task level. Use ``throttle`` to restrict tasks that may be CPU-intensive or interact with a rate-limiting API::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:149
msgid "If you have already restricted the number of forks or the number of machines to execute against in parallel, you can reduce the number of workers with ``throttle``, but you cannot increase it. In other words, to have an effect, your ``throttle`` setting must be lower than your ``forks`` or ``serial`` setting if you are using them together."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:152
msgid "Ordering execution based on inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:154
msgid "The ``order`` keyword controls the order in which hosts are run. Possible values for order are:"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:156
msgid "inventory:"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:157
msgid "(default) The order provided in the inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:158
msgid "reverse_inventory:"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:159
msgid "The reverse of the order provided by the inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:160
msgid "sorted:"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:161
msgid "Sorted alphabetically sorted by name"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:162
msgid "reverse_sorted:"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:163
msgid "Sorted by name in reverse alphabetical order"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:165
msgid "shuffle:"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:165
msgid "Randomly ordered on each run"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:167
msgid "Other keywords that affect play execution include ``ignore_errors``, ``ignore_unreachable``, and ``any_errors_fatal``. These options are documented in :ref:`playbooks_error_handling`."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:172
msgid "Running on a single machine with ``run_once``"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:174
msgid "If you want a task to run only on the first host in your batch of hosts, set ``run_once`` to true on that task::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:188
msgid "Ansible executes this task on the first host in the current batch and applies all results and facts to all the hosts in the same batch. This approach is similar to applying a conditional to a task such as::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:193
msgid "However, with ``run_once``, the results are applied to all the hosts. To run the task on a specific host, instead of the first host in the batch, delegate the task::"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:199
msgid "As always with :ref:`delegation <playbooks_delegation>`, the action will be executed on the delegated host, but the information is still that of the original host in the task."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:202
msgid "When used together with ``serial``, tasks marked as ``run_once`` will be run on one host in *each* serial batch. If the task must run only once regardless of ``serial`` mode, use :code:`when: inventory_hostname == ansible_play_hosts_all[0]` construct."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:206
msgid "Any conditional (in other words, `when:`) will use the variables of the 'first host' to decide if the task runs or not, no other hosts will be tested."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:209
msgid "If you want to avoid the default behavior of setting the fact for all hosts, set ``delegate_facts: True`` for the specific task or block."
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:215
msgid ":ref:`playbooks_delegation`"
msgstr ""

#: ../../rst/user_guide/playbooks_strategies.rst:216
msgid "Running tasks on or assigning facts to specific machines"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:5
msgid "Tags"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:7
msgid "If you have a large playbook, it may be useful to run only specific parts of it instead of running the entire playbook. You can do this with Ansible tags. Using tags to execute or skip selected tasks is a two-step process:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:9
msgid "Add tags to your tasks, either individually or with tag inheritance from a block, play, role, or import."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:10
msgid "Select or skip tags when you run your playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:16
msgid "Adding tags with the tags keyword"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:18
msgid "You can add tags to a single task or include. You can also add tags to multiple tasks by defining them at the level of a block, play, role, or import. The keyword ``tags`` addresses all these use cases. The ``tags`` keyword always defines tags and adds them to tasks; it does not select or skip tasks for execution. You can only select or skip tasks based on tags at the command line when you run a playbook. See :ref:`using_tags` for more details."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:21
msgid "Adding tags to individual tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:23
msgid "At the simplest level, you can apply one or more tags to an individual task. You can add tags to tasks in playbooks, in task files, or within a role. Here is an example that tags two tasks with different tags:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:45
msgid "You can apply the same tag to more than one individual task. This example tags several tasks with the same tag, \"ntp\":"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:81
msgid "If you ran these four tasks in a playbook with ``--tags ntp``, Ansible would run the three tasks tagged ``ntp`` and skip the one task that does not have that tag."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:86
msgid "Adding tags to includes"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:88
msgid "You can apply tags to dynamic includes in a playbook. As with tags on an individual task, tags on an ``include_*`` task apply only to the include itself, not to any tasks within the included file or role. If you add ``mytag`` to a dynamic include, then run that playbook with ``--tags mytag``, Ansible runs the include itself, runs any tasks within the included file or role tagged with ``mytag``, and skips any tasks within the included file or role without that tag. See :ref:`selective_reuse` for more details."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:90
msgid "You add tags to includes the same way you add tags to any other task:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:101
msgid "You can add a tag only to the dynamic include of a role. In this example, the ``foo`` tag will `not` apply to tasks inside the ``bar`` role:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:114
msgid "With plays, blocks, the ``role`` keyword, and static imports, Ansible applies tag inheritance, adding the tags you define to every task inside the play, block, role, or imported file. However, tag inheritance does *not* apply to dynamic re-use with ``include_role`` and ``include_tasks``. With dynamic re-use (includes), the tags you define apply only to the include itself. If you need tag inheritance, use a static import. If you cannot use an import because the rest of your playbook uses includes, see :ref:`apply_keyword` for ways to work around this behavior."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:119
msgid "Tag inheritance: adding tags to multiple tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:121
msgid "If you want to apply the same tag or tags to multiple tasks without adding a ``tags`` line to every task, you can define the tags at the level of your play or block, or when you add a role or import a file. Ansible applies the tags down the dependency chain to all child tasks. With roles and imports, Ansible appends the tags set by the ``roles`` section or import to any tags set on individual tasks or blocks within the role or imported file. This is called tag inheritance. Tag inheritance is convenient, because you do not have to tag every task. However, the tags still apply to the tasks individually."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:124
msgid "Adding tags to blocks"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:126
msgid "If you want to apply a tag to many, but not all, of the tasks in your play, use a :ref:`block <playbooks_blocks>` and define the tags at that level. For example, we could edit the NTP example shown above to use a block:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:162
msgid "Adding tags to plays"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:164
msgid "If all the tasks in a play should get the same tag, you can add the tag at the level of the play. For example, if you had a play with only the NTP tasks, you could tag the entire play:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:195
msgid "Adding tags to roles"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:197
msgid "There are three ways to add tags to roles:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:199
msgid "Add the same tag or tags to all tasks in the role by setting tags under ``roles``. See examples in this section."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:200
msgid "Add the same tag or tags to all tasks in the role by setting tags on a static ``import_role`` in your playbook. See examples in :ref:`tags_on_imports`."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:201
msgid "Add a tag or tags to to individual tasks or blocks within the role itself. This is the only approach that allows you to select or skip some tasks within the role. To select or skip tasks within the role, you must have tags set on individual tasks or blocks, use the dynamic ``include_role`` in your playbook, and add the same tag or tags to the include. When you use this approach, and then run your playbook with ``--tags foo``, Ansible runs the include itself plus any tasks in the role that also have the tag ``foo``. See :ref:`tags_on_includes` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:203
msgid "When you incorporate a role in your playbook statically with the ``roles`` keyword, Ansible adds any tags you define to all the tasks in the role. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:213
msgid "or:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:230
msgid "Adding tags to imports"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:232
msgid "You can also apply a tag or tags to all the tasks imported by the static ``import_role`` and ``import_tasks`` statements:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:253
msgid "Tag inheritance for includes: blocks and the ``apply`` keyword"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:255
msgid "By default, Ansible does not apply :ref:`tag inheritance <tag_inheritance>` to dynamic re-use with ``include_role`` and ``include_tasks``. If you add tags to an include, they apply only to the include itself, not to any tasks in the included file or role. This allows you to execute selected tasks within a role or task file - see :ref:`selective_reuse` when you run your playbook."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:257
msgid "If you want tag inheritance, you probably want to use imports. However, using both includes and imports in a single playbook can lead to difficult-to-diagnose bugs. For this reason, if your playbook uses ``include_*`` to re-use roles or tasks, and you need tag inheritance on one include, Ansible offers two workarounds. You can use the ``apply`` keyword:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:270
msgid "Or you can use a block:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:282
msgid "Special tags: always and never"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:284
msgid "Ansible reserves two tag names for special behavior: always and never. If you assign the ``always`` tag to a task or play, Ansible will always run that task or play, unless you specifically skip it (``--skip-tags always``)."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:286
#: ../../rst/user_guide/playbooks_tags.rst:312
msgid "For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:304
msgid "Fact gathering is tagged with 'always' by default. It is only skipped if you apply a tag and then use a different tag in ``--tags`` or the same tag in ``--skip-tags``."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:310
msgid "If you assign the ``never`` tag to a task or play, Ansible will skip that task or play unless you specifically request it (``--tags never``)."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:322
msgid "The rarely-used debug task in the example above only runs when you specifically request the ``debug`` or ``never`` tags."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:327
msgid "Selecting or skipping tags when you run a playbook"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:329
msgid "Once you have added tags to your tasks, includes, blocks, plays, roles, and imports, you can selectively execute or skip tasks based on their tags when you run :ref:`ansible-playbook`. Ansible runs or skips all tasks with tags that match the tags you pass at the command line. If you have added a tag at the block or play level, with ``roles``, or with an import, that tag applies to every task within the block, play, role, or imported role or file. If you have a role with lots of tags and you want to call subsets of the role at different times, either :ref:`use it with dynamic includes <selective_reuse>`, or split the role into multiple roles."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:331
msgid ":ref:`ansible-playbook` offers five tag-related command-line options:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:333
msgid "``--tags all`` - run all tasks, ignore tags (default behavior)"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:334
msgid "``--tags [tag1, tag2]`` - run only tasks with the tags ``tag1`` and ``tag2``"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:335
msgid "``--skip-tags [tag3, tag4]`` - run all tasks except those with the tags ``tag3`` and ``tag4``"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:336
msgid "``--tags tagged`` - run only tasks with at least one tag"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:337
msgid "``--tags untagged`` - run only tasks with no tags"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:339
msgid "For example, to run only tasks and blocks tagged ``configuration`` and ``packages`` in a very long playbook:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:345
msgid "To run all tasks except those tagged ``packages``:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:352
msgid "Previewing the results of using tags"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:354
msgid "When you run a role or playbook, you might not know or remember which tasks have which tags, or which tags exist at all. Ansible offers two command-line flags for :ref:`ansible-playbook` that help you manage tagged playbooks:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:356
msgid "``--list-tags`` - generate a list of available tags"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:357
msgid "``--list-tasks`` - when used with ``--tags tagname`` or ``--skip-tags tagname``, generate a preview of tagged tasks"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:359
msgid "For example, if you do not know whether the tag for configuration tasks is ``config`` or ``conf`` in a playbook, role, or tasks file, you can display all available tags without running any tasks:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:365
msgid "If you do not know which tasks have the tags ``configuration`` and ``packages``, you can pass those tags and add ``--list-tasks``. Ansible lists the tasks but does not execute any of them."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:371
msgid "These command-line flags have one limitation: they cannot show tags or tasks within dynamically included files or roles. See :ref:`dynamic_vs_static` for more information on differences between static imports and dynamic includes."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:376
msgid "Selectively running tagged tasks in re-usable files"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:378
msgid "If you have a role or a tasks file with tags defined at the task or block level, you can selectively run or skip those tagged tasks in a playbook if you use a dynamic include instead of a static import. You must use the same tag on the included tasks and on the include statement itself. For example you might create a file with some tagged and some untagged tasks:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:401
msgid "And you might include the tasks file above in a playbook:"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:413
msgid "When you run the playbook with ``ansible-playbook -i hosts myplaybook.yml --tags \"mytag\"``, Ansible skips the task with no tags, runs the tagged individual task, and runs the two tasks in the block."
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:416
msgid "Configuring tags globally"
msgstr ""

#: ../../rst/user_guide/playbooks_tags.rst:418
msgid "If you run or skip certain tags by default, you can use the :ref:`TAGS_RUN` and :ref:`TAGS_SKIP` options in Ansible configuration to set those defaults."
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:5
msgid "Templating (Jinja2)"
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:7
msgid "Ansible uses Jinja2 templating to enable dynamic expressions and access to variables. Ansible includes a lot of specialized filters and tests for templating. You can use all the :ref:`standard filters and tests <jinja2:builtin-filters>` included in Jinja2 as well. Ansible also offers a new plugin type: :ref:`lookup_plugins`."
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:9
msgid "All templating happens on the Ansible controller **before** the task is sent and executed on the target machine. This approach minimizes the package requirements on the target (jinja2 is only required on the controller). It also limits the amount of data Ansible passes to the target machine. Ansible parses templates on the controller and passes only the information needed for each task to the target machine, instead of passing all the data on the controller and parsing it on the target."
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:25
msgid "Get the current time"
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:29
msgid "The ``now()`` Jinja2 function retrieves a Python datetime object or a string representation for the current time."
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:31
msgid "The ``now()`` function supports 2 arguments:"
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:34
msgid "utc"
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:34
msgid "Specify ``True`` to get the current time in UTC. Defaults to ``False``."
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:38
msgid "fmt"
msgstr ""

#: ../../rst/user_guide/playbooks_templating.rst:37
msgid "Accepts a `strftime <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_ string that returns a formatted date time string."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:5
msgid "Tests"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:7
msgid "`Tests <http://jinja.pocoo.org/docs/dev/templates/#tests>`_ in Jinja are a way of evaluating template expressions and returning True or False. Jinja ships with many of these. See `builtin tests`_ in the official Jinja template documentation."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:9
msgid "The main difference between tests and filters are that Jinja tests are used for comparisons, whereas filters are used for data manipulation, and have different applications in jinja. Tests can also be used in list processing filters, like ``map()`` and ``select()`` to choose items in the list."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:11
msgid "Like all templating, tests always execute on the Ansible controller, **not** on the target of a task, as they test local data."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:13
msgid "In addition to those Jinja2 tests, Ansible supplies a few more and users can easily create their own."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:21
msgid "Test syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:23
msgid "`Test syntax <http://jinja.pocoo.org/docs/dev/templates/#tests>`_ varies from `filter syntax <http://jinja.pocoo.org/docs/dev/templates/#filters>`_ (``variable | filter``). Historically Ansible has registered tests as both jinja tests and jinja filters, allowing for them to be referenced using filter syntax."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:25
msgid "As of Ansible 2.5, using a jinja test as a filter will generate a warning."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:27
msgid "The syntax for using a jinja test is as follows::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:31
msgid "Such as::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:38
msgid "Testing strings"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:40
msgid "To match strings against a substring or a regular expression, use the ``match``, ``search`` or ``regex`` tests::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:62
msgid "``match`` succeeds if it finds the pattern at the beginning of the string, while ``search`` succeeds if it finds the pattern anywhere within string. By default, ``regex`` works like ``search``, but ``regex`` can be configured to perform other tests as well, by passing the ``match_type`` keyword argument. In particular, ``match_type`` determines the ``re`` method that gets used to perform the search. The full list can be found in the relevant Python documentation `here <https://docs.python.org/3/library/re.html#regular-expression-objects>`_."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:64
msgid "All of the string tests also take optional ``ignorecase`` and ``multiline`` arguments. These correspond to ``re.I`` and ``re.M`` from Python's ``re`` library, respectively."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:69
msgid "Vault"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:73
msgid "You can test whether a variable is an inline single vault encrypted value using the ``vault_encrypted`` test."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:93
msgid "Testing truthiness"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:97
msgid "As of Ansible 2.10, you can now perform Python like truthy and falsy checks."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:113
msgid "Additionally, the ``truthy`` and ``falsy`` tests accept an optional parameter called ``convert_bool`` that will attempt to convert boolean indicators to actual booleans."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:133
msgid "Comparing versions"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:137
msgid "In 2.5 ``version_compare`` was renamed to ``version``"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:139
msgid "To compare a version number, such as checking if the ``ansible_facts['distribution_version']`` version is greater than or equal to '12.04', you can use the ``version`` test."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:142
msgid "The ``version`` test can also be used to evaluate the ``ansible_facts['distribution_version']``::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:146
msgid "If ``ansible_facts['distribution_version']`` is greater than or equal to 12.04, this test returns True, otherwise False."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:148
msgid "The ``version`` test accepts the following operators::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:152
msgid "This test also accepts a 3rd parameter, ``strict`` which defines if strict version parsing as defined by ``distutils.version.StrictVersion`` should be used.  The default is ``False`` (using ``distutils.version.LooseVersion``), ``True`` enables strict version parsing::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:156
msgid "As of Ansible 2.11 the ``version`` test accepts a ``version_type`` parameter which is mutually exclusive with ``strict``, and accepts the following values::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:160
msgid "Using ``version_type`` to compare a semantic version would be achieved like the following::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:164
msgid "When using ``version`` in a playbook or role, don't use ``{{ }}`` as described in the `FAQ <https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#when-should-i-use-also-how-to-interpolate-variables-or-dynamic-variable-names>`_::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:177
msgid "Set theory tests"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:181
msgid "In 2.5 ``issubset`` and ``issuperset`` were renamed to ``subset`` and ``superset``"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:183
msgid "To see if a list includes or is included by another list, you can use 'subset' and 'superset'::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:200
msgid "Testing if a list contains a value"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:204
msgid "Ansible includes a ``contains`` test which operates similarly, but in reverse of the Jinja2 provided ``in`` test. The ``contains`` test is designed to work with the ``select``, ``reject``, ``selectattr``, and ``rejectattr`` filters::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:236
msgid "Testing if a list value is True"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:238
msgid "You can use `any` and `all` to check if any or all elements in a list are true or not::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:261
msgid "Testing paths"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:263
msgid "In 2.5 the following tests were renamed to remove the ``is_`` prefix"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:265
msgid "The following tests can provide information about a path on the controller::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:296
msgid "Testing size formats"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:298
msgid "The ``human_readable`` and ``human_to_bytes`` functions let you test your playbooks to make sure you are using the right size format in your tasks, and that you provide Byte format to computers and human-readable format to people."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:303
msgid "Human readable"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:305
msgid "Asserts whether the given string is human readable or not."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:324
msgid "Human to bytes"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:326
msgid "Returns the given string in the Bytes format."
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:350
msgid "Testing task results"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:352
msgid "The following tasks are illustrative of the tests meant to check the status of tasks::"
msgstr ""

#: ../../rst/user_guide/playbooks_tests.rst:381
msgid "From 2.1, you can also use success, failure, change, and skip so that the grammar matches, for those who need to be strict about it."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:5
msgid "Using Variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:7
msgid "Ansible uses variables to manage differences between systems. With Ansible, you can execute tasks and playbooks on multiple different systems with a single command. To represent the variations among those different systems, you can create variables with standard YAML syntax, including lists and dictionaries. You can define these variables in your playbooks, in your :ref:`inventory <intro_inventory>`, in re-usable :ref:`files <playbooks_reuse>` or :ref:`roles <playbooks_reuse_roles>`, or at the command line. You can also create variables during a playbook run by registering the return value or values of a task as a new variable."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:9
msgid "After you create variables, either by defining them in a file, passing them at the command line, or registering the return value or values of a task as a new variable, you can use those variables in module arguments, in :ref:`conditional \"when\" statements <playbooks_conditionals>`, in :ref:`templates <playbooks_templating>`, and in :ref:`loops <playbooks_loops>`. The `ansible-examples github repository <https://github.com/ansible/ansible-examples>`_ contains many examples of using variables in Ansible."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:11
msgid "Once you understand the concepts and examples on this page, read about :ref:`Ansible facts <vars_and_facts>`, which are variables you retrieve from remote systems."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:19
msgid "Creating valid variable names"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:21
msgid "Not all strings are valid Ansible variable names. A variable name can only include letters, numbers, and underscores. `Python keywords`_ or :ref:`playbook keywords<playbook_keywords>` are not valid variable names. A variable name cannot begin with a number."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:23
msgid "Variable names can begin with an underscore. In many programming languages, variables that begin with an underscore are private. This is not true in Ansible. Variables that begin with an underscore are treated exactly the same as any other variable. Do not rely on this convention for privacy or security."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:25
msgid "This table gives examples of valid and invalid variable names:"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:31
msgid "Valid variable names"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:31
msgid "Not valid"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:33
msgid "``foo``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:33
msgid "``*foo``, `Python keywords`_ such as ``async`` and ``lambda``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:35
msgid "``foo_env``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:35
msgid ":ref:`playbook keywords<playbook_keywords>` such as ``environment``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:37
msgid "``foo_port``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:37
msgid "``foo-port``, ``foo port``, ``foo.port``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:39
msgid "``foo5``, ``_foo``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:39
msgid "``5foo``, ``12``"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:45
msgid "Simple variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:47
msgid "Simple variables combine a variable name with a single value. You can use this syntax (and the syntax for lists and dictionaries shown below) in a variety of places. For details about setting variables in inventory, in playbooks, in reusable files, in roles, or at the command line, see :ref:`setting_variables`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:50
msgid "Defining simple variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:52
msgid "You can define a simple variable using standard YAML syntax. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:57
msgid "Referencing simple variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:59
msgid "After you define a variable, use Jinja2 syntax to reference it. Jinja2 variables use double curly braces. For example, the expression ``My amp goes to {{ max_amp_value }}`` demonstrates the most basic form of variable substitution. You can use Jinja2 syntax in playbooks. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:65
msgid "In this example, the variable defines the location of a file, which can vary from one system to another."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:69
msgid "Ansible allows Jinja2 loops and conditionals in :ref:`templates <playbooks_templating>` but not in playbooks. You cannot create a loop of tasks. Ansible playbooks are pure machine-parseable YAML."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:74
msgid "When to quote variables (a YAML gotcha)"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:76
msgid "If you start a value with ``{{ foo }}``, you must quote the whole expression to create valid YAML syntax. If you do not quote the whole expression, the YAML parser cannot interpret the syntax - it might be a variable or it might be the start of a YAML dictionary. For guidance on writing YAML, see the :ref:`yaml_syntax` documentation."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:78
msgid "If you use a variable without quotes like this::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:84
msgid "You will see: ``ERROR! Syntax Error while loading YAML.`` If you add quotes, Ansible works correctly::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:93
msgid "List variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:95
msgid "A list variable combines a variable name with multiple values. The multiple values can be stored as an itemized list or in square brackets ``[]``, separated with commas."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:98
msgid "Defining variables as lists"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:100
msgid "You can define variables with multiple values using YAML lists. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:108
msgid "Referencing list variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:110
msgid "When you use variables defined as a list (also called an array), you can use individual, specific fields from that list. The first item in a list is item 0, the second item is item 1. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:114
msgid "The value of this expression would be \"northeast\"."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:119
msgid "Dictionary variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:121
msgid "A dictionary stores the data in key-value pairs. Usually, dictionaries are used to store related data, such as the information contained in an ID or a user profile."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:124
msgid "Defining variables as key:value dictionaries"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:126
msgid "You can define more complex variables using YAML dictionaries. A YAML dictionary maps keys to values.  For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:133
msgid "Referencing key:value dictionary variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:135
msgid "When you use variables defined as a key:value dictionary (also called a hash), you can use individual, specific fields from that dictionary using either bracket notation or dot notation::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:140
msgid "Both of these examples reference the same value (\"one\"). Bracket notation always works. Dot notation can cause problems because some keys collide with attributes and methods of python dictionaries. Use bracket notation if you use keys which start and end with two underscores (which are reserved for special meanings in python) or are any of the known public attributes:"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:142
msgid "``add``, ``append``, ``as_integer_ratio``, ``bit_length``, ``capitalize``, ``center``, ``clear``, ``conjugate``, ``copy``, ``count``, ``decode``, ``denominator``, ``difference``, ``difference_update``, ``discard``, ``encode``, ``endswith``, ``expandtabs``, ``extend``, ``find``, ``format``, ``fromhex``, ``fromkeys``, ``get``, ``has_key``, ``hex``, ``imag``, ``index``, ``insert``, ``intersection``, ``intersection_update``, ``isalnum``, ``isalpha``, ``isdecimal``, ``isdigit``, ``isdisjoint``, ``is_integer``, ``islower``, ``isnumeric``, ``isspace``, ``issubset``, ``issuperset``, ``istitle``, ``isupper``, ``items``, ``iteritems``, ``iterkeys``, ``itervalues``, ``join``, ``keys``, ``ljust``, ``lower``, ``lstrip``, ``numerator``, ``partition``, ``pop``, ``popitem``, ``real``, ``remove``, ``replace``, ``reverse``, ``rfind``, ``rindex``, ``rjust``, ``rpartition``, ``rsplit``, ``rstrip``, ``setdefault``, ``sort``, ``split``, ``splitlines``, ``startswith``, ``strip``, ``swapcase``, ``symmetric_difference``, ``symmetric_difference_update``, ``title``, ``translate``, ``union``, ``update``, ``upper``, ``values``, ``viewitems``, ``viewkeys``, ``viewvalues``, ``zfill``."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:147
msgid "Registering variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:149
msgid "You can create variables from the output of an Ansible task with the task keyword ``register``. You can use registered variables in any later tasks in your play. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:164
msgid "For more examples of using registered variables in conditions on later tasks, see :ref:`playbooks_conditionals`. Registered variables may be simple variables, list variables, dictionary variables, or complex nested data structures. The documentation for each module includes a ``RETURN`` section describing the return values for that module. To see the values for a particular task, run your playbook with ``-v``."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:166
msgid "Registered variables are stored in memory. You cannot cache registered variables for use in future plays. Registered variables are only valid on the host for the rest of the current playbook run."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:168
msgid "Registered variables are host-level variables. When you register a variable in a task with a loop, the registered variable contains a value for each item in the loop. The data structure placed in the variable during the loop will contain a ``results`` attribute, that is a list of all responses from the module. For a more in-depth example of how this works, see the :ref:`playbooks_loops` section on using register with a loop."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:170
msgid "If a task fails or is skipped, Ansible still registers a variable with a failure or skipped status, unless the task is skipped based on tags. See :ref:`tags` for information on adding and using tags."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:175
msgid "Referencing nested variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:177
msgid "Many registered variables (and :ref:`facts <vars_and_facts>`) are nested YAML or JSON data structures. You cannot access values from these nested data structures with the simple ``{{ foo }}`` syntax. You must use either bracket notation or dot notation. For example, to reference an IP address from your facts using the bracket notation::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:181
msgid "To reference an IP address from your facts using the dot notation::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:189
msgid "Transforming variables with Jinja2 filters"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:191
msgid "Jinja2 filters let you transform the value of a variable within a template expression. For example, the ``capitalize`` filter capitalizes any value passed to it; the ``to_yaml`` and ``to_json`` filters change the format of your variable values. Jinja2 includes many `built-in filters <https://jinja.palletsprojects.com/templates/#builtin-filters>`_ and Ansible supplies many more filters. To find more examples of filters, see :ref:`playbooks_filters`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:196
msgid "Where to set variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:198
msgid "You can define variables in a variety of places, such as in inventory, in playbooks, in reusable files, in roles, and at the command line. Ansible loads every possible variable it finds, then chooses the variable to apply based on :ref:`variable precedence rules <ansible_variable_precedence>`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:203
msgid "Defining variables in inventory"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:205
msgid "You can define different variables for each individual host, or set shared variables for a group of hosts in your inventory. For example, if all machines in the ``[Boston]`` group use 'boston.ntp.example.com' as an NTP server, you can set a group variable. The :ref:`intro_inventory` page has details on setting :ref:`host variables <host_variables>` and :ref:`group variables <group_variables>` in inventory."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:210
msgid "Defining variables in a playbook"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:212
msgid "You can define variables directly in a playbook::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:218
msgid "When you define variables in a playbook, they are visible to anyone who runs that playbook. This is especially useful if you share playbooks widely."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:224
msgid "Defining variables in included files and roles"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:226
msgid "You can define variables in reusable variables files and/or in reusable roles. When you define variables in reusable variable files, the sensitive variables are separated from playbooks. This separation enables you to store your playbooks in a source control software and even share the playbooks, without the risk of exposing passwords or other sensitive and personal data. For information about creating reusable files and roles, see :ref:`playbooks_reuse`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:228
msgid "This example shows how you can include variables defined in an external file::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:244
msgid "The contents of each variables file is a simple YAML dictionary. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:252
msgid "You can keep per-host and per-group variables in similar files. To learn about organizing your variables, see :ref:`splitting_out_vars`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:257
msgid "Defining variables at runtime"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:259
msgid "You can define variables when you run your playbook by passing variables at the command line using the ``--extra-vars`` (or ``-e``) argument. You can also request user input with a ``vars_prompt`` (see :ref:`playbooks_prompts`). When you pass variables at the command line, use a single quoted string, that contains one or more variables, in one of the formats below."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:262
msgid "key=value format"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:264
msgid "Values passed in using the ``key=value`` syntax are interpreted as strings. Use the JSON format if you need to pass non-string values such as Booleans, integers, floats, lists, and so on."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:271
msgid "JSON string format"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:278
msgid "When passing variables with ``--extra-vars``, you must escape quotes and other special characters appropriately for both your markup (for example, JSON), and for your shell::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:284
msgid "If you have a lot of special characters, use a JSON or YAML file containing the variable definitions."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:287
msgid "vars from a JSON or YAML file"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:297
msgid "Variable precedence: Where should I put a variable?"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:299
msgid "You can set multiple variables with the same name in many different places. When you do this, Ansible loads every possible variable it finds, then chooses the variable to apply based on variable precedence. In other words, the different variables will override each other in a certain order."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:301
msgid "Teams and projects that agree on guidelines for defining variables (where to define certain types of variables) usually avoid variable precedence concerns. We suggest that you define each variable in one place: figure out where to define a variable, and keep it simple. For examples, see :ref:`variable_examples`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:303
msgid "Some behavioral parameters that you can set in variables you can also set in Ansible configuration, as command-line options, and using playbook keywords. For example, you can define the user Ansible uses to connect to remote devices as a variable with ``ansible_user``, in a configuration file with ``DEFAULT_REMOTE_USER``, as a command-line option with ``-u``, and with the playbook keyword ``remote_user``. If you define the same parameter in a variable and by another method, the variable overrides the other setting. This approach allows host-specific settings to override more general settings. For examples and more details on the precedence of these various settings, see :ref:`general_precedence_rules`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:306
msgid "Understanding variable precedence"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:308
msgid "Ansible does apply variable precedence, and you might have a use for it. Here is the order of precedence from least to greatest (the last listed variables override all other variables):"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:310
msgid "command line values (for example, ``-u my_user``, these are not variables)"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:311
msgid "role defaults (defined in role/defaults/main.yml) [1]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:312
msgid "inventory file or script group vars [2]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:313
msgid "inventory group_vars/all [3]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:314
msgid "playbook group_vars/all [3]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:315
msgid "inventory group_vars/* [3]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:316
msgid "playbook group_vars/* [3]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:317
msgid "inventory file or script host vars [2]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:318
msgid "inventory host_vars/* [3]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:319
msgid "playbook host_vars/* [3]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:320
msgid "host facts / cached set_facts [4]_"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:321
msgid "play vars"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:322
msgid "play vars_prompt"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:323
msgid "play vars_files"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:324
msgid "role vars (defined in role/vars/main.yml)"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:325
msgid "block vars (only for tasks in block)"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:326
msgid "task vars (only for the task)"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:327
#: ../../rst/user_guide/windows_faq.rst:151
msgid "include_vars"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:328
msgid "set_facts / registered vars"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:329
msgid "role (and include_role) params"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:330
msgid "include params"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:331
msgid "extra vars (for example, ``-e \"user=my_user\"``)(always win precedence)"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:333
msgid "In general, Ansible gives precedence to variables that were defined more recently, more actively, and with more explicit scope. Variables in the defaults folder inside a role are easily overridden. Anything in the vars directory of the role overrides previous versions of that variable in the namespace. Host and/or inventory variables override role defaults, but explicit includes such as the vars directory or an ``include_vars`` task override inventory variables."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:335
msgid "Ansible merges different variables set in inventory so that more specific settings override more generic settings. For example, ``ansible_ssh_user`` specified as a group_var is overridden by ``ansible_user`` specified as a host_var. For details about the precedence of variables set in inventory, see :ref:`how_we_merge`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:338
msgid "Footnotes"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:339
msgid "Tasks in each role see their own role's defaults. Tasks defined outside of a role see the last role's defaults."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:340
msgid "Variables defined in inventory file or provided by dynamic inventory."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:341
msgid "Includes vars added by 'vars plugins' as well as host_vars and group_vars which are added by the default vars plugin shipped with Ansible."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:342
msgid "When created with set_facts's cacheable option, variables have the high precedence in the play, but are the same as a host facts precedence when they come from the cache."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:345
msgid "Within any section, redefining a var overrides the previous instance. If multiple groups have the same variable, the last one loaded wins. If you define a variable twice in a play's ``vars:`` section, the second one wins."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:348
msgid "The previous describes the default config ``hash_behaviour=replace``, switch to ``merge`` to only partially overwrite."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:353
msgid "Scoping variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:355
msgid "You can decide where to set a variable based on the scope you want that value to have. Ansible has three main scopes:"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:357
msgid "Global: this is set by config, environment variables and the command line"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:358
msgid "Play: each play and contained structures, vars entries (vars; vars_files; vars_prompt), role defaults and vars."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:359
msgid "Host: variables directly associated to a host, like inventory, include_vars, facts or registered task outputs"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:361
msgid "Inside a template, you automatically have access to all variables that are in scope for a host, plus any registered variables, facts, and magic variables."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:366
msgid "Tips on where to set variables"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:368
msgid "You should choose where to define a variable based on the kind of control you might want over values."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:370
msgid "Set variables in inventory that deal with geography or behavior. Since groups are frequently the entity that maps roles onto hosts, you can often set variables on the group instead of defining them on a role. Remember: child groups override parent groups, and host variables override group variables. See :ref:`define_variables_in_inventory` for details on setting host and group variables."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:372
msgid "Set common defaults in a ``group_vars/all`` file. See :ref:`splitting_out_vars` for details on how to organize host and group variables in your inventory. Group variables are generally placed alongside your inventory file, but they can also be returned by dynamic inventory (see :ref:`intro_dynamic_inventory`) or defined in :ref:`ansible_tower` from the UI or API::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:379
msgid "Set location-specific variables in ``group_vars/my_location`` files. All groups are children of the ``all`` group, so variables set here override those set in ``group_vars/all``::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:385
msgid "If one host used a different NTP server, you could set that in a host_vars file, which would override the group variable::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:391
msgid "Set defaults in roles to avoid undefined-variable errors. If you share your roles, other users can rely on the reasonable defaults you added in the ``roles/x/defaults/main.yml`` file, or they can easily override those values in inventory or at the command line. See :ref:`playbooks_reuse_roles` for more info. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:398
msgid "Set variables in roles to ensure a value is used in that role, and is not overridden by inventory variables. If you are not sharing your role with others, you can define app-specific behaviors like ports this way, in ``roles/x/vars/main.yml``. If you are sharing roles with others, putting variables here makes them harder to override, although they still can by passing a parameter to the role or setting a variable with ``-e``::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:405
msgid "Pass variables as parameters when you call roles for maximum clarity, flexibility, and visibility. This approach overrides any defaults that exist for a role. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:412
msgid "When you read this playbook it is clear that you have chosen to set a variable or override a default. You can also pass multiple values, which allows you to run the same role multiple times. See :ref:`run_role_twice` for more details. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:428
msgid "Variables set in one role are available to later roles. You can set variables in a ``roles/common_settings/vars/main.yml`` file and use them in other roles and elsewhere in your playbook::"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:437
msgid "There are some protections in place to avoid the need to namespace variables. In this example, variables defined in 'common_settings' are available to 'something' and 'something_else' tasks, but tasks in 'something' have foo set at 12, even if 'common_settings' sets foo to 20."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:440
msgid "Instead of worrying about variable precedence, we encourage you to think about how easily or how often you want to override a variable when deciding where to set it. If you are not sure what other variables are defined, and you need a particular value, use ``--extra-vars`` (``-e``) to override all other variables."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:443
msgid "Using advanced variable syntax"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:445
msgid "For information about advanced YAML syntax used to declare variables and have more control over the data placed in YAML files used by Ansible, see :ref:`playbooks_advanced_syntax`."
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:454
msgid "Jinja2 filters and their uses"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:461
msgid ":ref:`special_variables`"
msgstr ""

#: ../../rst/user_guide/playbooks_variables.rst:462
msgid "List of special variables"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:5
msgid "Discovering variables: facts and magic variables"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:7
msgid "With Ansible you can retrieve or discover certain variables containing information about your remote systems or about Ansible itself. Variables related to remote systems are called facts. With facts, you can use the behavior or state of one system as configuration on other systems. For example, you can use the IP address of one system as a configuration value on another system. Variables related to Ansible are called magic variables."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:13
msgid "Ansible facts"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:15
msgid "Ansible facts are data related to your remote systems, including operating systems, IP addresses, attached filesystems, and more. You can access this data in the ``ansible_facts`` variable. By default, you can also access some Ansible facts as top-level variables with the ``ansible_`` prefix. You can disable this behavior using the :ref:`INJECT_FACTS_AS_VARS` setting. To see all available facts, add this task to a play::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:21
msgid "To see the 'raw' information as gathered, run this command at the command line::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:25
msgid "Facts include a large amount of variable data, which may look like this:"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:486
msgid "You can reference the model of the first disk in the facts shown above in a template or playbook as::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:490
msgid "To reference the system hostname::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:494
msgid "You can use facts in conditionals (see :ref:`playbooks_conditionals`) and also in templates. You can also use facts to create dynamic groups of hosts that match particular criteria, see the :ref:`group_by module <group_by_module>` documentation for details."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:499
msgid "Package requirements for fact gathering"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:501
msgid "On some distros, you may see missing fact values or facts set to default values because the packages that support gathering those facts are not installed by default. You can install the necessary packages on your remote hosts using the OS package manager. Known dependencies include:"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:503
msgid "Linux Network fact gathering -  Depends on  the ``ip`` binary, commonly included in the ``iproute2`` package."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:508
msgid "Caching facts"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:510
msgid "Like registered variables, facts are stored in memory by default. However, unlike registered variables, facts can be gathered independently and cached for repeated use. With cached facts, you can refer to facts from one system when configuring a second system, even if Ansible executes the current play on the second system first. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:514
msgid "Caching is controlled by the cache plugins. By default, Ansible uses the memory cache plugin, which stores facts in memory for the duration of the current playbook run. To retain Ansible facts for repeated use, select a different cache plugin. See :ref:`cache_plugins` for details."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:516
msgid "Fact caching can improve performance. If you manage thousands of hosts, you can configure fact caching to run nightly, then manage configuration on a smaller set of servers periodically throughout the day. With cached facts, you have access to variables and information about all hosts even when you are only managing a small number of servers."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:521
msgid "Disabling facts"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:523
msgid "By default, Ansible gathers facts at the beginning of each play. If you do not need to gather facts (for example, if you know everything about your systems centrally), you can turn off fact gathering at the play level to improve scalability. Disabling facts may particularly improve performance in push mode with very large numbers of systems, or if you are using Ansible on experimental platforms. To disable fact gathering::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:529
msgid "Adding custom facts"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:531
msgid "The setup module in Ansible automatically discovers a standard set of facts about each host. If you want to add custom values to your facts, you can write a custom facts module, set temporary facts with a ``ansible.builtin.set_fact`` task, or provide permanent custom facts using the facts.d directory."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:536
msgid "facts.d or local facts"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:540
msgid "You can add static custom facts by adding static files to facts.d, or add dynamic facts by adding executable scripts to facts.d. For example, you can add a list of all users on a host to your facts by creating and running a script in facts.d."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:542
msgid "To use facts.d, create an ``/etc/ansible/facts.d`` directory on the remote host or hosts. If you prefer a different directory, create it and specify it using the ``fact_path`` play keyword. Add files to the directory to supply your custom facts. All file names must end with ``.fact``. The files can be JSON, INI, or executable files returning JSON."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:544
msgid "To add static facts, simply add a file with the ``.fact`` extension. For example, create ``/etc/ansible/facts.d/preferences.fact`` with this content::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:550
msgid "Make sure the file is not executable as this will break the ``ansible.builtin.setup`` module."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:552
msgid "The next time fact gathering runs, your facts will include a hash variable fact named ``general`` with ``asdf`` and ``bar`` as members. To validate this, run the following::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:556
msgid "And you will see your custom fact added::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:567
msgid "The ansible_local namespace separates custom facts created by facts.d from system facts or variables defined elsewhere in the playbook, so variables will not override each other. You can access this custom fact in a template or playbook as::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:571
msgid "The key part in the key=value pairs will be converted into lowercase inside the ansible_local variable. Using the example above, if the ini file contained ``XYZ=3`` in the ``[general]`` section, then you should expect to access it as: ``{{ ansible_local['preferences']['general']['xyz'] }}`` and not ``{{ ansible_local['preferences']['general']['XYZ'] }}``. This is because Ansible uses Python's `ConfigParser`_ which passes all option names through the `optionxform`_ method and this method's default implementation converts option names to lower case."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:576
msgid "You can also use facts.d to execute a script on the remote host, generating dynamic custom facts to the ansible_local namespace. For example, you can generate a list of all users that exist on a remote host as a fact about that host. To generate dynamic custom facts using facts.d:"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:578
msgid "Write and test a script to generate the JSON data you want."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:579
msgid "Save the script in your facts.d directory."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:580
msgid "Make sure your script has the ``.fact`` file extension."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:581
msgid "Make sure your script is executable by the Ansible connection user."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:582
msgid "Gather facts to execute the script and add the JSON output to ansible_local."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:584
msgid "By default, fact gathering runs once at the beginning of each play. If you create a custom fact using facts.d in a playbook, it will be available in the next play that gathers facts. If you want to use it in the same play where you created it, you must explicitly re-run the setup module. For example::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:604
msgid "If you use this pattern frequently, a custom facts module would be more efficient than facts.d."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:609
msgid "Information about Ansible: magic variables"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:611
msgid "You can access information about Ansible operations, including the python version being used, the hosts and groups in inventory, and the directories for playbooks and roles, using \"magic\" variables. Like connection variables, magic variables are :ref:`special_variables`. Magic variable names are reserved - do not set variables with these names. The variable ``environment`` is also reserved."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:613
msgid "The most commonly used magic variables are ``hostvars``, ``groups``, ``group_names``, and ``inventory_hostname``. With ``hostvars``, you can access variables defined for any host in the play, at any point in a playbook. You can access Ansible facts using the ``hostvars`` variable too, but only after you have gathered (or cached) facts."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:615
msgid "If you want to configure your database server using the value of a 'fact' from another node, or the value of an inventory variable assigned to another node, you can use ``hostvars`` in a template or on an action line::"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:619
msgid "With ``groups``, a list of all the groups (and hosts) in the inventory, you can enumerate all hosts within a group. For example:"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:627
msgid "You can use ``groups`` and ``hostvars`` together to find all the IP addresses in a group."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:635
msgid "You can use this approach to point a frontend proxy server to all the hosts in your app servers group, to set up the correct firewall rules between servers, and so on. You must either cache facts or gather facts for those hosts before the task that fills out the template."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:637
msgid "With ``group_names``, a list (array) of all the groups the current host is in, you can create templated files that vary based on the group membership (or role) of the host:"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:645
msgid "You can use the magic variable ``inventory_hostname``, the name of the host as configured in your inventory, as an alternative to ``ansible_hostname`` when fact-gathering is disabled. If you have a long FQDN, you can use ``inventory_hostname_short``, which contains the part up to the first period, without the rest of the domain."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:647
msgid "Other useful magic variables refer to the current play or playbook. These vars may be useful for filling out templates with multiple hostnames or for injecting the list into the rules for a load balancer."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:649
msgid "``ansible_play_hosts`` is the list of all hosts still active in the current play."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:651
msgid "``ansible_play_batch`` is a list of hostnames that are in scope for the current 'batch' of the play."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:653
msgid "The batch size is defined by ``serial``, when not set it is equivalent to the whole play (making it the same as ``ansible_play_hosts``)."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:655
msgid "``ansible_playbook_python`` is the path to the python executable used to invoke the Ansible command line tool."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:657
msgid "``inventory_dir`` is the pathname of the directory holding Ansible's inventory host file."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:659
msgid "``inventory_file`` is the pathname and the filename pointing to the Ansible's inventory host file."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:661
msgid "``playbook_dir`` contains the playbook base directory."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:663
msgid "``role_path`` contains the current role's pathname and only works inside a role."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:665
msgid "``ansible_check_mode`` is a boolean, set to ``True`` if you run Ansible with ``--check``."
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:670
msgid "Ansible version"
msgstr ""

#: ../../rst/user_guide/playbooks_vars_facts.rst:674
msgid "To adapt playbook behavior to different versions of Ansible, you can use the variable ``ansible_version``, which has the following structure::"
msgstr ""

#: ../../rst/user_guide/playbooks_vault.rst:4
msgid "Using vault in playbooks"
msgstr ""

#: ../../rst/user_guide/playbooks_vault.rst:6
msgid "The documentation regarding Ansible Vault has moved. The new location is here: :ref:`vault`. Please update any links you may have made directly to this page."
msgstr ""

#: ../../rst/user_guide/plugin_filtering_config.rst:4
msgid "Blacklisting modules"
msgstr ""

#: ../../rst/user_guide/plugin_filtering_config.rst:6
msgid "If you want to avoid using certain modules, you can blacklist them to prevent Ansible from loading them. To blacklist plugins, create a yaml configuration file. The default location for this file is :file:`/etc/ansible/plugin_filters.yml`, or you can select a different path for the blacklist file using the :ref:`PLUGIN_FILTERS_CFG` setting in the ``defaults`` section of your ansible.cfg. Here is an example blacklist file:"
msgstr ""

#: ../../rst/user_guide/plugin_filtering_config.rst:18
msgid "The file contains two fields:"
msgstr ""

#: ../../rst/user_guide/plugin_filtering_config.rst:20
msgid "A file version so that you can update the format while keeping backwards compatibility in the future. The present version should be the string, ``\"1.0\"``"
msgstr ""

#: ../../rst/user_guide/plugin_filtering_config.rst:22
msgid "A list of modules to blacklist. Any module in this list will not be loaded by Ansible when it searches for a module to invoke for a task."
msgstr ""

#: ../../rst/user_guide/plugin_filtering_config.rst:26
msgid "You cannot blacklist the ``stat`` module, as it is required for Ansible to run."
msgstr ""

#: ../../rst/user_guide/quickstart.rst:4
msgid "Ansible Quickstart Guide"
msgstr ""

#: ../../rst/user_guide/quickstart.rst:6
msgid "We've recorded a short video that introduces Ansible."
msgstr ""

#: ../../rst/user_guide/quickstart.rst:8
msgid "The `quickstart video <https://www.ansible.com/resources/videos/quick-start-video>`_ is about 13 minutes long and gives you a high level introduction to Ansible -- what it does and how to use it. We'll also tell you about other products in the Ansible ecosystem."
msgstr ""

#: ../../rst/user_guide/quickstart.rst:11
msgid "Enjoy, and be sure to visit the rest of the documentation to learn more."
msgstr ""

#: ../../rst/user_guide/quickstart.rst:15
msgid "`A system administrators guide to getting started with Ansible <https://www.redhat.com/en/blog/system-administrators-guide-getting-started-ansible-fast>`_"
msgstr ""

#: ../../rst/user_guide/quickstart.rst:16
msgid "A step by step introduction to Ansible"
msgstr ""

#: ../../rst/user_guide/quickstart.rst:17
msgid "`Ansible Automation for SysAdmins <https://opensource.com/downloads/ansible-quickstart>`_"
msgstr ""

#: ../../rst/user_guide/quickstart.rst:18
msgid "A downloadable guide for getting started with Ansible"
msgstr ""

#: ../../rst/user_guide/quickstart.rst:19
msgid ":ref:`network_getting_started`"
msgstr ""

#: ../../rst/user_guide/quickstart.rst:20
msgid "A guide for network engineers using Ansible for the first time"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:5
msgid "Sample Ansible setup"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:7
msgid "You have learned about playbooks, inventory, roles, and variables. This section pulls all those elements together, outlining a sample setup for automating a web service. You can find more example playbooks illustrating these patterns in our `ansible-examples repository <https://github.com/ansible/ansible-examples>`_.  (NOTE: These may not use all of the features in the latest release, but are still an excellent reference!)."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:9
msgid "The sample setup organizes playbooks, roles, inventory, and variables files by function, with tags at the play and task level for greater granularity and control. This is a powerful and flexible approach, but there are other ways to organize Ansible content. Your usage of Ansible should fit your needs, not ours, so feel free to modify this approach and organize your content as you see fit."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:15
msgid "Sample directory layout"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:17
msgid "This layout organizes most tasks in roles, with a single inventory file for each environment and a few playbooks in the top-level directory::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:67
msgid "Alternative directory layout"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:69
msgid "Alternatively you can put each inventory file with its ``group_vars``/``host_vars`` in a separate directory. This is particularly useful if your ``group_vars``/``host_vars`` don't have that much in common in different environments. The layout could look something like this::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:104
msgid "This layout gives you more flexibility for larger environments, as well as a total separation of inventory variables between different environments. However, this approach is harder to maintain, because there are more files. For more information on organizing group and host variables, see :ref:`splitting_out_vars`."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:109
msgid "Sample group and host variables"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:111
msgid "These sample group and host variables files record the variable values that apply to each machine or group of machines. For instance, the data center in Atlanta has its own NTP servers, so when setting up ntp.conf, we should use them::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:118
msgid "Similarly, the webservers have some configuration that does not apply to the database servers::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:125
msgid "Default values, or values that are universally true, belong in a file called group_vars/all::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:132
msgid "If necessary, you can define specific hardware variance in systems in a host_vars file::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:139
msgid "Again, if you are using :ref:`dynamic inventory <dynamic_inventory>`, Ansible creates many dynamic groups automatically.  So a tag like \"class:webserver\" would load in variables from the file \"group_vars/ec2_tag_class_webserver\" automatically."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:144
msgid "Sample playbooks organized by function"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:146
msgid "With this setup, a single playbook can define all the infrastructure. The site.yml playbook imports two other playbooks, one for the webservers and one for the database servers::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:153
msgid "The webservers.yml file, also at the top level, maps the configuration of the webservers group to the roles related to the webservers group::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:162
msgid "With this setup, you can configure your whole infrastructure by \"running\" site.yml, or run a subset by running webservers.yml.  This is analogous to the Ansible \"--limit\" parameter but a little more explicit::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:170
msgid "Sample task and handler files in a function-based role"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:172
msgid "Ansible loads any file called ``main.yml`` in a role sub-directory. This sample ``tasks/main.yml`` file is simple - it sets up NTP, but it could do more if we wanted::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:198
msgid "Here is an example handlers file.  As a review, handlers are only fired when certain tasks report changes, and are run at the end of each play::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:208
msgid "See :ref:`playbooks_reuse_roles` for more information."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:214
msgid "What the sample setup enables"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:216
msgid "The basic organizational structure described above enables a lot of different automation options. To reconfigure your entire infrastructure::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:220
msgid "To reconfigure NTP on everything::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:224
msgid "To reconfigure only the webservers::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:228
msgid "To reconfigure only the webservers in Boston::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:232
msgid "To reconfigure only the first 10 webservers in Boston, and then the next 10::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:237
msgid "The sample setup also supports basic ad-hoc commands::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:242
msgid "To discover what tasks would run or what hostnames would be affected by a particular Ansible command::"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:253
msgid "Organizing for deployment or configuration"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:255
msgid "The sample setup models a typical configuration topology.  When doing multi-tier deployments, there are going to be some additional playbooks that hop between tiers to roll out an application. In this case, 'site.yml' may be augmented by playbooks like 'deploy_exampledotcom.yml' but the general concepts still apply. Ansible allows you to deploy and configure using the same tool, so you would likely reuse groups and keep the OS configuration in separate playbooks or roles from the app deployment."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:259
msgid "Consider \"playbooks\" as a sports metaphor -- you can have one set of plays to use against all your infrastructure and situational plays that you use at different times and for different purposes."
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:264
msgid "Using local Ansible modules"
msgstr ""

#: ../../rst/user_guide/sample_setup.rst:266
msgid "If a playbook has a :file:`./library` directory relative to its YAML file, this directory can be used to add Ansible modules that will automatically be in the Ansible module path.  This is a great way to keep modules that go with a playbook together.  This is shown in the directory structure example at the start of this section."
msgstr ""

#: ../../rst/user_guide/vault.rst:5 ../../rst/user_guide/vault.rst:127
msgid "Encrypting content with Ansible Vault"
msgstr ""

#: ../../rst/user_guide/vault.rst:7
msgid "Ansible Vault encrypts variables and files so you can protect sensitive content such as passwords or keys rather than leaving it visible as plaintext in playbooks or roles. To use Ansible Vault you need one or more passwords to encrypt and decrypt content. If you store your vault passwords in a third-party tool such as a secret manager, you need a script to access them. Use the passwords with the :ref:`ansible-vault` command-line tool to create and view encrypted variables, create encrypted files, encrypt existing files, or edit, re-key, or decrypt files. You can then place encrypted content under source control and share it more safely."
msgstr ""

#: ../../rst/user_guide/vault.rst:10
msgid "Encryption with Ansible Vault ONLY protects 'data at rest'.  Once the content is decrypted ('data in use'), play and plugin authors are responsible for avoiding any secret disclosure, see :ref:`no_log <keep_secret_data>` for details on hiding output and :ref:`vault_securing_editor` for security considerations on editors you use with Ansible Vault."
msgstr ""

#: ../../rst/user_guide/vault.rst:12
msgid "You can use encrypted variables and files in ad-hoc commands and playbooks by supplying the passwords you used to encrypt them. You can modify your ``ansible.cfg`` file to specify the location of a password file or to always prompt for the password."
msgstr ""

#: ../../rst/user_guide/vault.rst:18
msgid "Managing vault passwords"
msgstr ""

#: ../../rst/user_guide/vault.rst:20
msgid "Managing your encrypted content is easier if you develop a strategy for managing your vault passwords. A vault password can be any string you choose. There is no special command to create a vault password. However, you need to keep track of your vault passwords. Each time you encrypt a variable or file with Ansible Vault, you must provide a password. When you use an encrypted variable or file in a command or playbook, you must provide the same password that was used to encrypt it. To develop a strategy for managing vault passwords, start with two questions:"
msgstr ""

#: ../../rst/user_guide/vault.rst:22
msgid "Do you want to encrypt all your content with the same password, or use different passwords for different needs?"
msgstr ""

#: ../../rst/user_guide/vault.rst:23
msgid "Where do you want to store your password or passwords?"
msgstr ""

#: ../../rst/user_guide/vault.rst:26
msgid "Choosing between a single password and multiple passwords"
msgstr ""

#: ../../rst/user_guide/vault.rst:28
msgid "If you have a small team or few sensitive values, you can use a single password for everything you encrypt with Ansible Vault. Store your vault password securely in a file or a secret manager as described below."
msgstr ""

#: ../../rst/user_guide/vault.rst:30
msgid "If you have a larger team or many sensitive values, you can use multiple passwords. For example, you can use different passwords for different users or different levels of access. Depending on your needs, you might want a different password for each encrypted file, for each directory, or for each environment. For example, you might have a playbook that includes two vars files, one for the dev environment and one for the production environment, encrypted with two different passwords. When you run the playbook, select the correct vault password for the environment you are targeting, using a vault ID."
msgstr ""

#: ../../rst/user_guide/vault.rst:35
msgid "Managing multiple passwords with vault IDs"
msgstr ""

#: ../../rst/user_guide/vault.rst:37
msgid "If you use multiple vault passwords, you can differentiate one password from another with vault IDs. You use the vault ID in three ways:"
msgstr ""

#: ../../rst/user_guide/vault.rst:39
msgid "Pass it with :option:`--vault-id <ansible-playbook --vault-id>` to the :ref:`ansible-vault` command when you create encrypted content"
msgstr ""

#: ../../rst/user_guide/vault.rst:40
msgid "Include it wherever you store the password for that vault ID (see :ref:`storing_vault_passwords`)"
msgstr ""

#: ../../rst/user_guide/vault.rst:41
msgid "Pass it with :option:`--vault-id <ansible-playbook --vault-id>` to the :ref:`ansible-playbook` command when you run a playbook that uses content you encrypted with that vault ID"
msgstr ""

#: ../../rst/user_guide/vault.rst:43
msgid "When you pass a vault ID as an option to the :ref:`ansible-vault` command, you add a label (a hint or nickname) to the encrypted content. This label documents which password you used to encrypt it. The encrypted variable or file includes the vault ID label in plain text in the header. The vault ID is the last element before the encrypted content. For example::"
msgstr ""

#: ../../rst/user_guide/vault.rst:53
msgid "In addition to the label, you must provide a source for the related password. The source can be a prompt, a file, or a script, depending on how you are storing your vault passwords. The pattern looks like this:"
msgstr ""

#: ../../rst/user_guide/vault.rst:59
msgid "If your playbook uses multiple encrypted variables or files that you encrypted with different passwords, you must pass the vault IDs when you run that playbook. You can use :option:`--vault-id <ansible-playbook --vault-id>` by itself, with :option:`--vault-password-file <ansible-playbook --vault-password-file>`, or with :option:`--ask-vault-pass <ansible-playbook --ask-vault-pass>`. The pattern is the same as when you create encrypted content: include the label and the source for the matching password."
msgstr ""

#: ../../rst/user_guide/vault.rst:61
msgid "See below for examples of encrypting content with vault IDs and using content encrypted with vault IDs. The :option:`--vault-id <ansible-playbook --vault-id>` option works with any Ansible command that interacts with vaults, including :ref:`ansible-vault`, :ref:`ansible-playbook`, and so on."
msgstr ""

#: ../../rst/user_guide/vault.rst:64
msgid "Limitations of vault IDs"
msgstr ""

#: ../../rst/user_guide/vault.rst:66
msgid "Ansible does not enforce using the same password every time you use a particular vault ID label. You can encrypt different variables or files with the same vault ID label but different passwords. This usually happens when you type the password at a prompt and make a mistake. It is possible to use different passwords with the same vault ID label on purpose. For example, you could use each label as a reference to a class of passwords, rather than a single password. In this scenario, you must always know which specific password or file to use in context. However, you are more likely to encrypt two files with the same vault ID label and different passwords by mistake. If you encrypt two files with the same label but different passwords by accident, you can :ref:`rekey <rekeying_files>` one file to fix the issue."
msgstr ""

#: ../../rst/user_guide/vault.rst:69
msgid "Enforcing vault ID matching"
msgstr ""

#: ../../rst/user_guide/vault.rst:71
msgid "By default the vault ID label is only a hint to remind you which password you used to encrypt a variable or file. Ansible does not check that the vault ID in the header of the encrypted content matches the vault ID you provide when you use the content. Ansible decrypts all files and variables called by your command or playbook that are encrypted with the password you provide. To check the encrypted content and decrypt it only when the vault ID it contains matches the one you provide with ``--vault-id``, set the config option :ref:`DEFAULT_VAULT_ID_MATCH`. When you set :ref:`DEFAULT_VAULT_ID_MATCH`, each password is only used to decrypt data that was encrypted with the same label. This is efficient, predictable, and can reduce errors when different values are encrypted with different passwords."
msgstr ""

#: ../../rst/user_guide/vault.rst:74
msgid "Even with the :ref:`DEFAULT_VAULT_ID_MATCH` setting enabled, Ansible does not enforce using the same password every time you use a particular vault ID label."
msgstr ""

#: ../../rst/user_guide/vault.rst:79
msgid "Storing and accessing vault passwords"
msgstr ""

#: ../../rst/user_guide/vault.rst:81
msgid "You can memorize your vault password, or manually copy vault passwords from any source and paste them at a command-line prompt, but most users store them securely and access them as needed from within Ansible. You have two options for storing vault passwords that work from within Ansible: in files, or in a third-party tool such as the system keyring or a secret manager. If you store your passwords in a third-party tool, you need a vault password client script to retrieve them from within Ansible."
msgstr ""

#: ../../rst/user_guide/vault.rst:84
msgid "Storing passwords in files"
msgstr ""

#: ../../rst/user_guide/vault.rst:86
msgid "To store a vault password in a file, enter the password as a string on a single line in the file. Make sure the permissions on the file are appropriate. Do not add password files to source control. If you have multiple passwords, you can store them all in a single file, as long as they all have vault IDs. For each password, create a separate line and enter the vault ID, a space, then the password as a string. For example:"
msgstr ""

#: ../../rst/user_guide/vault.rst:98
msgid "Storing passwords in third-party tools with vault password client scripts"
msgstr ""

#: ../../rst/user_guide/vault.rst:100
msgid "You can store your vault passwords on the system keyring, in a database, or in a secret manager and retrieve them from within Ansible using a vault password client script. Enter the password as a string on a single line. If your password has a vault ID, store it in a way that works with your password storage tool."
msgstr ""

#: ../../rst/user_guide/vault.rst:102
msgid "To create a vault password client script:"
msgstr ""

#: ../../rst/user_guide/vault.rst:104
msgid "Create a file with a name ending in ``-client.py``"
msgstr ""

#: ../../rst/user_guide/vault.rst:105
msgid "Make the file executable"
msgstr ""

#: ../../rst/user_guide/vault.rst:109
msgid "Within the script itself:"
msgstr ""

#: ../../rst/user_guide/vault.rst:107
msgid "Print the passwords to standard output"
msgstr ""

#: ../../rst/user_guide/vault.rst:108
msgid "Accept a ``--vault-id`` option"
msgstr ""

#: ../../rst/user_guide/vault.rst:109
msgid "If the script prompts for data (for example, a database password), send the prompts to standard error"
msgstr ""

#: ../../rst/user_guide/vault.rst:111
msgid "When you run a playbook that uses vault passwords stored in a third-party tool, specify the script as the source within the ``--vault-id`` flag. For example:"
msgstr ""

#: ../../rst/user_guide/vault.rst:117
msgid "Ansible executes the client script with a ``--vault-id`` option so the script knows which vault ID label you specified. For example a script loading passwords from a secret manager can use the vault ID label to pick either the 'dev' or 'prod' password. The example command above results in the following execution of the client script:"
msgstr ""

#: ../../rst/user_guide/vault.rst:123
msgid "For an example of a client script that loads passwords from the system keyring, see :file:`contrib/vault/vault-keyring-client.py`."
msgstr ""

#: ../../rst/user_guide/vault.rst:129
msgid "Once you have a strategy for managing and storing vault passwords, you can start encrypting content. You can encrypt two types of content with Ansible Vault: variables and files. Encrypted content always includes the ``!vault`` tag, which tells Ansible and YAML that the content needs to be decrypted, and a ``|`` character, which allows multi-line strings. Encrypted content created with ``--vault-id`` also contains the vault ID label. For more details about the encryption process and the format of content encrypted with Ansible Vault, see :ref:`vault_format`. This table shows the main differences between encrypted variables and encrypted files:"
msgstr ""

#: ../../rst/user_guide/vault.rst:135
msgid "Encrypted variables"
msgstr ""

#: ../../rst/user_guide/vault.rst:135
msgid "Encrypted files"
msgstr ""

#: ../../rst/user_guide/vault.rst:137
msgid "How much is encrypted?"
msgstr ""

#: ../../rst/user_guide/vault.rst:137
msgid "Variables within a plaintext file"
msgstr ""

#: ../../rst/user_guide/vault.rst:137
msgid "The entire file"
msgstr ""

#: ../../rst/user_guide/vault.rst:139
msgid "When is it decrypted?"
msgstr ""

#: ../../rst/user_guide/vault.rst:139
msgid "On demand, only when needed"
msgstr ""

#: ../../rst/user_guide/vault.rst:139
msgid "Whenever loaded or referenced [#f1]_"
msgstr ""

#: ../../rst/user_guide/vault.rst:141
msgid "What can be encrypted?"
msgstr ""

#: ../../rst/user_guide/vault.rst:141
msgid "Only variables"
msgstr ""

#: ../../rst/user_guide/vault.rst:141
msgid "Any structured data file"
msgstr ""

#: ../../rst/user_guide/vault.rst:145
msgid "Ansible cannot know if it needs content from an encrypted file unless it decrypts the file, so it decrypts all encrypted files referenced in your playbooks and roles."
msgstr ""

#: ../../rst/user_guide/vault.rst:151
msgid "Encrypting individual variables with Ansible Vault"
msgstr ""

#: ../../rst/user_guide/vault.rst:153
msgid "You can encrypt single values inside a YAML file using the :ref:`ansible-vault encrypt_string <ansible_vault_encrypt_string>` command. For one way to keep your vaulted variables safely visible, see :ref:`tip_for_variables_and_vaults`."
msgstr ""

#: ../../rst/user_guide/vault.rst:156
msgid "Advantages and disadvantages of encrypting variables"
msgstr ""

#: ../../rst/user_guide/vault.rst:158
msgid "With variable-level encryption, your files are still easily legible. You can mix plaintext and encrypted variables, even inline in a play or role. However, password rotation is not as simple as with file-level encryption. You cannot :ref:`rekey <rekeying_files>` encrypted variables. Also, variable-level encryption only works on variables. If you want to encrypt tasks or other content, you must encrypt the entire file."
msgstr ""

#: ../../rst/user_guide/vault.rst:163
msgid "Creating encrypted variables"
msgstr ""

#: ../../rst/user_guide/vault.rst:165
msgid "The :ref:`ansible-vault encrypt_string <ansible_vault_encrypt_string>` command encrypts and formats any string you type (or copy or generate) into a format that can be included in a playbook, role, or variables file. To create a basic encrypted variable, pass three options to the :ref:`ansible-vault encrypt_string <ansible_vault_encrypt_string>` command:"
msgstr ""

#: ../../rst/user_guide/vault.rst:167
msgid "a source for the vault password (prompt, file, or script, with or without a vault ID)"
msgstr ""

#: ../../rst/user_guide/vault.rst:168
msgid "the string to encrypt"
msgstr ""

#: ../../rst/user_guide/vault.rst:169
msgid "the string name (the name of the variable)"
msgstr ""

#: ../../rst/user_guide/vault.rst:171
msgid "The pattern looks like this:"
msgstr ""

#: ../../rst/user_guide/vault.rst:177
msgid "For example, to encrypt the string 'foobar' using the only password stored in 'a_password_file' and name the variable 'the_secret':"
msgstr ""

#: ../../rst/user_guide/vault.rst:183 ../../rst/user_guide/vault.rst:199
msgid "The command above creates this content::"
msgstr ""

#: ../../rst/user_guide/vault.rst:193
msgid "To encrypt the string 'foooodev', add the vault ID label 'dev' with the 'dev' vault password stored in 'a_password_file', and call the encrypted variable 'the_dev_secret':"
msgstr ""

#: ../../rst/user_guide/vault.rst:209
msgid "To encrypt the string 'letmein' read from stdin, add the vault ID 'test' using the 'test' vault password stored in `a_password_file`, and name the variable 'test_db_password':"
msgstr ""

#: ../../rst/user_guide/vault.rst:217
msgid "Typing secret content directly at the command line (without a prompt) leaves the secret string in your shell history. Do not do this outside of testing."
msgstr ""

#: ../../rst/user_guide/vault.rst:219
msgid "The command above creates this output::"
msgstr ""

#: ../../rst/user_guide/vault.rst:230
msgid "To be prompted for a string to encrypt, encrypt it with the 'dev' vault password from 'a_password_file', name the variable 'new_user_password' and give it the vault ID label 'dev':"
msgstr ""

#: ../../rst/user_guide/vault.rst:236
msgid "The command above triggers this prompt:"
msgstr ""

#: ../../rst/user_guide/vault.rst:242
msgid "Type the string to encrypt (for example, 'hunter2'), hit ctrl-d, and wait."
msgstr ""

#: ../../rst/user_guide/vault.rst:246
msgid "Do not press ``Enter`` after supplying the string to encrypt. That will add a newline to the encrypted value."
msgstr ""

#: ../../rst/user_guide/vault.rst:248
msgid "The sequence above creates this output::"
msgstr ""

#: ../../rst/user_guide/vault.rst:258
msgid "You can add the output from any of the examples above to any playbook, variables file, or role for future use. Encrypted variables are larger than plain-text variables, but they protect your sensitive content while leaving the rest of the playbook, variables file, or role in plain text so you can easily read it."
msgstr ""

#: ../../rst/user_guide/vault.rst:261
msgid "Viewing encrypted variables"
msgstr ""

#: ../../rst/user_guide/vault.rst:263
msgid "You can view the original value of an encrypted variable using the debug module. You must pass the password that was used to encrypt the variable. For example, if you stored the variable created by the last example above in a file called 'vars.yml', you could view the unencrypted value of that variable like this:"
msgstr ""

#: ../../rst/user_guide/vault.rst:275
msgid "Encrypting files with Ansible Vault"
msgstr ""

#: ../../rst/user_guide/vault.rst:277
msgid "Ansible Vault can encrypt any structured data file used by Ansible, including:"
msgstr ""

#: ../../rst/user_guide/vault.rst:279
msgid "group variables files from inventory"
msgstr ""

#: ../../rst/user_guide/vault.rst:280
msgid "host variables files from inventory"
msgstr ""

#: ../../rst/user_guide/vault.rst:281
msgid "variables files passed to ansible-playbook with ``-e @file.yml`` or ``-e @file.json``"
msgstr ""

#: ../../rst/user_guide/vault.rst:282
msgid "variables files loaded by ``include_vars`` or ``vars_files``"
msgstr ""

#: ../../rst/user_guide/vault.rst:283
msgid "variables files in roles"
msgstr ""

#: ../../rst/user_guide/vault.rst:284
msgid "defaults files in roles"
msgstr ""

#: ../../rst/user_guide/vault.rst:285
msgid "tasks files"
msgstr ""

#: ../../rst/user_guide/vault.rst:286
msgid "handlers files"
msgstr ""

#: ../../rst/user_guide/vault.rst:287
msgid "binary files or other arbitrary files"
msgstr ""

#: ../../rst/user_guide/vault.rst:289
msgid "The full file is encrypted in the vault."
msgstr ""

#: ../../rst/user_guide/vault.rst:293
msgid "Ansible Vault uses an editor to create or modify encrypted files. See :ref:`vault_securing_editor` for some guidance on securing the editor."
msgstr ""

#: ../../rst/user_guide/vault.rst:297
msgid "Advantages and disadvantages of encrypting files"
msgstr ""

#: ../../rst/user_guide/vault.rst:299
msgid "File-level encryption is easy to use. Password rotation for encrypted files is straightforward with the :ref:`rekey <rekeying_files>` command. Encrypting files can hide not only sensitive values, but the names of the variables you use. However, with file-level encryption the contents of files are no longer easy to access and read. This may be a problem with encrypted tasks files. When encrypting a variables file, see :ref:`tip_for_variables_and_vaults` for one way to keep references to these variables in a non-encrypted file. Ansible always decrypts the entire encrypted file when it is when loaded or referenced, because Ansible cannot know if it needs the content unless it decrypts it."
msgstr ""

#: ../../rst/user_guide/vault.rst:304
msgid "Creating encrypted files"
msgstr ""

#: ../../rst/user_guide/vault.rst:306
msgid "To create a new encrypted data file called 'foo.yml' with the 'test' vault password from 'multi_password_file':"
msgstr ""

#: ../../rst/user_guide/vault.rst:312
msgid "The tool launches an editor (whatever editor you have defined with $EDITOR, default editor is vi). Add the content. When you close the editor session, the file is saved as encrypted data. The file header reflects the vault ID used to create it:"
msgstr ""

#: ../../rst/user_guide/vault.rst:318
msgid "To create a new encrypted data file with the vault ID 'my_new_password' assigned to it and be prompted for the password:"
msgstr ""

#: ../../rst/user_guide/vault.rst:324
msgid "Again, add content to the file in the editor and save. Be sure to store the new password you created at the prompt, so you can find it when you want to decrypt that file."
msgstr ""

#: ../../rst/user_guide/vault.rst:329
msgid "Encrypting existing files"
msgstr ""

#: ../../rst/user_guide/vault.rst:331
msgid "To encrypt an existing file, use the :ref:`ansible-vault encrypt <ansible_vault_encrypt>` command. This command can operate on multiple files at once. For example:"
msgstr ""

#: ../../rst/user_guide/vault.rst:337
msgid "To encrypt existing files with the 'project' ID and be prompted for the password:"
msgstr ""

#: ../../rst/user_guide/vault.rst:347
msgid "Viewing encrypted files"
msgstr ""

#: ../../rst/user_guide/vault.rst:349
msgid "To view the contents of an encrypted file without editing it, you can use the :ref:`ansible-vault view <ansible_vault_view>` command:"
msgstr ""

#: ../../rst/user_guide/vault.rst:359
msgid "Editing encrypted files"
msgstr ""

#: ../../rst/user_guide/vault.rst:361
msgid "To edit an encrypted file in place, use the :ref:`ansible-vault edit <ansible_vault_edit>` command. This command decrypts the file to a temporary file, allows you to edit the content, then saves and re-encrypts the content and removes the temporary file when you close the editor. For example:"
msgstr ""

#: ../../rst/user_guide/vault.rst:367
msgid "To edit a file encrypted with the ``vault2`` password file and assigned the vault ID ``pass2``:"
msgstr ""

#: ../../rst/user_guide/vault.rst:377
msgid "Changing the password and/or vault ID on encrypted files"
msgstr ""

#: ../../rst/user_guide/vault.rst:379
msgid "To change the password on an encrypted file or files, use the :ref:`rekey <ansible_vault_rekey>` command:"
msgstr ""

#: ../../rst/user_guide/vault.rst:385
msgid "This command can rekey multiple data files at once and will ask for the original password and also the new password. To set a different ID for the rekeyed files, pass the new ID to ``--new-vault-id``. For example, to rekey a list of files encrypted with the 'preprod1' vault ID from the 'ppold' file to the 'preprod2' vault ID and be prompted for the new password:"
msgstr ""

#: ../../rst/user_guide/vault.rst:395
msgid "Decrypting encrypted files"
msgstr ""

#: ../../rst/user_guide/vault.rst:397
msgid "If you have an encrypted file that you no longer want to keep encrypted, you can permanently decrypt it by running the :ref:`ansible-vault decrypt <ansible_vault_decrypt>` command. This command will save the file unencrypted to the disk, so be sure you do not want to :ref:`edit <ansible_vault_edit>` it instead."
msgstr ""

#: ../../rst/user_guide/vault.rst:407
msgid "Steps to secure your editor"
msgstr ""

#: ../../rst/user_guide/vault.rst:409
msgid "Ansible Vault relies on your configured editor, which can be a source of disclosures. Most editors have ways to prevent loss of data, but these normally rely on extra plain text files that can have a clear text copy of your secrets. Consult your editor documentation to configure the editor to avoid disclosing secure data. The following sections provide some guidance on common editors but should not be taken as a complete guide to securing your editor."
msgstr ""

#: ../../rst/user_guide/vault.rst:413
msgid "vim"
msgstr ""

#: ../../rst/user_guide/vault.rst:415
msgid "You can set the following ``vim`` options in command mode to avoid cases of disclosure. There may be more settings you need to modify to ensure security, especially when using plugins, so consult the ``vim`` documentation."
msgstr ""

#: ../../rst/user_guide/vault.rst:418
msgid "Disable swapfiles that act like an autosave in case of crash or interruption."
msgstr ""

#: ../../rst/user_guide/vault.rst:424 ../../rst/user_guide/vault.rst:458
msgid "Disable creation of backup files."
msgstr ""

#: ../../rst/user_guide/vault.rst:431
msgid "Disable the viminfo file from copying data from your current session."
msgstr ""

#: ../../rst/user_guide/vault.rst:437
msgid "Disable copying to the system clipboard."
msgstr ""

#: ../../rst/user_guide/vault.rst:444
msgid "You can optionally add these settings in ``.vimrc`` for all files, or just specific paths or extensions. See the ``vim`` manual for details."
msgstr ""

#: ../../rst/user_guide/vault.rst:448
msgid "Emacs"
msgstr ""

#: ../../rst/user_guide/vault.rst:450
msgid "You can set the following Emacs options to avoid cases of disclosure. There may be more settings you need to modify to ensure security, especially when using plugins, so consult the Emacs documentation."
msgstr ""

#: ../../rst/user_guide/vault.rst:452
msgid "Do not copy data to the system clipboard."
msgstr ""

#: ../../rst/user_guide/vault.rst:464
msgid "Disable autosave files."
msgstr ""

#: ../../rst/user_guide/vault.rst:475
msgid "Using encrypted variables and files"
msgstr ""

#: ../../rst/user_guide/vault.rst:477
msgid "When you run a task or playbook that uses encrypted variables or files, you must provide the passwords to decrypt the variables or files. You can do this at the command line or in the playbook itself."
msgstr ""

#: ../../rst/user_guide/vault.rst:480
msgid "Passing a single password"
msgstr ""

#: ../../rst/user_guide/vault.rst:482
msgid "If all the encrypted variables and files your task or playbook needs use a single password, you can use the :option:`--ask-vault-pass <ansible-playbook --ask-vault-pass>` or :option:`--vault-password-file <ansible-playbook --vault-password-file>` cli options."
msgstr ""

#: ../../rst/user_guide/vault.rst:484 ../../rst/user_guide/vault.rst:552
msgid "To prompt for the password:"
msgstr ""

#: ../../rst/user_guide/vault.rst:490
msgid "To retrieve the password from the :file:`/path/to/my/vault-password-file` file:"
msgstr ""

#: ../../rst/user_guide/vault.rst:496
msgid "To get the password from the vault password client script :file:`my-vault-password-client.py`:"
msgstr ""

#: ../../rst/user_guide/vault.rst:506
msgid "Passing vault IDs"
msgstr ""

#: ../../rst/user_guide/vault.rst:508
msgid "You can also use the :option:`--vault-id <ansible-playbook --vault-id>` option to pass a single password with its vault label. This approach is clearer when multiple vaults are used within a single inventory."
msgstr ""

#: ../../rst/user_guide/vault.rst:510
msgid "To prompt for the password for the 'dev' vault ID:"
msgstr ""

#: ../../rst/user_guide/vault.rst:516
msgid "To retrieve the password for the 'dev' vault ID from the :file:`dev-password` file:"
msgstr ""

#: ../../rst/user_guide/vault.rst:522
msgid "To get the password for the 'dev' vault ID from the vault password client script :file:`my-vault-password-client.py`:"
msgstr ""

#: ../../rst/user_guide/vault.rst:529
msgid "Passing multiple vault passwords"
msgstr ""

#: ../../rst/user_guide/vault.rst:531
msgid "If your task or playbook requires multiple encrypted variables or files that you encrypted with different vault IDs, you must use the :option:`--vault-id <ansible-playbook --vault-id>` option, passing multiple ``--vault-id`` options to specify the vault IDs ('dev', 'prod', 'cloud', 'db') and sources for the passwords (prompt, file, script). . For example, to use a 'dev' password read from a file and to be prompted for the 'prod' password:"
msgstr ""

#: ../../rst/user_guide/vault.rst:537
msgid "By default the vault ID labels (dev, prod and so on) are only hints. Ansible attempts to decrypt vault content with each password. The password with the same label as the encrypted data will be tried first, after that each vault secret will be tried in the order they were provided on the command line."
msgstr ""

#: ../../rst/user_guide/vault.rst:539
msgid "Where the encrypted data has no label, or the label does not match any of the provided labels, the passwords will be tried in the order they are specified. In the example above, the 'dev' password will be tried first, then the 'prod' password for cases where Ansible doesn't know which vault ID is used to encrypt something."
msgstr ""

#: ../../rst/user_guide/vault.rst:542
msgid "Using ``--vault-id`` without a vault ID"
msgstr ""

#: ../../rst/user_guide/vault.rst:544
msgid "The :option:`--vault-id <ansible-playbook --vault-id>` option can also be used without specifying a vault-id. This behavior is equivalent to :option:`--ask-vault-pass <ansible-playbook --ask-vault-pass>` or :option:`--vault-password-file <ansible-playbook --vault-password-file>` so is rarely used."
msgstr ""

#: ../../rst/user_guide/vault.rst:546
msgid "For example, to use a password file :file:`dev-password`:"
msgstr ""

#: ../../rst/user_guide/vault.rst:558
msgid "To get the password from an executable script :file:`my-vault-password-client.py`:"
msgstr ""

#: ../../rst/user_guide/vault.rst:566
msgid "Configuring defaults for using encrypted content"
msgstr ""

#: ../../rst/user_guide/vault.rst:569
msgid "Setting a default vault ID"
msgstr ""

#: ../../rst/user_guide/vault.rst:571
msgid "If you use one vault ID more frequently than any other, you can set the config option :ref:`DEFAULT_VAULT_IDENTITY_LIST` to specify a default vault ID and password source. Ansible will use the default vault ID and source any time you do not specify :option:`--vault-id <ansible-playbook --vault-id>`. You can set multiple values for this option. Setting multiple values is equivalent to passing multiple :option:`--vault-id <ansible-playbook --vault-id>` cli options."
msgstr ""

#: ../../rst/user_guide/vault.rst:574
msgid "Setting a default password source"
msgstr ""

#: ../../rst/user_guide/vault.rst:576
msgid "If you use one vault password file more frequently than any other, you can set the :ref:`DEFAULT_VAULT_PASSWORD_FILE` config option or the :envvar:`ANSIBLE_VAULT_PASSWORD_FILE` environment variable to specify that file. For example, if you set ``ANSIBLE_VAULT_PASSWORD_FILE=~/.vault_pass.txt``, Ansible will automatically search for the password in that file. This is useful if, for example, you use Ansible from a continuous integration system such as Jenkins."
msgstr ""

#: ../../rst/user_guide/vault.rst:579
msgid "When are encrypted files made visible?"
msgstr ""

#: ../../rst/user_guide/vault.rst:581
msgid "In general, content you encrypt with Ansible Vault remains encrypted after execution. However, there is one exception. If you pass an encrypted file as the ``src`` argument to the :ref:`copy <copy_module>`, :ref:`template <template_module>`, :ref:`unarchive <unarchive_module>`, :ref:`script <script_module>` or :ref:`assemble <assemble_module>` module, the file will not be encrypted on the target host (assuming you supply the correct vault password when you run the play). This behavior is intended and useful. You can encrypt a configuration file or template to avoid sharing the details of your configuration, but when you copy that configuration to servers in your environment, you want it to be decrypted so local users and processes can access it."
msgstr ""

#: ../../rst/user_guide/vault.rst:586
msgid "Speeding up Ansible Vault"
msgstr ""

#: ../../rst/user_guide/vault.rst:588
msgid "If you have many encrypted files, decrypting them at startup may cause a perceptible delay. To speed this up, install the cryptography package:"
msgstr ""

#: ../../rst/user_guide/vault.rst:598
msgid "Format of files encrypted with Ansible Vault"
msgstr ""

#: ../../rst/user_guide/vault.rst:600
msgid "Ansible Vault creates UTF-8 encoded txt files. The file format includes a newline terminated header. For example::"
msgstr ""

#: ../../rst/user_guide/vault.rst:604
msgid "or::"
msgstr ""

#: ../../rst/user_guide/vault.rst:608
msgid "The header contains up to four elements, separated by semi-colons (``;``)."
msgstr ""

#: ../../rst/user_guide/vault.rst:610
msgid "The format ID (``$ANSIBLE_VAULT``). Currently ``$ANSIBLE_VAULT`` is the only valid format ID. The format ID identifies content that is encrypted with Ansible Vault (via vault.is_encrypted_file())."
msgstr ""

#: ../../rst/user_guide/vault.rst:612
msgid "The vault format version (``1.X``). All supported versions of Ansible will currently default to '1.1' or '1.2' if a labeled vault ID is supplied. The '1.0' format is supported for reading only (and will be converted automatically to the '1.1' format on write). The format version is currently used as an exact string compare only (version numbers are not currently 'compared')."
msgstr ""

#: ../../rst/user_guide/vault.rst:614
msgid "The cipher algorithm used to encrypt the data (``AES256``). Currently ``AES256`` is the only supported cipher algorithm. Vault format 1.0 used 'AES', but current code always uses 'AES256'."
msgstr ""

#: ../../rst/user_guide/vault.rst:616
msgid "The vault ID label used to encrypt the data (optional, ``vault-id-label``) For example, if you encrypt a file with ``--vault-id dev@prompt``, the vault-id-label is ``dev``."
msgstr ""

#: ../../rst/user_guide/vault.rst:618
msgid "Note: In the future, the header could change. Fields after the format ID and format version depend on the format version, and future vault format versions may add more cipher algorithm options and/or additional fields."
msgstr ""

#: ../../rst/user_guide/vault.rst:620
msgid "The rest of the content of the file is the 'vaulttext'. The vaulttext is a text armored version of the encrypted ciphertext. Each line is 80 characters wide, except for the last line which may be shorter."
msgstr ""

#: ../../rst/user_guide/vault.rst:624
msgid "Ansible Vault payload format 1.1 - 1.2"
msgstr ""

#: ../../rst/user_guide/vault.rst:626
msgid "The vaulttext is a concatenation of the ciphertext and a SHA256 digest with the result 'hexlifyied'."
msgstr ""

#: ../../rst/user_guide/vault.rst:628
msgid "'hexlify' refers to the ``hexlify()`` method of the Python Standard Library's `binascii <https://docs.python.org/3/library/binascii.html>`_ module."
msgstr ""

#: ../../rst/user_guide/vault.rst:630
msgid "hexlify()'ed result of:"
msgstr ""

#: ../../rst/user_guide/vault.rst:632
msgid "hexlify()'ed string of the salt, followed by a newline (``0x0a``)"
msgstr ""

#: ../../rst/user_guide/vault.rst:633
msgid "hexlify()'ed string of the crypted HMAC, followed by a newline. The HMAC is:"
msgstr ""

#: ../../rst/user_guide/vault.rst:635
msgid "a `RFC2104 <https://www.ietf.org/rfc/rfc2104.txt>`_ style HMAC"
msgstr ""

#: ../../rst/user_guide/vault.rst:637
msgid "inputs are:"
msgstr ""

#: ../../rst/user_guide/vault.rst:639
msgid "The AES256 encrypted ciphertext"
msgstr ""

#: ../../rst/user_guide/vault.rst:640
msgid "A PBKDF2 key. This key, the cipher key, and the cipher IV are generated from:"
msgstr ""

#: ../../rst/user_guide/vault.rst:642
msgid "the salt, in bytes"
msgstr ""

#: ../../rst/user_guide/vault.rst:643
msgid "10000 iterations"
msgstr ""

#: ../../rst/user_guide/vault.rst:644
msgid "SHA256() algorithm"
msgstr ""

#: ../../rst/user_guide/vault.rst:645
msgid "the first 32 bytes are the cipher key"
msgstr ""

#: ../../rst/user_guide/vault.rst:646
msgid "the second 32 bytes are the HMAC key"
msgstr ""

#: ../../rst/user_guide/vault.rst:647
msgid "remaining 16 bytes are the cipher IV"
msgstr ""

#: ../../rst/user_guide/vault.rst:649
msgid "hexlify()'ed string of the ciphertext. The ciphertext is:"
msgstr ""

#: ../../rst/user_guide/vault.rst:651
msgid "AES256 encrypted data. The data is encrypted using:"
msgstr ""

#: ../../rst/user_guide/vault.rst:653
msgid "AES-CTR stream cipher"
msgstr ""

#: ../../rst/user_guide/vault.rst:654
msgid "cipher key"
msgstr ""

#: ../../rst/user_guide/vault.rst:655
msgid "IV"
msgstr ""

#: ../../rst/user_guide/vault.rst:656
msgid "a 128 bit counter block seeded from an integer IV"
msgstr ""

#: ../../rst/user_guide/vault.rst:657
msgid "the plaintext"
msgstr ""

#: ../../rst/user_guide/vault.rst:659
msgid "the original plaintext"
msgstr ""

#: ../../rst/user_guide/vault.rst:660
msgid "padding up to the AES256 blocksize. (The data used for padding is based on `RFC5652 <https://tools.ietf.org/html/rfc5652#section-6.3>`_)"
msgstr ""

#: ../../rst/user_guide/windows.rst:4
msgid "Windows Guides"
msgstr ""

#: ../../rst/user_guide/windows.rst:6
msgid "The following sections provide information on managing Windows hosts with Ansible."
msgstr ""

#: ../../rst/user_guide/windows.rst:9
msgid "Because Windows is a non-POSIX-compliant operating system, there are differences between how Ansible interacts with them and the way Windows works. These guides will highlight some of the differences between Linux/Unix hosts and hosts running Windows."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:2
msgid "Desired State Configuration"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:8
msgid "What is Desired State Configuration?"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:9
msgid "Desired State Configuration, or DSC, is a tool built into PowerShell that can be used to define a Windows host setup through code. The overall purpose of DSC is the same as Ansible, it is just executed in a different manner. Since Ansible 2.4, the ``win_dsc`` module has been added and can be used to leverage existing DSC resources when interacting with a Windows host."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:15
msgid "More details on DSC can be viewed at `DSC Overview <https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview>`_."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:18
#: ../../rst/user_guide/windows_setup.rst:11
msgid "Host Requirements"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:19
msgid "To use the ``win_dsc`` module, a Windows host must have PowerShell v5.0 or newer installed. All supported hosts, except for Windows Server 2008 (non R2) can be upgraded to PowerShell v5."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:23
msgid "Once the PowerShell requirements have been met, using DSC is as simple as creating a task with the ``win_dsc`` module."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:27
msgid "Why Use DSC?"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:28
msgid "DSC and Ansible modules have a common goal which is to define and ensure the state of a resource. Because of this, resources like the DSC `File resource <https://docs.microsoft.com/en-us/powershell/scripting/dsc/reference/resources/windows/fileresource>`_ and Ansible ``win_file`` can be used to achieve the same result. Deciding which to use depends on the scenario."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:34
msgid "Reasons for using an Ansible module over a DSC resource:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:36
msgid "The host does not support PowerShell v5.0, or it cannot easily be upgraded"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:37
msgid "The DSC resource does not offer a feature present in an Ansible module. For example win_regedit can manage the ``REG_NONE`` property type, while the DSC ``Registry`` resource cannot"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:40
msgid "DSC resources have limited check mode support, while some Ansible modules have better checks"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:42
msgid "DSC resources do not support diff mode, while some Ansible modules do"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:43
msgid "Custom resources require further installation steps to be run on the host beforehand, while Ansible modules are built-in to Ansible"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:45
msgid "There are bugs in a DSC resource where an Ansible module works"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:47
msgid "Reasons for using a DSC resource over an Ansible module:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:49
msgid "The Ansible module does not support a feature present in a DSC resource"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:50
msgid "There is no Ansible module available"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:51
msgid "There are bugs in an existing Ansible module"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:53
msgid "In the end, it doesn't matter whether the task is performed with DSC or an Ansible module; what matters is that the task is performed correctly and the playbooks are still readable. If you have more experience with DSC over Ansible and it does the job, just use DSC for that task."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:59
msgid "How to Use DSC?"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:60
msgid "The ``win_dsc`` module takes in a free-form of options so that it changes according to the resource it is managing. A list of built in resources can be found at `resources <https://docs.microsoft.com/en-us/powershell/scripting/dsc/resources/resources>`_."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:64
msgid "Using the `Registry <https://docs.microsoft.com/en-us/powershell/scripting/dsc/reference/resources/windows/registryresource>`_ resource as an example, this is the DSC definition as documented by Microsoft:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:81
msgid "When defining the task, ``resource_name`` must be set to the DSC resource being used - in this case the ``resource_name`` should be set to ``Registry``. The ``module_version`` can refer to a specific version of the DSC resource installed; if left blank it will default to the latest version. The other options are parameters that are used to define the resource, such as ``Key`` and ``ValueName``. While the options in the task are not case sensitive, keeping the case as-is is recommended because it makes it easier to distinguish DSC resource options from Ansible's ``win_dsc`` options."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:90
msgid "This is what the Ansible task version of the above DSC Registry resource would look like:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:102
msgid "Starting in Ansible 2.8, the ``win_dsc`` module automatically validates the input options from Ansible with the DSC definition. This means Ansible will fail if the option name is incorrect, a mandatory option is not set, or the value is not a valid choice. When running Ansible with a verbosity level of 3 or more (``-vvv``), the return value will contain the possible invocation options based on the ``resource_name`` specified. Here is an example of the invocation output for the above ``Registry`` task:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:157
msgid "The ``invocation.module_args`` key shows the actual values that were set as well as other possible values that were not set. Unfortunately this will not show the default value for a DSC property, only what was set from the Ansible task. Any ``*_password`` option will be masked in the output for security reasons, if there are any other sensitive module options, set ``no_log: True`` on the task to stop all task output from being logged."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:166
msgid "Property Types"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:167
msgid "Each DSC resource property has a type that is associated with it. Ansible will try to convert the defined options to the correct type during execution. For simple types like ``[string]`` and ``[bool]`` this is a simple operation, but complex types like ``[PSCredential]`` or arrays (like ``[string[]]``) this require certain rules."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:174
msgid "PSCredential"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:175
msgid "A ``[PSCredential]`` object is used to store credentials in a secure way, but Ansible has no way to serialize this over JSON. To set a DSC PSCredential property, the definition of that parameter should have two entries that are suffixed with ``_username`` and ``_password`` for the username and password respectively. For example:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:189
msgid "On versions of Ansible older than 2.8, you should set ``no_log: yes`` on the task definition in Ansible to ensure any credentials used are not stored in any log file or console output."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:193
msgid "A ``[PSCredential]`` is defined with ``EmbeddedInstance(\"MSFT_Credential\")`` in a DSC resource MOF definition."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:197
msgid "CimInstance Type"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:198
msgid "A ``[CimInstance]`` object is used by DSC to store a dictionary object based on a custom class defined by that resource. Defining a value that takes in a ``[CimInstance]`` in YAML is the same as defining a dictionary in YAML. For example, to define a ``[CimInstance]`` value in Ansible:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:212
msgid "In the above example, the CIM instance is a representation of the class `MSFT_xWebAuthenticationInformation <https://github.com/dsccommunity/xWebAdministration/blob/master/source/DSCResources/MSFT_xWebSite/MSFT_xWebSite.schema.mof>`_. This class accepts four boolean variables, ``Anonymous``, ``Basic``, ``Digest``, and ``Windows``. The keys to use in a ``[CimInstance]`` depend on the class it represents. Please read through the documentation of the resource to determine the keys that can be used and the types of each key value. The class definition is typically located in the ``<resource name>.schema.mof``."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:221
msgid "HashTable Type"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:222
msgid "A ``[HashTable]`` object is also a dictionary but does not have a strict set of keys that can/need to be defined. Like a ``[CimInstance]``, define it like a normal dictionary value in YAML. A ``[HashTable]]`` is defined with ``EmbeddedInstance(\"MSFT_KeyValuePair\")`` in a DSC resource MOF definition."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:228
msgid "Arrays"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:229
msgid "Simple type arrays like ``[string[]]`` or ``[UInt32[]]`` are defined as a list or as a comma separated string which are then cast to their type. Using a list is recommended because the values are not manually parsed by the ``win_dsc`` module before being passed to the DSC engine. For example, to define a simple type array in Ansible:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:250
msgid "Complex type arrays like ``[CimInstance[]]`` (array of dicts), can be defined like this example:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:268
msgid "The above example, is an array with two values of the class `MSFT_xWebBindingInformation <https://github.com/dsccommunity/xWebAdministration/blob/master/source/DSCResources/MSFT_xWebSite/MSFT_xWebSite.schema.mof>`_. When defining a ``[CimInstance[]]``, be sure to read the resource documentation to find out what keys to use in the definition."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:273
msgid "DateTime"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:274
msgid "A ``[DateTime]`` object is a DateTime string representing the date and time in the `ISO 8601 <https://www.w3.org/TR/NOTE-datetime>`_ date time format. The value for a ``[DateTime]`` field should be quoted in YAML to ensure the string is properly serialized to the Windows host. Here is an example of how to define a ``[DateTime]`` value in Ansible:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:291
msgid "All the values above are equal to a UTC date time of February 22nd 2019 at 1:57pm with 31 seconds and 2311892 milliseconds."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:295
msgid "Run As Another User"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:296
msgid "By default, DSC runs each resource as the SYSTEM account and not the account that Ansible use to run the module. This means that resources that are dynamically loaded based on a user profile, like the ``HKEY_CURRENT_USER`` registry hive, will be loaded under the ``SYSTEM`` profile. The parameter ``PsDscRunAsCredential`` is a parameter that can be set for every DSC resource force the DSC engine to run under a different account. As ``PsDscRunAsCredential`` has a type of ``PSCredential``, it is defined with the ``_username`` and ``_password`` suffix."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:305
msgid "Using the Registry resource type as an example, this is how to define a task to access the ``HKEY_CURRENT_USER`` hive of the Ansible user:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:322
msgid "Custom DSC Resources"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:323
msgid "DSC resources are not limited to the built-in options from Microsoft. Custom modules can be installed to manage other resources that are not usually available."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:327
msgid "Finding Custom DSC Resources"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:328
msgid "You can use the `PSGallery <https://www.powershellgallery.com/>`_ to find custom resources, along with documentation on how to install them  on a Windows host."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:331
msgid "The ``Find-DscResource`` cmdlet can also be used to find custom resources. For example:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:341
msgid "DSC resources developed by Microsoft that start with ``x``, means the resource is experimental and comes with no support."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:345
msgid "Installing a Custom Resource"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:346
msgid "There are three ways that a DSC resource can be installed on a host:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:348
msgid "Manually with the ``Install-Module`` cmdlet"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:349
msgid "Using the ``win_psmodule`` Ansible module"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:350
msgid "Saving the module manually and copying it another host"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:352
msgid "This is an example of installing the ``xWebAdministration`` resources using ``win_psmodule``:"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:362
msgid "Once installed, the win_dsc module will be able to use the resource by referencing it with the ``resource_name`` option."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:365
msgid "The first two methods above only work when the host has access to the internet. When a host does not have internet access, the module must first be installed using the methods above on another host with internet access and then copied across. To save a module to a local filepath, the following PowerShell cmdlet can be run::"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:373
msgid "This will create a folder called ``xWebAdministration`` in ``C:\\temp`` which can be copied to any host. For PowerShell to see this offline resource, it must be copied to a directory set in the ``PSModulePath`` environment variable. In most cases the path ``C:\\Program Files\\WindowsPowerShell\\Module`` is set through this variable, but the ``win_path`` module can be used to add different paths."
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:381
msgid "Examples"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:383
msgid "Extract a zip file"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:395
msgid "Create a directory"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:418
msgid "Interact with Azure"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:441
msgid "Setup IIS Website"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:500
#: ../../rst/user_guide/windows_setup.rst:568
#: ../../rst/user_guide/windows_usage.rst:508
#: ../../rst/user_guide/windows_winrm.rst:908
msgid ":ref:`List of Windows Modules <windows_modules>`"
msgstr ""

#: ../../rst/user_guide/windows_dsc.rst:501
#: ../../rst/user_guide/windows_setup.rst:569
#: ../../rst/user_guide/windows_usage.rst:509
#: ../../rst/user_guide/windows_winrm.rst:909
msgid "Windows specific module list, all implemented in PowerShell"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:4
msgid "Windows Frequently Asked Questions"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:6
msgid "Here are some commonly asked questions in regards to Ansible and Windows and their answers."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:9
msgid "This document covers questions about managing Microsoft Windows servers with Ansible. For questions about Ansible Core, please see the :ref:`general FAQ page <ansible_faq>`."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:14
msgid "Does Ansible work with Windows XP or Server 2003?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:15
msgid "Ansible does not work with Windows XP or Server 2003 hosts. Ansible does work with these Windows operating system versions:"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:17
msgid "Windows Server 2008 :sup:`1`"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:18
msgid "Windows Server 2008 R2 :sup:`1`"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:19
msgid "Windows Server 2012"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:20
msgid "Windows Server 2012 R2"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:21
msgid "Windows Server 2016"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:22
msgid "Windows Server 2019"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:23
msgid "Windows 7 :sup:`1`"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:24
msgid "Windows 8.1"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:25
msgid "Windows 10"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:27
msgid "1 - See the :ref:`Server 2008 FAQ <windows_faq_server2008>` entry for more details."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:29
msgid "Ansible also has minimum PowerShell version requirements - please see :ref:`windows_setup` for the latest information."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:35
msgid "Are Server 2008, 2008 R2 and Windows 7 supported?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:36
msgid "Microsoft ended Extended Support for these versions of Windows on January 14th, 2020, and Ansible deprecated official support in the 2.10 release. No new feature development will occur targeting these operating systems, and automated testing has ceased. However, existing modules and features will likely continue to work, and simple pull requests to resolve issues with these Windows versions may be accepted."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:39
msgid "Can I manage Windows Nano Server with Ansible?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:40
msgid "Ansible does not currently work with Windows Nano Server, since it does not have access to the full .NET Framework that is used by the majority of the modules and internal components."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:45
msgid "Can Ansible run on Windows?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:46
msgid "No, Ansible can only manage Windows hosts. Ansible cannot run on a Windows host natively, though it can run under the Windows Subsystem for Linux (WSL)."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:49
msgid "The Windows Subsystem for Linux is not supported by Ansible and should not be used for production systems."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:52
msgid "To install Ansible on WSL, the following commands can be run in the bash terminal:"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:61
msgid "To run Ansible from source instead of a release on the WSL, simply uninstall the pip installed version and then clone the git repo."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:74
msgid "Can I use SSH keys to authenticate to Windows hosts?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:75
msgid "You cannot use SSH keys with the WinRM or PSRP connection plugins. These connection plugins use X509 certificates for authentication instead of the SSH key pairs that SSH uses."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:79
msgid "The way X509 certificates are generated and mapped to a user is different from the SSH implementation; consult the :ref:`windows_winrm` documentation for more information."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:83
msgid "Ansible 2.8 has added an experimental option to use the SSH connection plugin, which uses SSH keys for authentication, for Windows servers. See :ref:`this question <windows_faq_ssh>` for more information."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:90
msgid "Why can I run a command locally that does not work under Ansible?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:91
msgid "Ansible executes commands through WinRM. These processes are different from running a command locally in these ways:"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:94
msgid "Unless using an authentication option like CredSSP or Kerberos with credential delegation, the WinRM process does not have the ability to delegate the user's credentials to a network resource, causing ``Access is Denied`` errors."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:99
msgid "All processes run under WinRM are in a non-interactive session. Applications that require an interactive session will not work."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:102
msgid "When running through WinRM, Windows restricts access to internal Windows APIs like the Windows Update API and DPAPI, which some installers and programs rely on."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:106
msgid "Some ways to bypass these restrictions are to:"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:108
msgid "Use ``become``, which runs a command as it would when run locally. This will bypass most WinRM restrictions, as Windows is unaware the process is running under WinRM when ``become`` is used. See the :ref:`become` documentation for more information."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:113
msgid "Use a scheduled task, which can be created with ``win_scheduled_task``. Like ``become``, it will bypass all WinRM restrictions, but it can only be used to run commands, not modules."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:117
msgid "Use ``win_psexec`` to run a command on the host. PSExec does not use WinRM and so will bypass any of the restrictions."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:120
msgid "To access network resources without any of these workarounds, you can use CredSSP or Kerberos with credential delegation enabled."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:123
msgid "See :ref:`become` more info on how to use become. The limitations section at :ref:`windows_winrm` has more details around WinRM limitations."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:127
msgid "This program won't install on Windows with Ansible"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:128
msgid "See :ref:`this question <windows_faq_winrm>` for more information about WinRM limitations."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:131
msgid "What Windows modules are available?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:132
msgid "Most of the Ansible modules in Ansible Core are written for a combination of Linux/Unix machines and arbitrary web services. These modules are written in Python and most of them do not work on Windows."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:136
msgid "Because of this, there are dedicated Windows modules that are written in PowerShell and are meant to be run on Windows hosts. A list of these modules can be found :ref:`here <windows_modules>`."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:140
msgid "In addition, the following Ansible Core modules/action-plugins work with Windows:"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:142
msgid "add_host"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:143
msgid "assert"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:144
msgid "async_status"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:145
msgid "debug"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:146
msgid "fail"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:147
msgid "fetch"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:148
msgid "group_by"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:149
msgid "include"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:150
msgid "include_role"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:152
msgid "meta"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:153
msgid "pause"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:154
msgid "raw"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:155
msgid "script"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:156
msgid "set_fact"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:157
msgid "set_stats"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:158
msgid "setup"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:159
msgid "slurp"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:160
msgid "template (also: win_template)"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:161
msgid "wait_for_connection"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:164
msgid "Can I run Python modules on Windows hosts?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:165
msgid "No, the WinRM connection protocol is set to use PowerShell modules, so Python modules will not work. A way to bypass this issue to use ``delegate_to: localhost`` to run a Python module on the Ansible controller. This is useful if during a playbook, an external service needs to be contacted and there is no equivalent Windows module available."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:174
msgid "Can I connect to Windows hosts over SSH?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:175
msgid "Ansible 2.8 has added an experimental option to use the SSH connection plugin to manage Windows hosts. To connect to Windows hosts over SSH, you must install and configure the `Win32-OpenSSH <https://github.com/PowerShell/Win32-OpenSSH>`_ fork that is in development with Microsoft on the Windows host(s). While most of the basics should work with SSH, ``Win32-OpenSSH`` is rapidly changing, with new features added and bugs fixed in every release. It is highly recommend you `install <https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH>`_ the latest release of ``Win32-OpenSSH`` from the GitHub Releases page when using it with Ansible on Windows hosts."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:184
msgid "To use SSH as the connection to a Windows host, set the following variables in the inventory::"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:193
msgid "The value for ``ansible_shell_type`` should either be ``cmd`` or ``powershell``. Use ``cmd`` if the ``DefaultShell`` has not been configured on the SSH service and ``powershell`` if that has been set as the ``DefaultShell``."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:198
msgid "Why is connecting to a Windows host via SSH failing?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:199
msgid "Unless you are using ``Win32-OpenSSH`` as described above, you must connect to Windows hosts using :ref:`windows_winrm`. If your Ansible output indicates that SSH was used, either you did not set the connection vars properly or the host is not inheriting them correctly."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:203
msgid "Make sure ``ansible_connection: winrm`` is set in the inventory for the Windows host(s)."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:207
msgid "Why are my credentials being rejected?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:208
msgid "This can be due to a myriad of reasons unrelated to incorrect credentials."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:210
msgid "See HTTP 401/Credentials Rejected at :ref:`windows_setup` for a more detailed guide of this could mean."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:214
msgid "Why am I getting an error SSL CERTIFICATE_VERIFY_FAILED?"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:215
msgid "When the Ansible controller is running on Python 2.7.9+ or an older version of Python that has backported SSLContext (like Python 2.7.5 on RHEL 7), the controller will attempt to validate the certificate WinRM is using for an HTTPS connection. If the certificate cannot be validated (such as in the case of a self signed cert), it will fail the verification process."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:221
msgid "To ignore certificate validation, add ``ansible_winrm_server_cert_validation: ignore`` to inventory for the Windows host."
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:227
msgid ":ref:`windows`"
msgstr ""

#: ../../rst/user_guide/windows_faq.rst:228
msgid "The Windows documentation index"
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:4
msgid "Windows performance"
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:5
msgid "This document offers some performance optimizations you might like to apply to your Windows hosts to speed them up specifically in the context of using Ansible with them, and generally."
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:10
msgid "Optimise PowerShell performance to reduce Ansible task overhead"
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:11
msgid "To speed up the startup of PowerShell by around 10x, run the following PowerShell snippet in an Administrator session. Expect it to take tens of seconds."
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:17
msgid "If native images have already been created by the ngen task or service, you will observe no difference in performance (but this snippet will at that point execute faster than otherwise)."
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:42
msgid "PowerShell is used by every Windows Ansible module. This optimisation reduces the time PowerShell takes to start up, removing that overhead from every invocation."
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:45
msgid "This snippet uses `the native image generator, ngen <https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator#WhenToUse>`_ to pre-emptively create native images for the assemblies that PowerShell relies on."
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:49
msgid "Fix high-CPU-on-boot for VMs/cloud instances"
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:50
msgid "If you are creating golden images to spawn instances from, you can avoid a disruptive high CPU task near startup via `processing the ngen queue <https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator#native-image-service>`_ within your golden image creation, if you know the CPU types won't change between golden image build process and runtime."
msgstr ""

#: ../../rst/user_guide/windows_performance.rst:55
msgid "Place the following near the end of your playbook, bearing in mind the factors that can cause native images to be invalidated (`see MSDN <https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator#native-images-and-jit-compilation>`_)."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:4
msgid "Setting up a Windows Host"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:5
msgid "This document discusses the setup that is required before Ansible can communicate with a Microsoft Windows host."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:12
msgid "For Ansible to communicate to a Windows host and use Windows modules, the Windows host must meet these requirements:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:15
msgid "Ansible can generally manage Windows versions under current and extended support from Microsoft. Ansible can manage desktop OSs including Windows 7, 8.1, and 10, and server OSs including Windows Server 2008, 2008 R2, 2012, 2012 R2, 2016, and 2019."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:20
msgid "Ansible requires PowerShell 3.0 or newer and at least .NET 4.0 to be installed on the Windows host."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:23
msgid "A WinRM listener should be created and activated. More details for this can be found below."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:26
msgid "While these are the base requirements for Ansible connectivity, some Ansible modules have additional requirements, such as a newer OS or PowerShell version. Please consult the module's documentation page to determine whether a host meets those requirements."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:32
msgid "Upgrading PowerShell and .NET Framework"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:33
msgid "Ansible requires PowerShell version 3.0 and .NET Framework 4.0 or newer to function on older operating systems like Server 2008 and Windows 7. The base image does not meet this requirement. You can use the `Upgrade-PowerShell.ps1 <https://github.com/jborean93/ansible-windows/blob/master/scripts/Upgrade-PowerShell.ps1>`_ script to update these."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:36
msgid "This is an example of how to run this script from PowerShell:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:51
msgid "Once completed, you will need to remove auto logon and set the execution policy back to the default of ``Restricted``. You can do this with the following PowerShell commands:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:65
msgid "The script works by checking to see what programs need to be installed (such as .NET Framework 4.5.2) and what PowerShell version is required. If a reboot is required and the ``username`` and ``password`` parameters are set, the script will automatically reboot and logon when it comes back up from the reboot. The script will continue until no more actions are required and the PowerShell version matches the target version. If the ``username`` and ``password`` parameters are not set, the script will prompt the user to manually reboot and logon when required. When the user is next logged in, the script will continue where it left off and the process continues until no more actions are required."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:76
msgid "If running on Server 2008, then SP2 must be installed. If running on Server 2008 R2 or Windows 7, then SP1 must be installed."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:79
msgid "Windows Server 2008 can only install PowerShell 3.0; specifying a newer version will result in the script failing."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:82
msgid "The ``username`` and ``password`` parameters are stored in plain text in the registry. Make sure the cleanup commands are run after the script finishes to ensure no credentials are still stored on the host."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:87
msgid "WinRM Memory Hotfix"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:88
msgid "When running on PowerShell v3.0, there is a bug with the WinRM service that limits the amount of memory available to WinRM. Without this hotfix installed, Ansible will fail to execute certain commands on the Windows host. These hotfixes should be installed as part of the system bootstrapping or imaging process. The script `Install-WMF3Hotfix.ps1 <https://github.com/jborean93/ansible-windows/blob/master/scripts/Install-WMF3Hotfix.ps1>`_ can be used to install the hotfix on affected hosts."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:94
msgid "The following PowerShell command will install the hotfix:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:104
msgid "For more details, please refer to the `Hotfix document <https://support.microsoft.com/en-us/help/2842230/out-of-memory-error-on-a-computer-that-has-a-customized-maxmemorypersh>`_ from Microsoft."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:107
msgid "WinRM Setup"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:108
msgid "Once Powershell has been upgraded to at least version 3.0, the final step is for the WinRM service to be configured so that Ansible can connect to it. There are two main components of the WinRM service that governs how Ansible can interface with the Windows host: the ``listener`` and the ``service`` configuration settings."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:113
msgid "Details about each component can be read below, but the script `ConfigureRemotingForAnsible.ps1 <https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1>`_ can be used to set up the basics. This script sets up both HTTP and HTTPS listeners with a self-signed certificate and enables the ``Basic`` authentication option on the service."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:119
msgid "To use this script, run the following in PowerShell:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:130
msgid "There are different switches and parameters (like ``-EnableCredSSP`` and ``-ForceNewSSLCert``) that can be set alongside this script. The documentation for these options are located at the top of the script itself."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:134
msgid "The ConfigureRemotingForAnsible.ps1 script is intended for training and development purposes only and should not be used in a production environment, since it enables settings (like ``Basic`` authentication) that can be inherently insecure."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:140
msgid "WinRM Listener"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:141
msgid "The WinRM services listens for requests on one or more ports. Each of these ports must have a listener created and configured."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:144
msgid "To view the current listeners that are running on the WinRM service, run the following command:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:151
#: ../../rst/user_guide/windows_setup.rst:263
msgid "This will output something like::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:175
msgid "In the example above there are two listeners activated; one is listening on port 5985 over HTTP and the other is listening on port 5986 over HTTPS. Some of the key options that are useful to understand are:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:179
msgid "``Transport``: Whether the listener is run over HTTP or HTTPS, it is recommended to use a listener over HTTPS as the data is encrypted without any further changes required."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:183
msgid "``Port``: The port the listener runs on, by default it is ``5985`` for HTTP and ``5986`` for HTTPS. This port can be changed to whatever is required and corresponds to the host var ``ansible_port``."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:187
msgid "``URLPrefix``: The URL prefix to listen on, by default it is ``wsman``. If this is changed, the host var ``ansible_winrm_path`` must be set to the same value."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:191
msgid "``CertificateThumbprint``: If running over an HTTPS listener, this is the thumbprint of the certificate in the Windows Certificate Store that is used in the connection. To get the details of the certificate itself, run this command with the relevant certificate thumbprint in PowerShell::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:200
msgid "Setup WinRM Listener"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:201
msgid "There are three ways to set up a WinRM listener:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:203
msgid "Using ``winrm quickconfig`` for HTTP or ``winrm quickconfig -transport:https`` for HTTPS. This is the easiest option to use when running outside of a domain environment and a simple listener is required. Unlike the other options, this process also has the added benefit of opening up the Firewall for the ports required and starts the WinRM service."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:209
msgid "Using Group Policy Objects. This is the best way to create a listener when the host is a member of a domain because the configuration is done automatically without any user input. For more information on group policy objects, see the `Group Policy Objects documentation <https://msdn.microsoft.com/en-us/library/aa374162(v=vs.85).aspx>`_."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:214
msgid "Using PowerShell to create the listener with a specific configuration. This can be done by running the following PowerShell commands:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:229
msgid "To see the other options with this PowerShell cmdlet, see `New-WSManInstance <https://docs.microsoft.com/en-us/powershell/module/microsoft.wsman.management/new-wsmaninstance?view=powershell-5.1>`_."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:232
msgid "When creating an HTTPS listener, an existing certificate needs to be created and stored in the ``LocalMachine\\My`` certificate store. Without a certificate being present in this store, most commands will fail."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:237
msgid "Delete WinRM Listener"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:238
msgid "To remove a WinRM listener::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:246
msgid "The ``Keys`` object is an array of strings, so it can contain different values. By default it contains a key for ``Transport=`` and ``Address=`` which correspond to the values from winrm enumerate winrm/config/Listeners."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:251
msgid "WinRM Service Options"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:252
msgid "There are a number of options that can be set to control the behavior of the WinRM service component, including authentication options and memory settings."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:255
msgid "To get an output of the current service configuration options, run the following command:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:299
msgid "While many of these options should rarely be changed, a few can easily impact the operations over WinRM and are useful to understand. Some of the important options are:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:303
msgid "``Service\\AllowUnencrypted``: This option defines whether WinRM will allow traffic that is run over HTTP without message encryption. Message level encryption is only possible when ``ansible_winrm_transport`` is ``ntlm``, ``kerberos`` or ``credssp``. By default this is ``false`` and should only be set to ``true`` when debugging WinRM messages."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:309
msgid "``Service\\Auth\\*``: These flags define what authentication options are allowed with the WinRM service. By default, ``Negotiate (NTLM)`` and ``Kerberos`` are enabled."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:313
msgid "``Service\\Auth\\CbtHardeningLevel``: Specifies whether channel binding tokens are not verified (None), verified but not required (Relaxed), or verified and required (Strict). CBT is only used when connecting with NTLM or Kerberos over HTTPS."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:318
msgid "``Service\\CertificateThumbprint``: This is the thumbprint of the certificate used to encrypt the TLS channel used with CredSSP authentication. By default this is empty; a self-signed certificate is generated when the WinRM service starts and is used in the TLS process."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:323
msgid "``Winrs\\MaxShellRunTime``: This is the maximum time, in milliseconds, that a remote command is allowed to execute."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:326
msgid "``Winrs\\MaxMemoryPerShellMB``: This is the maximum amount of memory allocated per shell, including the shell's child processes."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:329
msgid "To modify a setting under the ``Service`` key in PowerShell::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:337
msgid "To modify a setting under the ``Winrs`` key in PowerShell::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:345
msgid "If running in a domain environment, some of these options are set by GPO and cannot be changed on the host itself. When a key has been configured with GPO, it contains the text ``[Source=\"GPO\"]`` next to the value."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:350
msgid "Common WinRM Issues"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:351
msgid "Because WinRM has a wide range of configuration options, it can be difficult to setup and configure. Because of this complexity, issues that are shown by Ansible could in fact be issues with the host setup instead."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:355
msgid "One easy way to determine whether a problem is a host issue is to run the following command from another Windows host to connect to the target Windows host::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:373
msgid "If this fails, the issue is probably related to the WinRM setup. If it works, the issue may not be related to the WinRM setup; please continue reading for more troubleshooting suggestions."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:376
msgid "HTTP 401/Credentials Rejected"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:377
msgid "A HTTP 401 error indicates the authentication process failed during the initial connection. Some things to check for this are:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:380
msgid "Verify that the credentials are correct and set properly in your inventory with ``ansible_user`` and ``ansible_password``"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:383
msgid "Ensure that the user is a member of the local Administrators group or has been explicitly granted access (a connection test with the ``winrs`` command can be used to rule this out)."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:387
msgid "Make sure that the authentication option set by ``ansible_winrm_transport`` is enabled under ``Service\\Auth\\*``"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:390
msgid "If running over HTTP and not HTTPS, use ``ntlm``, ``kerberos`` or ``credssp`` with ``ansible_winrm_message_encryption: auto`` to enable message encryption. If using another authentication option or if the installed pywinrm version cannot be upgraded, the ``Service\\AllowUnencrypted`` can be set to ``true`` but this is only recommended for troubleshooting"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:396
msgid "Ensure the downstream packages ``pywinrm``, ``requests-ntlm``, ``requests-kerberos``, and/or ``requests-credssp`` are up to date using ``pip``."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:399
msgid "If using Kerberos authentication, ensure that ``Service\\Auth\\CbtHardeningLevel`` is not set to ``Strict``."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:402
msgid "When using Basic or Certificate authentication, make sure that the user is a local account and not a domain account. Domain accounts do not work with Basic and Certificate authentication."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:407
msgid "HTTP 500 Error"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:408
msgid "These indicate an error has occurred with the WinRM service. Some things to check for include:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:411
msgid "Verify that the number of current open shells has not exceeded either ``WinRsMaxShellsPerUser`` or any of the other Winrs quotas haven't been exceeded."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:416
msgid "Timeout Errors"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:417
msgid "These usually indicate an error with the network connection where Ansible is unable to reach the host. Some things to check for include:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:420
msgid "Make sure the firewall is not set to block the configured WinRM listener ports"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:421
msgid "Ensure that a WinRM listener is enabled on the port and path set by the host vars"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:422
msgid "Ensure that the ``winrm`` service is running on the Windows host and configured for automatic start"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:426
msgid "Connection Refused Errors"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:427
msgid "These usually indicate an error when trying to communicate with the WinRM service on the host. Some things to check for:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:430
msgid "Ensure that the WinRM service is up and running on the host. Use ``(Get-Service -Name winrm).Status`` to get the status of the service."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:432
msgid "Check that the host firewall is allowing traffic over the WinRM port. By default this is ``5985`` for HTTP and ``5986`` for HTTPS."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:435
msgid "Sometimes an installer may restart the WinRM or HTTP service and cause this error. The best way to deal with this is to use ``win_psexec`` from another Windows host."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:440
msgid "Failure to Load Builtin Modules"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:441
msgid "If powershell fails with an error message similar to ``The 'Out-String' command was found in the module 'Microsoft.PowerShell.Utility', but the module could not be loaded.`` then there could be a problem trying to access all the paths specified by the ``PSModulePath`` environment variable. A common cause of this issue is that the ``PSModulePath`` environment variable contains a UNC path to a file share and because of the double hop/credential delegation issue the Ansible process cannot access these folders. The way around this problems is to either:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:447
msgid "Remove the UNC path from the ``PSModulePath`` environment variable, or"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:448
msgid "Use an authentication option that supports credential delegation like ``credssp`` or ``kerberos`` with credential delegation enabled"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:450
msgid "See `KB4076842 <https://support.microsoft.com/en-us/help/4076842>`_ for more information on this problem."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:454
msgid "Windows SSH Setup"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:455
msgid "Ansible 2.8 has added an experimental SSH connection for Windows managed nodes."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:458
msgid "Use this feature at your own risk! Using SSH with Windows is experimental, the implementation may make backwards incompatible changes in feature releases. The server side components can be unreliable depending on the version that is installed."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:464
msgid "Installing Win32-OpenSSH"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:465
msgid "The first step to using SSH with Windows is to install the `Win32-OpenSSH <https://github.com/PowerShell/Win32-OpenSSH>`_ service on the Windows host. Microsoft offers a way to install ``Win32-OpenSSH`` through a Windows capability but currently the version that is installed through this process is too old to work with Ansible. To install ``Win32-OpenSSH`` for use with Ansible, select one of these three installation options:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:471
msgid "Manually install the service, following the `install instructions <https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH>`_ from Microsoft."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:474
msgid "Install the `openssh <https://chocolatey.org/packages/openssh>`_ package using Chocolatey::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:478
msgid "Use ``win_chocolatey`` to install the service::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:486
msgid "Use an existing Ansible Galaxy role like `jborean93.win_openssh <https://galaxy.ansible.com/jborean93/win_openssh>`_::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:499
msgid "``Win32-OpenSSH`` is still a beta product and is constantly being updated to include new features and bugfixes. If you are using SSH as a connection option for Windows, it is highly recommend you install the latest release from one of the 3 methods above."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:505
msgid "Configuring the Win32-OpenSSH shell"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:507
msgid "By default ``Win32-OpenSSH`` will use ``cmd.exe`` as a shell. To configure a different shell, use an Ansible task to define the registry setting::"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:526
msgid "Win32-OpenSSH Authentication"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:527
msgid "Win32-OpenSSH authentication with Windows is similar to SSH authentication on Unix/Linux hosts. You can use a plaintext password or SSH public key authentication, add public keys to an ``authorized_key`` file in the ``.ssh`` folder of the user's profile directory, and configure the service using the ``sshd_config`` file used by the SSH service as you would on a Unix/Linux host."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:534
msgid "When using SSH key authentication with Ansible, the remote session won't have access to the user's credentials and will fail when attempting to access a network resource. This is also known as the double-hop or credential delegation issue. There are two ways to work around this issue:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:539
msgid "Use plaintext password auth by setting ``ansible_password``"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:540
msgid "Use ``become`` on the task with the credentials of the user that needs access to the remote resource"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:543
msgid "Configuring Ansible for SSH on Windows"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:544
msgid "To configure Ansible to use SSH for Windows hosts, you must set two connection variables:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:546
msgid "set ``ansible_connection`` to ``ssh``"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:547
msgid "set ``ansible_shell_type`` to ``cmd`` or ``powershell``"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:549
msgid "The ``ansible_shell_type`` variable should reflect the ``DefaultShell`` configured on the Windows host. Set to ``cmd`` for the default shell or set to ``powershell`` if the ``DefaultShell`` has been changed to PowerShell."
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:554
msgid "Known issues with SSH on Windows"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:555
msgid "Using SSH with Windows is experimental, and we expect to uncover more issues. Here are the known ones:"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:558
msgid "Win32-OpenSSH versions older than ``v7.9.0.0p1-Beta`` do not work when ``powershell`` is the shell type"
msgstr ""

#: ../../rst/user_guide/windows_setup.rst:559
msgid "While SCP should work, SFTP is the recommended SSH file transfer mechanism to use when copying or fetching a file"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:2
msgid "Using Ansible and Windows"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:3
msgid "When using Ansible to manage Windows, many of the syntax and rules that apply for Unix/Linux hosts also apply to Windows, but there are still some differences when it comes to components like path separators and OS-specific tasks. This document covers details specific to using Ansible for Windows."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:12
msgid "Use Cases"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:13
msgid "Ansible can be used to orchestrate a multitude of tasks on Windows servers. Below are some examples and info about common tasks."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:17
msgid "Installing Software"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:18
msgid "There are three main ways that Ansible can be used to install software:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:20
msgid "Using the ``win_chocolatey`` module. This sources the program data from the default public `Chocolatey <https://chocolatey.org/>`_ repository. Internal repositories can be used instead by setting the ``source`` option."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:24
msgid "Using the ``win_package`` module. This installs software using an MSI or .exe installer from a local/network path or URL."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:27
msgid "Using the ``win_command`` or ``win_shell`` module to run an installer manually."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:29
msgid "The ``win_chocolatey`` module is recommended since it has the most complete logic for checking to see if a package has already been installed and is up-to-date."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:31
msgid "Below are some examples of using all three options to install 7-Zip:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:81
msgid "Some installers like Microsoft Office or SQL Server require credential delegation or access to components restricted by WinRM. The best method to bypass these issues is to use ``become`` with the task. With ``become``, Ansible will run the installer as if it were run interactively on the host."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:86
msgid "Many installers do not properly pass back error information over WinRM. In these cases, if the install has been  verified to work locally the recommended method is to use become."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:88
msgid "Some installers restart the WinRM or HTTP services, or cause them to become temporarily unavailable, making Ansible assume the system is unreachable."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:91
msgid "Installing Updates"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:92
msgid "The ``win_updates`` and ``win_hotfix`` modules can be used to install updates or hotfixes on a host. The module ``win_updates`` is used to install multiple updates by category, while ``win_hotfix`` can be used to install a single update or hotfix file that has been downloaded locally."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:97
msgid "The ``win_hotfix`` module has a requirement that the DISM PowerShell cmdlets are present. These cmdlets were only added by default on Windows Server 2012 and newer and must be installed on older Windows hosts."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:101
msgid "The following example shows how ``win_updates`` can be used:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:117
msgid "The following example show how ``win_hotfix`` can be used to install a single update or hotfix:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:139
msgid "Set Up Users and Groups"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:140
msgid "Ansible can be used to create Windows users and groups both locally and on a domain."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:143
msgid "Local"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:144
msgid "The modules ``win_user``, ``win_group`` and ``win_group_membership`` manage Windows users, groups and group memberships locally."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:147
msgid "The following is an example of creating local accounts and groups that can access a folder on the same host:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:190
msgid "Domain"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:191
msgid "The modules ``win_domain_user`` and ``win_domain_group`` manages users and groups in a domain. The below is an example of ensuring a batch of domain users are created:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:217
msgid "Running Commands"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:218
msgid "In cases where there is no appropriate module available for a task, a command or script can be run using the ``win_shell``, ``win_command``, ``raw``, and ``script`` modules."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:221
msgid "The ``raw`` module simply executes a Powershell command remotely. Since ``raw`` has none of the wrappers that Ansible typically uses, ``become``, ``async`` and environment variables do not work."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:225
msgid "The ``script`` module executes a script from the Ansible controller on one or more Windows hosts. Like ``raw``, ``script`` currently does not support ``become``, ``async``, or environment variables."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:229
msgid "The ``win_command`` module is used to execute a command which is either an executable or batch file, while the ``win_shell`` module is used to execute commands within a shell."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:233
msgid "Choosing Command or Shell"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:234
msgid "The ``win_shell`` and ``win_command`` modules can both be used to execute a command or commands. The ``win_shell`` module is run within a shell-like process like ``PowerShell`` or ``cmd``, so it has access to shell operators like ``<``, ``>``, ``|``, ``;``, ``&&``, and ``||``. Multi-lined commands can also be run in ``win_shell``."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:238
msgid "The ``win_command`` module simply runs a process outside of a shell. It can still run a shell command like ``mkdir`` or ``New-Item`` by passing the shell commands to a shell executable like ``cmd.exe`` or ``PowerShell.exe``."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:242
msgid "Here are some examples of using ``win_command`` and ``win_shell``:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:270
msgid "Some commands like ``mkdir``, ``del``, and ``copy`` only exist in the CMD shell. To run them with ``win_command`` they must be prefixed with ``cmd.exe /c``."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:275
msgid "Argument Rules"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:276
msgid "When running a command through ``win_command``, the standard Windows argument rules apply:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:279
msgid "Each argument is delimited by a white space, which can either be a space or a tab."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:282
msgid "An argument can be surrounded by double quotes ``\"``. Anything inside these quotes is interpreted as a single argument even if it contains whitespace."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:285
msgid "A double quote preceded by a backslash ``\\`` is interpreted as just a double quote ``\"`` and not as an argument delimiter."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:288
msgid "Backslashes are interpreted literally unless it immediately precedes double quotes; for example ``\\`` == ``\\`` and ``\\\"`` == ``\"``"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:291
msgid "If an even number of backslashes is followed by a double quote, one backslash is used in the argument for every pair, and the double quote is used as a string delimiter for the argument."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:295
msgid "If an odd number of backslashes is followed by a double quote, one backslash is used in the argument for every pair, and the double quote is escaped and made a literal double quote in the argument."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:299
msgid "With those rules in mind, here are some examples of quoting:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:324
msgid "For more information, see `escaping arguments <https://msdn.microsoft.com/en-us/library/17w5ykft(v=vs.85).aspx>`_."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:327
msgid "Creating and Running a Scheduled Task"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:328
msgid "WinRM has some restrictions in place that cause errors when running certain commands. One way to bypass these restrictions is to run a command through a scheduled task. A scheduled task is a Windows component that provides the ability to run an executable on a schedule and under a different account."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:333
msgid "Ansible version 2.5 added modules that make it easier to work with scheduled tasks in Windows. The following is an example of running a script as a scheduled task that deletes itself after running:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:362
msgid "The modules used in the above example were updated/added in Ansible version 2.5."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:366
msgid "Path Formatting for Windows"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:367
msgid "Windows differs from a traditional POSIX operating system in many ways. One of the major changes is the shift from ``/`` as the path separator to ``\\``. This can cause major issues with how playbooks are written, since ``\\`` is often used as an escape character on POSIX systems."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:372
msgid "Ansible allows two different styles of syntax; each deals with path separators for Windows differently:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:375
msgid "YAML Style"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:376
msgid "When using the YAML syntax for tasks, the rules are well-defined by the YAML standard:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:379
msgid "When using a normal string (without quotes), YAML will not consider the backslash an escape character."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:382
msgid "When using single quotes ``'``, YAML will not consider the backslash an escape character."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:385
msgid "When using double quotes ``\"``, the backslash is considered an escape character and needs to escaped with another backslash."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:388
msgid "You should only quote strings when it is absolutely necessary or required by YAML, and then use single quotes."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:391
msgid "The YAML specification considers the following `escape sequences <https://yaml.org/spec/current.html#id2517668>`_:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:393
msgid "``\\0``, ``\\\\``, ``\\\"``, ``\\_``, ``\\a``, ``\\b``, ``\\e``, ``\\f``, ``\\n``, ``\\r``, ``\\t``, ``\\v``, ``\\L``, ``\\N`` and ``\\P`` -- Single character escape"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:396
msgid "``<TAB>``, ``<SPACE>``, ``<NBSP>``, ``<LNSP>``, ``<PSP>`` -- Special characters"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:399
#: ../../rst/user_guide/windows_usage.rst:449
msgid "``\\x..`` -- 2-digit hex escape"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:401
#: ../../rst/user_guide/windows_usage.rst:451
msgid "``\\u....`` -- 4-digit hex escape"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:403
#: ../../rst/user_guide/windows_usage.rst:453
msgid "``\\U........`` -- 8-digit hex escape"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:405
msgid "Here are some examples on how to write Windows paths::"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:419
msgid "This is an example which will fail:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:426
msgid "This example shows the use of single quotes when they are required::"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:435
msgid "Legacy key=value Style"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:436
msgid "The legacy ``key=value`` syntax is used on the command line for ad-hoc commands, or inside playbooks. The use of this style is discouraged within playbooks because backslash characters need to be escaped, making playbooks harder to read. The legacy syntax depends on the specific implementation in Ansible, and quoting (both single and double) does not have any effect on how it is parsed by Ansible."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:443
msgid "The Ansible key=value parser parse_kv() considers the following escape sequences:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:446
msgid "``\\``, ``'``, ``\"``, ``\\a``, ``\\b``, ``\\f``, ``\\n``, ``\\r``, ``\\t`` and ``\\v`` -- Single character escape"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:455
msgid "``\\N{...}`` -- Unicode character by name"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:457
msgid "This means that the backslash is an escape character for some sequences, and it is usually safer to escape a backslash when in this form."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:460
msgid "Here are some examples of using Windows paths with the key=value style:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:482
msgid "The failing examples don't fail outright but will substitute ``\\t`` with the ``<TAB>`` character resulting in ``tempdir`` being ``C:\\Windows<TAB>emp``."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:486
#: ../../rst/user_guide/windows_winrm.rst:866
msgid "Limitations"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:487
msgid "Some things you cannot do with Ansible and Windows are:"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:489
msgid "Upgrade PowerShell"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:491
msgid "Interact with the WinRM listeners"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:493
msgid "Because WinRM is reliant on the services being online and running during normal operations, you cannot upgrade PowerShell or interact with WinRM listeners with Ansible. Both of these actions will cause the connection to fail. This can technically be avoided by using ``async`` or a scheduled task, but those methods are fragile if the process it runs breaks the underlying connection Ansible uses, and are best left to the bootstrapping process or before an image is created."
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:497
msgid "Developing Windows Modules"
msgstr ""

#: ../../rst/user_guide/windows_usage.rst:498
msgid "Because Ansible modules for Windows are written in PowerShell, the development guides for Windows modules differ substantially from those for standard standard modules. Please see :ref:`developing_modules_general_windows` for more information."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:4
msgid "Windows Remote Management"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:5
msgid "Unlike Linux/Unix hosts, which use SSH by default, Windows hosts are configured with WinRM. This topic covers how to configure and use WinRM with Ansible."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:12
msgid "What is WinRM?"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:13
msgid "WinRM is a management protocol used by Windows to remotely communicate with another server. It is a SOAP-based protocol that communicates over HTTP/HTTPS, and is included in all recent Windows operating systems. Since Windows Server 2012, WinRM has been enabled by default, but in most cases extra configuration is required to use WinRM with Ansible."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:19
msgid "Ansible uses the `pywinrm <https://github.com/diyan/pywinrm>`_ package to communicate with Windows servers over WinRM. It is not installed by default with the Ansible package, but can be installed by running the following:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:27
msgid "on distributions with multiple python versions, use pip2 or pip2.x, where x matches the python minor version Ansible is running under."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:31
msgid "Using the ``winrm`` or ``psrp`` connection plugins in Ansible on MacOS in the latest releases typically fail. This is a known problem that occurs deep within the Python stack and cannot be changed by Ansible. The only workaround today is to set the environment variable ``no_proxy=*`` and avoid using Kerberos auth."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:39
msgid "Authentication Options"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:40
msgid "When connecting to a Windows host, there are several different options that can be used when authenticating with an account. The authentication type may be set on inventory hosts or groups with the ``ansible_winrm_transport`` variable."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:44
msgid "The following matrix is a high level overview of the options:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:47
msgid "Option"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:47
msgid "Local Accounts"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:47
msgid "Active Directory Accounts"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:47
msgid "Credential Delegation"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:47
msgid "HTTP Encryption"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:49
#: ../../rst/user_guide/windows_winrm.rst:61
msgid "Basic"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:49
#: ../../rst/user_guide/windows_winrm.rst:51
#: ../../rst/user_guide/windows_winrm.rst:53
#: ../../rst/user_guide/windows_winrm.rst:55
#: ../../rst/user_guide/windows_winrm.rst:57
msgid "Yes"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:49
#: ../../rst/user_guide/windows_winrm.rst:51
#: ../../rst/user_guide/windows_winrm.rst:53
#: ../../rst/user_guide/windows_winrm.rst:55
msgid "No"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:51
#: ../../rst/user_guide/windows_winrm.rst:82
msgid "Certificate"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:53
#: ../../rst/user_guide/windows_winrm.rst:268
msgid "Kerberos"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:55
#: ../../rst/user_guide/windows_winrm.rst:241
msgid "NTLM"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:57
#: ../../rst/user_guide/windows_winrm.rst:455
msgid "CredSSP"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:62
msgid "Basic authentication is one of the simplest authentication options to use, but is also the most insecure. This is because the username and password are simply base64 encoded, and if a secure channel is not in use (eg, HTTPS) then it can be decoded by anyone. Basic authentication can only be used for local accounts (not domain accounts)."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:67
msgid "The following example shows host vars configured for basic authentication:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:76
msgid "Basic authentication is not enabled by default on a Windows host but can be enabled by running the following in PowerShell::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:83
msgid "Certificate authentication uses certificates as keys similar to SSH key pairs, but the file format and key generation process is different."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:86
msgid "The following example shows host vars configured for certificate authentication:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:95
msgid "Certificate authentication is not enabled by default on a Windows host but can be enabled by running the following in PowerShell::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:100
msgid "Encrypted private keys cannot be used as the urllib3 library that is used by Ansible for WinRM does not support this functionality."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:104
msgid "Generate a Certificate"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:105
msgid "A certificate must be generated before it can be mapped to a local user. This can be done using one of the following methods:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:108
msgid "OpenSSL"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:109
msgid "PowerShell, using the ``New-SelfSignedCertificate`` cmdlet"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:110
msgid "Active Directory Certificate Services"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:112
msgid "Active Directory Certificate Services is beyond of scope in this documentation but may be the best option to use when running in a domain environment. For more information, see the `Active Directory Certificate Services documentation <https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732625(v=ws.11)>`_."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:116
msgid "Using the PowerShell cmdlet ``New-SelfSignedCertificate`` to generate a certificate for authentication only works when being generated from a Windows 10 or Windows Server 2012 R2 host or later. OpenSSL is still required to extract the private key from the PFX certificate to a PEM file for Ansible to use."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:122
msgid "To generate a certificate with ``OpenSSL``:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:142
msgid "To generate a certificate with ``New-SelfSignedCertificate``:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:170
msgid "To convert the PFX file to a private key that pywinrm can use, run the following command with OpenSSL ``openssl pkcs12 -in cert.pfx -nocerts -nodes -out cert_key.pem -passin pass: -passout pass:``"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:175
msgid "Import a Certificate to the Certificate Store"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:176
msgid "Once a certificate has been generated, the issuing certificate needs to be imported into the ``Trusted Root Certificate Authorities`` of the ``LocalMachine`` store, and the client certificate public key must be present in the ``Trusted People`` folder of the ``LocalMachine`` store. For this example, both the issuing certificate and public key are the same."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:182
msgid "Following example shows how to import the issuing certificate:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:197
msgid "If using ADCS to generate the certificate, then the issuing certificate will already be imported and this step can be skipped."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:200
msgid "The code to import the client certificate public key is:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:216
msgid "Mapping a Certificate to an Account"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:217
msgid "Once the certificate has been imported, map it to the local user account::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:236
msgid "Once this is complete, the hostvar ``ansible_winrm_cert_pem`` should be set to the path of the public key and the ``ansible_winrm_cert_key_pem`` variable should be set to the path of the private key."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:242
msgid "NTLM is an older authentication mechanism used by Microsoft that can support both local and domain accounts. NTLM is enabled by default on the WinRM service, so no setup is required before using it."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:246
msgid "NTLM is the easiest authentication protocol to use and is more secure than ``Basic`` authentication. If running in a domain environment, ``Kerberos`` should be used instead of NTLM."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:250
msgid "Kerberos has several advantages over using NTLM:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:252
msgid "NTLM is an older protocol and does not support newer encryption protocols."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:254
msgid "NTLM is slower to authenticate because it requires more round trips to the host in the authentication stage."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:256
msgid "Unlike Kerberos, NTLM does not allow credential delegation."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:258
msgid "This example shows host variables configured to use NTLM authentication:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:269
msgid "Kerberos is the recommended authentication option to use when running in a domain environment. Kerberos supports features like credential delegation and message encryption over HTTP and is one of the more secure options that is available through WinRM."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:274
msgid "Kerberos requires some additional setup work on the Ansible host before it can be used properly."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:277
msgid "The following example shows host vars configured for Kerberos authentication:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:286
msgid "As of Ansible version 2.3, the Kerberos ticket will be created based on ``ansible_user`` and ``ansible_password``. If running on an older version of Ansible or when ``ansible_winrm_kinit_mode`` is ``manual``, a Kerberos ticket must already be obtained. See below for more details."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:291
msgid "There are some extra host variables that can be set::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:300
msgid "Installing the Kerberos Library"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:301
msgid "Some system dependencies that must be installed prior to using Kerberos. The script below lists the dependencies based on the distro:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:327
msgid "Once the dependencies have been installed, the ``python-kerberos`` wrapper can be install using ``pip``:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:336
msgid "While Ansible has supported Kerberos auth through ``pywinrm`` for some time, optional features or more secure options may only be available in newer versions of the ``pywinrm`` and/or ``pykerberos`` libraries. It is recommended you upgrade each version to the latest available to resolve any warnings or errors. This can be done through tools like ``pip`` or a system package manager like ``dnf``, ``yum``, ``apt`` but the package names and versions available may differ between tools."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:346
msgid "Configuring Host Kerberos"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:347
msgid "Once the dependencies have been installed, Kerberos needs to be configured so that it can communicate with a domain. This configuration is done through the ``/etc/krb5.conf`` file, which is installed with the packages in the script above."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:351
msgid "To configure Kerberos, in the section that starts with:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:357
msgid "Add the full domain name and the fully qualified domain names of the primary and secondary Active Directory domain controllers. It should look something like this:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:369
msgid "In the section that starts with:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:375
msgid "Add a line like the following for each domain that Ansible needs access for:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:382
msgid "You can configure other settings in this file such as the default domain. See `krb5.conf <https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html>`_ for more details."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:387
msgid "Automatic Kerberos Ticket Management"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:388
msgid "Ansible version 2.3 and later defaults to automatically managing Kerberos tickets when both ``ansible_user`` and ``ansible_password`` are specified for a host. In this process, a new ticket is created in a temporary credential cache for each host. This is done before each task executes to minimize the chance of ticket expiration. The temporary credential caches are deleted after each task completes and will not interfere with the default credential cache."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:395
msgid "To disable automatic ticket management, set ``ansible_winrm_kinit_mode=manual`` via the inventory."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:398
msgid "Automatic ticket management requires a standard ``kinit`` binary on the control host system path. To specify a different location or binary name, set the ``ansible_winrm_kinit_cmd`` hostvar to the fully qualified path to a MIT krbv5 ``kinit``-compatible binary."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:404
msgid "Manual Kerberos Ticket Management"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:405
msgid "To manually manage Kerberos tickets, the ``kinit`` binary is used. To obtain a new ticket the following command is used:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:412
msgid "The domain must match the configured Kerberos realm exactly, and must be in upper case."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:414
msgid "To see what tickets (if any) have been acquired, use the following command:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:420
msgid "To destroy all the tickets that have been acquired, use the following command:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:427
msgid "Troubleshooting Kerberos"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:428
msgid "Kerberos is reliant on a properly-configured environment to work. To troubleshoot Kerberos issues, ensure that:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:431
msgid "The hostname set for the Windows host is the FQDN and not an IP address."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:433
msgid "The forward and reverse DNS lookups are working properly in the domain. To test this, ping the windows host by name and then use the ip address returned with ``nslookup``. The same name should be returned when using ``nslookup`` on the IP address."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:438
msgid "The Ansible host's clock is synchronized with the domain controller. Kerberos is time sensitive, and a little clock drift can cause the ticket generation process to fail."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:442
msgid "Ensure that the fully qualified domain name for the domain is configured in the ``krb5.conf`` file. To check this, run::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:448
msgid "If the domain name returned by ``klist`` is different from the one requested, an alias is being used. The ``krb5.conf`` file needs to be updated so that the fully qualified domain name is used and not an alias."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:452
msgid "If the default kerberos tooling has been replaced or modified (some IdM solutions may do this), this may cause issues when installing or upgrading the Python Kerberos library. As of the time of this writing, this library is called ``pykerberos`` and is known to work with both MIT and Heimdal Kerberos libraries. To resolve ``pykerberos`` installation issues, ensure the system dependencies for Kerberos have been met (see: `Installing the Kerberos Library`_), remove any custom Kerberos tooling paths from the PATH environment variable, and retry the installation of Python Kerberos library package."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:456
msgid "CredSSP authentication is a newer authentication protocol that allows credential delegation. This is achieved by encrypting the username and password after authentication has succeeded and sending that to the server using the CredSSP protocol."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:461
msgid "Because the username and password are sent to the server to be used for double hop authentication, ensure that the hosts that the Windows host communicates with are not compromised and are trusted."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:465
msgid "CredSSP can be used for both local and domain accounts and also supports message encryption over HTTP."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:468
msgid "To use CredSSP authentication, the host vars are configured like so:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:477
msgid "There are some extra host variables that can be set as shown below::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:481
msgid "CredSSP authentication is not enabled by default on a Windows host, but can be enabled by running the following in PowerShell:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:489
msgid "Installing CredSSP Library"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:491
msgid "The ``requests-credssp`` wrapper can be installed using ``pip``:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:498
msgid "CredSSP and TLS 1.2"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:499
msgid "By default the ``requests-credssp`` library is configured to authenticate over the TLS 1.2 protocol. TLS 1.2 is installed and enabled by default for Windows Server 2012 and Windows 8 and more recent releases."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:503
msgid "There are two ways that older hosts can be used with CredSSP:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:505
msgid "Install and enable a hotfix to enable TLS 1.2 support (recommended for Server 2008 R2 and Windows 7)."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:508
msgid "Set ``ansible_winrm_credssp_disable_tlsv1_2=True`` in the inventory to run over TLS 1.0. This is the only option when connecting to Windows Server 2008, which has no way of supporting TLS 1.2"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:512
msgid "See :ref:`winrm_tls12` for more information on how to enable TLS 1.2 on the Windows host."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:516
msgid "Set CredSSP Certificate"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:517
msgid "CredSSP works by encrypting the credentials through the TLS protocol and uses a self-signed certificate by default. The ``CertificateThumbprint`` option under the WinRM service configuration can be used to specify the thumbprint of another certificate."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:520
msgid "This certificate configuration is independent of the WinRM listener certificate. With CredSSP, message transport still occurs over the WinRM listener, but the TLS-encrypted messages inside the channel use the service-level certificate."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:524
msgid "To explicitly set the certificate to use for CredSSP::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:534
msgid "Non-Administrator Accounts"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:535
msgid "WinRM is configured by default to only allow connections from accounts in the local ``Administrators`` group. This can be changed by running:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:542
msgid "This will display an ACL editor, where new users or groups may be added. To run commands over WinRM, users and groups must have at least the ``Read`` and ``Execute`` permissions enabled."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:546
msgid "While non-administrative accounts can be used with WinRM, most typical server administration tasks require some level of administrative access, so the utility is usually limited."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:550
msgid "WinRM Encryption"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:551
msgid "By default WinRM will fail to work when running over an unencrypted channel. The WinRM protocol considers the channel to be encrypted if using TLS over HTTP (HTTPS) or using message level encryption. Using WinRM with TLS is the recommended option as it works with all authentication options, but requires a certificate to be created and used on the WinRM listener."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:557
msgid "The ``ConfigureRemotingForAnsible.ps1`` creates a self-signed certificate and creates the listener with that certificate. If in a domain environment, ADCS can also create a certificate for the host that is issued by the domain itself."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:561
msgid "If using HTTPS is not an option, then HTTP can be used when the authentication option is ``NTLM``, ``Kerberos`` or ``CredSSP``. These protocols will encrypt the WinRM payload with their own encryption method before sending it to the server. The message-level encryption is not used when running over HTTPS because the encryption uses the more secure TLS protocol instead. If both transport and message encryption is required, set ``ansible_winrm_message_encryption=always`` in the host vars."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:569
msgid "Message encryption over HTTP requires pywinrm>=0.3.0."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:571
msgid "A last resort is to disable the encryption requirement on the Windows host. This should only be used for development and debugging purposes, as anything sent from Ansible can be viewed, manipulated and also the remote session can completely be taken over by anyone on the same network. To disable the encryption requirement::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:579
msgid "Do not disable the encryption check unless it is absolutely required. Doing so could allow sensitive information like credentials and files to be intercepted by others on the network."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:584
msgid "Inventory Options"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:585
msgid "Ansible's Windows support relies on a few standard variables to indicate the username, password, and connection type of the remote hosts. These variables are most easily set up in the inventory, but can be set on the ``host_vars``/ ``group_vars`` level."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:590
msgid "When setting up the inventory, the following variables are required:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:605
msgid "Using the variables above, Ansible will connect to the Windows host with Basic authentication through HTTPS. If ``ansible_user`` has a UPN value like ``username@MY.DOMAIN.COM`` then the authentication option will automatically attempt to use Kerberos unless ``ansible_winrm_transport`` has been set to something other than ``kerberos``."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:611
msgid "The following custom inventory variables are also supported for additional configuration of WinRM connections:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:614
msgid "``ansible_port``: The port WinRM will run over, HTTPS is ``5986`` which is the default while HTTP is ``5985``"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:617
msgid "``ansible_winrm_scheme``: Specify the connection scheme (``http`` or ``https``) to use for the WinRM connection. Ansible uses ``https`` by default unless ``ansible_port`` is ``5985``"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:621
msgid "``ansible_winrm_path``: Specify an alternate path to the WinRM endpoint, Ansible uses ``/wsman`` by default"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:624
msgid "``ansible_winrm_realm``: Specify the realm to use for Kerberos authentication. If ``ansible_user`` contains ``@``, Ansible will use the part of the username after ``@`` by default"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:628
msgid "``ansible_winrm_transport``: Specify one or more authentication transport options as a comma-separated list. By default, Ansible will use ``kerberos, basic`` if the ``kerberos`` module is installed and a realm is defined, otherwise it will be ``plaintext``"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:633
msgid "``ansible_winrm_server_cert_validation``: Specify the server certificate validation mode (``ignore`` or ``validate``). Ansible defaults to ``validate`` on Python 2.7.9 and higher, which will result in certificate validation errors against the Windows self-signed certificates. Unless verifiable certificates have been configured on the WinRM listeners, this should be set to ``ignore``"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:640
msgid "``ansible_winrm_operation_timeout_sec``: Increase the default timeout for WinRM operations, Ansible uses ``20`` by default"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:643
msgid "``ansible_winrm_read_timeout_sec``: Increase the WinRM read timeout, Ansible uses ``30`` by default. Useful if there are intermittent network issues and read timeout errors keep occurring"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:647
msgid "``ansible_winrm_message_encryption``: Specify the message encryption operation (``auto``, ``always``, ``never``) to use, Ansible uses ``auto`` by default. ``auto`` means message encryption is only used when ``ansible_winrm_scheme`` is ``http`` and ``ansible_winrm_transport`` supports message encryption. ``always`` means message encryption will always be used and ``never`` means message encryption will never be used"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:654
msgid "``ansible_winrm_ca_trust_path``: Used to specify a different cacert container than the one used in the ``certifi`` module. See the HTTPS Certificate Validation section for more details."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:658
msgid "``ansible_winrm_send_cbt``: When using ``ntlm`` or ``kerberos`` over HTTPS, the authentication library will try to send channel binding tokens to mitigate against man in the middle attacks. This flag controls whether these bindings will be sent or not (default: ``yes``)."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:663
msgid "``ansible_winrm_*``: Any additional keyword arguments supported by ``winrm.Protocol`` may be provided in place of ``*``"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:666
msgid "In addition, there are also specific variables that need to be set for each authentication option. See the section on authentication above for more information."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:669
msgid "Ansible 2.0 has deprecated the \"ssh\" from ``ansible_ssh_user``, ``ansible_ssh_pass``, ``ansible_ssh_host``, and ``ansible_ssh_port`` to become ``ansible_user``, ``ansible_password``, ``ansible_host``, and ``ansible_port``. If using a version of Ansible prior to 2.0, the older style (``ansible_ssh_*``) should be used instead. The shorter variables are ignored, without warning, in older versions of Ansible."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:676
msgid "``ansible_winrm_message_encryption`` is different from transport encryption done over TLS. The WinRM payload is still encrypted with TLS when run over HTTPS, even if ``ansible_winrm_message_encryption=never``."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:681
msgid "IPv6 Addresses"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:682
msgid "IPv6 addresses can be used instead of IPv4 addresses or hostnames. This option is normally set in an inventory. Ansible will attempt to parse the address using the `ipaddress <https://docs.python.org/3/library/ipaddress.html>`_ package and pass to pywinrm correctly."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:687
msgid "When defining a host using an IPv6 address, just add the IPv6 address as you would an IPv4 address or hostname:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:701
msgid "The ipaddress library is only included by default in Python 3.x. To use IPv6 addresses in Python 2.7, make sure to run ``pip install ipaddress`` which installs a backported package."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:706
msgid "HTTPS Certificate Validation"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:707
msgid "As part of the TLS protocol, the certificate is validated to ensure the host matches the subject and the client trusts the issuer of the server certificate. When using a self-signed certificate or setting ``ansible_winrm_server_cert_validation: ignore`` these security mechanisms are bypassed. While self signed certificates will always need the ``ignore`` flag, certificates that have been issued from a certificate authority can still be validated."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:715
msgid "One of the more common ways of setting up a HTTPS listener in a domain environment is to use Active Directory Certificate Service (AD CS). AD CS is used to generate signed certificates from a Certificate Signing Request (CSR). If the WinRM HTTPS listener is using a certificate that has been signed by another authority, like AD CS, then Ansible can be set up to trust that issuer as part of the TLS handshake."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:722
msgid "To get Ansible to trust a Certificate Authority (CA) like AD CS, the issuer certificate of the CA can be exported as a PEM encoded certificate. This certificate can then be copied locally to the Ansible controller and used as a source of certificate validation, otherwise known as a CA chain."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:727
msgid "The CA chain can contain a single or multiple issuer certificates and each entry is contained on a new line. To then use the custom CA chain as part of the validation process, set ``ansible_winrm_ca_trust_path`` to the path of the file. If this variable is not set, the default CA chain is used instead which is located in the install path of the Python package `certifi <https://github.com/certifi/python-certifi>`_."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:734
msgid "Each HTTP call is done by the Python requests library which does not use the systems built-in certificate store as a trust authority. Certificate validation will fail if the server's certificate issuer is only added to the system's truststore."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:742
msgid "TLS 1.2 Support"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:743
msgid "As WinRM runs over the HTTP protocol, using HTTPS means that the TLS protocol is used to encrypt the WinRM messages. TLS will automatically attempt to negotiate the best protocol and cipher suite that is available to both the client and the server. If a match cannot be found then Ansible will error out with a message similar to::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:751
msgid "Commonly this is when the Windows host has not been configured to support TLS v1.2 but it could also mean the Ansible controller has an older OpenSSL version installed."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:755
msgid "Windows 8 and Windows Server 2012 come with TLS v1.2 installed and enabled by default but older hosts, like Server 2008 R2 and Windows 7, have to be enabled manually."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:759
msgid "There is a bug with the TLS 1.2 patch for Server 2008 which will stop Ansible from connecting to the Windows host. This means that Server 2008 cannot be configured to use TLS 1.2. Server 2008 R2 and Windows 7 are not affected by this issue and can use TLS 1.2."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:764
msgid "To verify what protocol the Windows host supports, you can run the following command on the Ansible controller::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:769
msgid "The output will contain information about the TLS session and the ``Protocol`` line will display the version that was negotiated::"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:805
msgid "If the host is returning ``TLSv1`` then it should be configured so that TLS v1.2 is enable. You can do this by running the following PowerShell script:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:830
msgid "The below Ansible tasks can also be used to enable TLS v1.2:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:860
msgid "There are other ways to configure the TLS protocols as well as the cipher suites that are offered by the Windows host. One tool that can give you a GUI to manage these settings is `IIS Crypto <https://www.nartac.com/Products/IISCrypto/>`_ from Nartac Software."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:867
msgid "Due to the design of the WinRM protocol , there are a few limitations when using WinRM that can cause issues when creating playbooks for Ansible. These include:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:871
msgid "Credentials are not delegated for most authentication types, which causes authentication errors when accessing network resources or installing certain programs."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:875
msgid "Many calls to the Windows Update API are blocked when running over WinRM."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:877
msgid "Some programs fail to install with WinRM due to no credential delegation or because they access forbidden Windows API like WUA over WinRM."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:880
msgid "Commands under WinRM are done under a non-interactive session, which can prevent certain commands or executables from running."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:883
msgid "You cannot run a process that interacts with ``DPAPI``, which is used by some installers (like Microsoft SQL Server)."
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:886
msgid "Some of these limitations can be mitigated by doing one of the following:"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:888
msgid "Set ``ansible_winrm_transport`` to ``credssp`` or ``kerberos`` (with ``ansible_winrm_kerberos_delegation=true``) to bypass the double hop issue and access network resources"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:892
msgid "Use ``become`` to bypass all WinRM restrictions and run a command as it would locally. Unlike using an authentication transport like ``credssp``, this will also remove the non-interactive restriction and API restrictions like WUA and DPAPI"
msgstr ""

#: ../../rst/user_guide/windows_winrm.rst:897
msgid "Use a scheduled task to run a command which can be created with the ``win_scheduled_task`` module. Like ``become``, this bypasses all WinRM restrictions but can only run a command and not modules."
msgstr ""

